<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>人生ゲーム ver-15</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      /* Allowed palette:
         - #000000 (black)
         - #FFFFFF (white)
         - #86BB27 (green)
         - #C4C4C4 (gray)
         - #DFF3C6 (lightened 86BB27)
      */
      --black: #000000;
      --white: #FFFFFF;
      --green: #86BB27;
      --green-light: #DFF3C6; /* 86BB27 を薄めた色 */
      --gray: #C4C4C4;

      --board-cols:10; --board-rows:6; --cell-size:68px;
      --accent: var(--green);
      --bg: var(--white);
      --text: var(--black);
      --active: rgba(0,0,0,0.08);
      --ok: var(--green);
      --muted: var(--gray);
      --zoom-step:8px;
      --board-max-width: calc(var(--cell-size) * var(--board-cols) + 32px);

      /* UI style tokens */
      --btn-radius: 12px;
      --card-radius: 14px;
      --card-shadow: 0 12px 30px rgba(0,0,0,0.08);
      --btn-shadow: 0 8px 20px rgba(0,0,0,0.06);
      --btn-hover-shadow: 0 12px 28px rgba(0,0,0,0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; align-items:stretch;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--text); background:var(--bg);
      min-height:100vh;
    }

    /* ===== App Bar / Toolbar ===== */
    .appbar{
      position:sticky; top:0; z-index:1100; width:100%;
      display:flex; justify-content:center;
      background:linear-gradient(180deg, rgba(255,255,255,.98), rgba(255,255,255,.95));
      backdrop-filter:saturate(0.9); border-bottom:1px solid rgba(0,0,0,0.06);
      pointer-events:auto;
      box-shadow: 0 4px 18px rgba(0,0,0,0.03);
    }
    .toolbar{width:100%; padding:10px 12px; display:flex; flex-wrap:wrap; align-items:center; gap:10px}
    .title{font-weight:800; font-size:16px; color:var(--black); letter-spacing:.02em; white-space:nowrap; margin-right:auto}

    .group{display:flex; align-items:center; gap:8px; padding:8px 10px; background:var(--white); border:1px solid var(--gray); border-radius:14px}
    label{font-size:12px; color:var(--black)}
    select,input[type="number"],input[type="text"],input[type="range"],textarea,select{
      padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white); color:var(--black);
    }
    input[type="range"]{width:120px}
    button{
      padding:8px 12px; border-radius:var(--btn-radius); border:1px solid var(--gray);
      background:var(--white); cursor:pointer; font-weight:700; color:var(--black);
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease, background .12s ease;
      box-shadow: none;
    }
    button.primary{
      background: linear-gradient(180deg, var(--green), var(--green-light));
      color:var(--black); border-color:transparent;
      box-shadow: var(--btn-shadow);
    }
    button:disabled{opacity:.45; cursor:not-allowed; box-shadow:none}
    button:hover:not(:disabled){ transform: translateY(-2px); box-shadow: var(--btn-hover-shadow); }

    .dice{width:44px; height:44px; display:grid; place-items:center; border-radius:12px; border:1px solid var(--gray); background:var(--white); font-weight:800; color:var(--black)}
    .dice.spin{animation:spin .6s ease}
    @keyframes spin{0%{transform:rotate(0)}50%{transform:rotate(180deg) scale(1.05)}100%{transform:rotate(360deg)}}

    /* player name inputs */
    .player-names { display:flex; gap:8px; align-items:center; }
    .player-names input { width:140px; padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white); color:var(--black) }

    /* ===== Layout ===== */
    .wrap{width:100%; padding:16px; display:grid; grid-template-columns:3fr 1.1fr; gap:12px; flex:1; align-items:start}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* ===== Board ===== */
    .board-wrap{
      display:flex; justify-content:center; align-items:flex-start;
      overflow:auto;
      width:100%;
      padding-bottom:8px;
      -webkit-overflow-scrolling:touch;
      z-index:1;
    }
    .board{
      background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:12px; position:relative; display:grid; gap:8px;
      grid-template-columns:repeat(var(--board-cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      justify-content:center; align-content:start;
      min-width: var(--board-max-width);
      max-width: none;
      box-shadow: 0 6px 22px rgba(0,0,0,0.04);
    }
    .cell{background:var(--white); border:1px solid var(--gray); border-radius:12px; padding:8px; display:grid; place-items:center; font-size:12px; position:relative; cursor:default; color:var(--black)}
    .cell.start{background:linear-gradient(180deg,var(--green-light),var(--white))}
    .cell.goal{background:linear-gradient(180deg,var(--green),var(--green-light))}
    .cell.event{background:linear-gradient(180deg,var(--green-light),var(--white))}
    .cell.penalty{background:linear-gradient(180deg,#FBFBFB,var(--white))}
    .cell.bonus{background:linear-gradient(180deg,var(--green-light),#F8FFF2)}
    .cell.client{background:linear-gradient(180deg,var(--green-light),var(--white))}
    .cell.workshop{background:linear-gradient(180deg,var(--green-light),var(--white))}
    .cell .idx{position:absolute; top:6px; left:8px; font-size:10px; color:var(--black)}

    /* ===== Tokens ===== */
    .token{width:30px; height:30px; border-radius:50%; border:2px solid var(--black); display:grid; place-items:center; color:var(--white); font-size:12px; font-weight:800; box-shadow:0 8px 20px rgba(0,0,0,0.06)}
    .token.finished{opacity:.9; border-color:var(--gray)}
    .token.active{outline:3px solid rgba(0,0,0,0.08)}

    /* ===== Sidebar ===== */
    .sidebar{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:14px; display:grid; gap:12px; height:fit-content; z-index:2; box-shadow: 0 10px 30px rgba(0,0,0,0.04)}
    .stat{display:flex; justify-content:space-between; gap:8px; padding:10px 12px; background:linear-gradient(180deg,var(--white),#FBFBFB); border-radius:12px}
    .players{display:grid; gap:10px}
    /* compact two-column player row */
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:10px; align-items:center; padding:10px 12px; background:var(--white); border:1px solid var(--gray); border-radius:12px}
    .player-row.active{border-color:rgba(0,0,0,0.12); box-shadow:0 0 0 2px rgba(134,187,39,0.06) inset}
    .badge{width:20px; height:20px; border-radius:50%; border:2px solid var(--black); display:inline-block; margin-right:8px}

    .left-col{display:flex; align-items:center; gap:10px}
    .name-wrap{display:flex; flex-direction:column}
    .rank{font-weight:800; color:var(--black)}
    .salary{font-weight:700; color:var(--black); font-size:13px}

    .attr-list{display:flex; gap:8px; justify-content:flex-end; align-items:center}
    .attr{font-size:12px; background:var(--white); padding:6px 10px; border-radius:10px; border:1px solid var(--gray); min-width:86px; text-align:center; color:var(--black)}

    .log{border:1px solid var(--gray); border-radius:12px; background:linear-gradient(180deg,var(--white),#FBFBFB); padding:12px; max-height:320px; overflow:auto; font-size:13px; line-height:1.4}
    .log p{margin:0 0 8px}
    .log p.ok{color:var(--green)}
    .log p.bad{color:var(--black)}
    .footer{font-size:12px; color:var(--black)}

    /* nice little flash for attribute changes */
    .flash-attr { animation: flashAttr 520ms ease; }
    @keyframes flashAttr {
      0% { transform: scale(1); background: var(--white); }
      50% { transform: scale(1.05); background: var(--green-light); }
      100% { transform: scale(1); background: var(--white); }
    }

    /* Modal card styling */
    .card{padding:16px; border-radius:var(--card-radius); background:var(--white); box-shadow:var(--card-shadow); border:1px solid var(--gray)}
    .card h3{margin:0 0 8px; color:var(--black)}
    .card p{margin:0 0 8px}
    .card .muted{color:var(--black); opacity:0.7; font-size:13px}
    .card .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:12px}
    .card .actions button{min-width:84px; padding:8px 12px; border-radius:12px; font-weight:800}

    /* ensure dialog buttons clickable */
    dialog button{pointer-events:auto}
  </style>
</head>
<body>
  <!-- App Bar -->
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title" id="app-title">人生ゲーム ver-15</div>

      <div class="group"><label for="players-count">人数</label>
        <select id="players-count">
          <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option>
        </select>
      </div>

      <div class="group"><label for="initial-money">初期(未使用)</label><input id="initial-money" type="number" value="50000" min="0" step="1000" /></div>

      <!-- Player name inputs -->
      <div class="group player-names" id="player-names"></div>

      <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>

      <button id="btn-start" class="primary" type="button">開始</button>
      <button id="btn-roll" disabled type="button">サイコロ</button>
      <button id="btn-reset" type="button">リセット</button>

      <button id="btn-settings" title="プレイヤー設定" type="button">設定</button>

      <!-- SECOND COLUMN: only zoom controls visible here -->
      <div class="group" style="margin-left:auto;">
        <button id="btn-zoom-in" title="ズームイン" type="button">ズーム＋</button>
        <button id="btn-zoom-out" title="ズームアウト" type="button">ズーム−</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <main class="board" id="board" aria-label="ボード"></main>
    </div>
    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>
      <div class="players" id="players-panel"></div>
      <div class="log" id="log" aria-live="polite" aria-atomic="false"></div>
      <div class="footer">Space/Enterでサイコロ。全員がゴールすると結果発表。</div>
    </aside>
  </div>

  <!-- Tooltip -->
  <div id="tooltip" role="tooltip" aria-hidden="true"></div>

  <!-- Modals -->
  <dialog class="modal" id="modal" aria-labelledby="modal-title">
    <div class="card">
      <h3 id="modal-title">イベント</h3>
      <div id="modal-text" style="white-space:normal;"></div>
      <div class="muted" id="modal-sub"></div>
      <div class="actions" id="modal-actions"></div>
    </div>
  </dialog>

  <dialog class="modal" id="history-modal" aria-labelledby="history-title">
    <div class="card">
      <h3 id="history-title">イベント履歴</h3>
      <div id="history-body" style="max-height:360px; overflow:auto;"></div>
      <div class="actions">
        <button id="history-close" class="primary" type="button">閉じる</button>
        <button id="history-clear" type="button">クリア</button>
      </div>
    </div>
  </dialog>

  <dialog class="modal" id="shortcuts-modal" aria-labelledby="shortcuts-title">
    <div class="card">
      <h3 id="shortcuts-title">操作ショートカット</h3>
      <div class="help-list">
        Space / Enter: サイコロを振る<br>
        H: このヘルプを開く/閉じる<br>
        Z / Shift+Z: ズームイン / ズームアウト<br>
        F: 盤面を画面にフィット<br>
      </div>
      <div class="actions"><button id="shortcuts-close" class="primary" type="button">閉じる</button></div>
    </div>
  </dialog>

  <dialog class="modal" id="result" aria-labelledby="result-title">
    <div class="card">
      <h3 id="result-title">結果発表</h3>
      <div id="result-body"></div>
      <div class="actions"><button id="result-close" class="primary" type="button">閉じる</button></div>
    </div>
  </dialog>

  <script>
  (function(){
    const $ = s => document.querySelector(s);
    const boardEl = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const playersCountSel = $("#players-count"), initialMoneyInput = $("#initial-money");
    const playerNamesEl = $("#player-names");
    const btnZoomIn = $("#btn-zoom-in"), btnZoomOut = $("#btn-zoom-out");
    const tooltip = $("#tooltip");
    const genericModal = $("#modal"), genericTitle = $("#modal-title"), genericText = $("#modal-text"), genericSub = $("#modal-sub"), genericActions = $("#modal-actions");
    const historyModal = $("#history-modal"), historyBody = $("#history-body"), historyClose = $("#history-close"), historyClear = $("#history-clear");
    const resultDlg = $("#result"), resultBody = $("#result-body");

    const BOARD_COLS = 10, BOARD_ROWS = 6, TOTAL_CELLS = BOARD_COLS * BOARD_ROWS;
    // token colors restricted to allowed palette (green, light green, gray, black)
    const PLAYER_COLORS = ["#86BB27", "#DFF3C6", "#C4C4C4", "#000000", "#86BB27"];
    const BRANCH_CHANCE = 0.36;

    // events: attribute deltas
    const eventTable = [
      { text:"短期支援入り", learning:+6, mental:+2, rating:+3, responsibility:+1 },
      { text:"見積り漏れでトラブル", learning:+2, mental:-6, rating:-1, responsibility:0 },
      { text:"紹介で新規案件獲得", learning:+4, mental:+3, rating:+5, responsibility:+2 },
      { text:"資料誤記で修正対応", learning:+3, mental:-2, rating:-1, responsibility:+1 },
      { text:"アップセル成功", learning:+5, mental:+3, rating:+4, responsibility:+2 },
      { text:"請求遅延で対応", learning:+1, mental:-3, rating:0, responsibility:+1 },
      { text:"分析が評価される", learning:+7, mental:+1, rating:+4, responsibility:0 },
      { text:"外注コスト増で調整", learning:+1, mental:-4, rating:-1, responsibility:+1 },
      { text:"プロトタイプが好評", learning:+8, mental:+5, rating:+6, responsibility:+3 },
      { text:"内部調整で停滞", learning:0, mental:-1, rating:0, responsibility:0 }
    ];

    const RANKS = [
      { key: "アナリスト", min: -Infinity, max: 59.999, base: 5000000 },
      { key: "コンサルタント", min: 60, max: 84.999, base: 8500000 },
      { key: "シニアコンサルタント", min: 85, max: 109.999, base: 12000000 },
      { key: "マネージャー", min: 110, max: Infinity, base: 18000000 }
    ];
    function estimateScore(p){
      return ( (p.learning||0) * 0.35 + (p.rating||0) * 0.35 + (p.responsibility||0) * 0.2 + (p.mental||0) * 0.1 );
    }
    function getRankAndSalary(p){
      const score = estimateScore(p);
      const rank = RANKS.find(r => score >= r.min && score <= r.max) || RANKS[0];
      const modifier = 1 + Math.min(0.5, (p.responsibility||0) / 200) + Math.min(0.3, (p.rating||0) / 400);
      const estimated = Math.round(rank.base * modifier / 1000) * 1000;
      return { rank: rank.key, baseSalary: rank.base, estimatedSalary: estimated, score: Math.round(score) };
    }

    // state
    let state = {
      started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false,
      rng: Math.random, speed:180, overshoot:"clamp", playerSettings: []
    };

    // player name inputs
    function renderPlayerNameInputs(){
      const count = Math.max(1, parseInt(playersCountSel.value || "2"));
      playerNamesEl.innerHTML = "";
      for(let i=0;i<count;i++){
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = `Player ${i+1} 名前`;
        input.id = `player-name-${i}`;
        input.value = `プレイヤー${i+1}`;
        playerNamesEl.appendChild(input);
      }
    }
    playersCountSel.addEventListener("change", renderPlayerNameInputs);
    renderPlayerNameInputs();

    function getPlayerNames(){
      const inputs = playerNamesEl.querySelectorAll("input");
      return Array.from(inputs).map((inp, i) => inp.value.trim() || `プレイヤー${i+1}`);
    }

    // helpers
    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
    function randPick(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }
    function tokenId(i){ return `token-${i}` }
    function yen(n){ return "¥" + Number(n).toLocaleString("ja-JP"); }

    function flashAttr(playerIndex, attrName){
      try{
        const idKey = attrName === 'responsibility' ? 'responsibility' : attrName;
        const el = document.getElementById(`${idKey}-${playerIndex}`);
        if(!el) return;
        el.classList.add('flash-attr');
        setTimeout(()=> el.classList.remove('flash-attr'), 520);
      }catch(e){}
    }

    // board setup
    const cells = Array.from({length:TOTAL_CELLS},(_,i)=>({index:i,type:"none",label:""}));
    cells[0] = {index:0,type:"start",label:"スタート"};
    cells[TOTAL_CELLS-1] = {index:TOTAL_CELLS-1,type:"goal",label:"ゴール"};
    (function markCells(){
      for(let i=1;i<TOTAL_CELLS-1;i++){
        if(i % 11 === 0) { cells[i].type = "client"; cells[i].label = "クライアント"; }
        else if(i % 13 === 0) { cells[i].type = "workshop"; cells[i].label = "ワークショップ"; }
        else if(i % 6 === 0) { cells[i].type = "event"; cells[i].label = "案件/イベント"; }
        else if(i % 5 === 0) { cells[i].type = "bonus"; cells[i].label = "案件成功"; }
        else if(i % 7 === 0) { cells[i].type = "penalty"; cells[i].label = "コスト発生"; }
        else { cells[i].type = "none"; cells[i].label = ""; }
      }
    })();

    function indexToGrid(index){
      const row = Math.floor(index/BOARD_COLS);
      let col = index % BOARD_COLS;
      if(row % 2 === 1) col = BOARD_COLS-1-col;
      return {row, col};
    }

    function renderBoard(){
      if(!boardEl) return;
      boardEl.innerHTML = "";
      cells.forEach(cell=>{
        const div = document.createElement("div");
        div.className = "cell "+(cell.type!="none"?cell.type:"");
        div.dataset.index = String(cell.index);
        const idx = document.createElement("div"); idx.className = "idx"; idx.textContent = String(cell.index); div.appendChild(idx);
        const label = document.createElement("div"); label.textContent = cell.label||""; div.appendChild(label);
        const {row,col} = indexToGrid(cell.index); div.style.gridRowStart = row+1; div.style.gridColumnStart = col+1;
        div.addEventListener("mouseenter", e=> showCellTooltip(cell, e));
        div.addEventListener("mousemove", e=> moveTooltip(e));
        div.addEventListener("mouseleave", hideTooltip);
        boardEl.appendChild(div);
      });
      // tokens
      state.players.forEach((pl,i)=>{
        const token=document.createElement("div"); token.className="token"; token.id=tokenId(i); token.textContent=String(i+1);
        token.style.background = PLAYER_COLORS[i % PLAYER_COLORS.length];
        // Set token text color: players 2 and 3 (indexes 1 and 2) use black text for better readability
        token.style.color = (i === 1 || i === 2) ? 'var(--black)' : 'var(--white)';
        if(pl.finished) token.classList.add("finished");
        token.style.position = "absolute"; token.style.left = "0px"; token.style.top = "0px";
        token.addEventListener("mouseenter", e=> showPlayerTooltip(pl, e));
        token.addEventListener("mousemove", e=> moveTooltip(e));
        token.addEventListener("mouseleave", hideTooltip);
        boardEl.appendChild(token);
      });
      placeAllTokens(); highlightActiveToken();
    }

    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        if(!groups.has(pl.position)) groups.set(pl.position, []);
        groups.get(pl.position).push(i);
      });
      groups.forEach((idxs, pos)=>{
        const targetCell = boardEl.querySelector(`.cell[data-index="${pos}"]`);
        if(!targetCell) return;
        const rectBoard = boardEl.getBoundingClientRect();
        const rc = targetCell.getBoundingClientRect();
        const cx = rc.left - rectBoard.left + rc.width/2; const cy = rc.top - rectBoard.top + rc.height/2;
        const r = Math.min(rc.width, rc.height) / 3.2;
        const n = idxs.length; const baseAngle = -90;
        idxs.forEach((pi, k)=>{
          const angle = baseAngle + (n===1?0: (k-(n-1)/2) * 30);
          const rad = angle * Math.PI / 180;
          const x = cx + r * Math.cos(rad) - 14; const y = cy + r * Math.sin(rad) - 14;
          const t = $("#"+tokenId(pi)); if(t) t.style.transform = `translate(${x}px, ${y}px)`;
        });
      });
      state.players.forEach((pl,i)=>{
        const t = $("#"+tokenId(i)); if(!t) return;
        if(typeof pl.position !== "number") t.style.transform = "translate(-9999px,-9999px)";
      });
    }

    function highlightActiveToken(){
      state.players.forEach((_,i)=>{
        const t=$("#"+tokenId(i)); if(!t) return; if(i===state.currentPlayerIndex) t.classList.add("active"); else t.classList.remove("active");
      });
    }

    function renderPlayersPanel(){
      if(!playersPanelEl) return;
      playersPanelEl.innerHTML = "";
      state.players.forEach((pl,i)=>{
        const row=document.createElement("div"); row.className="player-row"+(i===state.currentPlayerIndex?" active":"");

        // left column: name + rank/salary
        const left = document.createElement("div"); left.className = "left-col";
        const badge=document.createElement("span"); badge.className="badge"; badge.style.background=pl.color; left.appendChild(badge);
        const nameWrap = document.createElement("div"); nameWrap.className = "name-wrap";
        const name = document.createElement("div"); name.textContent = pl.name; name.style.fontWeight = 700;
        const { rank, estimatedSalary, score } = getRankAndSalary(pl);
        const rankEl = document.createElement("div"); rankEl.className = "rank"; rankEl.textContent = `${rank} (S:${score})`;
        const salEl = document.createElement("div"); salEl.className = "salary"; salEl.textContent = `${yen(estimatedSalary)}`;
        nameWrap.appendChild(name); nameWrap.appendChild(rankEl); nameWrap.appendChild(salEl);
        left.appendChild(nameWrap);

        // right column: attributes compact
        const right = document.createElement("div"); right.className = "attr-list";
        const aLearning = document.createElement("div"); aLearning.className="attr"; aLearning.id=`learning-${i}`; aLearning.textContent = `学び: ${pl.learning}`;
        const aMental = document.createElement("div"); aMental.className="attr"; aMental.id=`mental-${i}`; aMental.textContent = `メンタル: ${pl.mental}`;
        const aRating = document.createElement("div"); aRating.className="attr"; aRating.id=`rating-${i}`; aRating.textContent = `評価: ${pl.rating}`;
        const aResp = document.createElement("div"); aResp.className="attr"; aResp.id=`responsibility-${i}`; aResp.textContent = `責任: ${pl.responsibility}`;
        right.appendChild(aLearning); right.appendChild(aMental); right.appendChild(aRating); right.appendChild(aResp);

        row.appendChild(left); row.appendChild(right);
        playersPanelEl.appendChild(row);
      });
    }

    // history & log helpers
    function pushLog(text, kind){ if(!logEl) return; const p=document.createElement("p"); p.textContent=text; if(kind) p.classList.add(kind); logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }
    function showHistory(){
      if(!historyBody) return;
      historyBody.innerHTML = "";
      const items = Array.from(logEl.querySelectorAll("p")).slice(-200);
      if(items.length===0) historyBody.textContent = "履歴がありません";
      items.reverse().forEach(p => { const d = document.createElement("div"); d.textContent = p.textContent; d.className = p.className; historyBody.appendChild(d); });
      if(historyModal && historyModal.showModal) historyModal.showModal();
    }
    if(historyClose) historyClose.addEventListener("click", ()=> { try{ historyModal.close(); }catch(e){} });
    if(historyClear) historyClear.addEventListener("click", ()=> { if(!confirm("履歴をクリアしますか？")) return; if(logEl) logEl.innerHTML=""; if(historyBody) historyBody.innerHTML=""; pushLog("履歴をクリアしました"); });

    // Tooltip
    function showCellTooltip(cell, e){
      if(!tooltip) return;
      const info = [];
      info.push(`マス #${cell.index}`);
      if(cell.type) info.push(`タイプ: ${cell.type}`);
      if(cell.label) info.push(`${cell.label}`);
      const recent = Array.from(logEl.querySelectorAll("p")).slice(-20).reverse().find(p => p.textContent.includes(String(cell.index)));
      if(recent) info.push(`最近: ${recent.textContent}`);
      tooltip.innerHTML = info.join("<br>");
      tooltip.style.display = "block";
      moveTooltip(e);
    }
    function moveTooltip(e){
      if(!tooltip) return;
      const pad = 12;
      tooltip.style.left = (e.clientX + pad) + "px";
      tooltip.style.top = Math.min(window.innerHeight - 80, e.clientY + pad) + "px";
    }
    function hideTooltip(){ if(tooltip) tooltip.style.display = "none"; }

    // Robust modal helpers
    function showCard(title, text, sub){
      return new Promise(resolve => {
        if(!genericModal){ resolve(); return; }
        genericTitle.textContent = title || "";
        genericText.textContent = text || "";
        genericSub.textContent = sub || "";
        genericActions.innerHTML = "";
        const ok = document.createElement("button"); ok.className = "primary"; ok.textContent = "OK"; ok.type = "button";

        let finished = false;
        function finish(){
          if(finished) return;
          finished = true;
          genericModal.removeEventListener("close", onClose);
          try{ genericModal.close(); }catch(e){}
          resolve();
        }
        function onClose(){ finish(); }
        ok.addEventListener("click", finish);
        genericModal.addEventListener("close", onClose);
        genericActions.appendChild(ok);
        try{ genericModal.showModal(); ok.focus(); }catch(e){}
      });
    }

    function showBranchModal(branchEv, playerIndex){
      return new Promise(resolve => {
        if(!genericModal){ resolve(null); return; }
        genericTitle.textContent = "案件分岐 (提案)";
        genericText.textContent = branchEv.text || "";
        genericSub.textContent = `あなた: ${state.players[playerIndex].name}`;
        genericActions.innerHTML = "";

        let resolved = false;
        function finish(val){
          if(resolved) return;
          resolved = true;
          genericModal.removeEventListener("close", onClose);
          try{ genericModal.close(); }catch(e){}
          resolve(val);
        }
        function onClose(){ finish(null); }

        branchEv.choices.forEach(choice=>{
          const b = document.createElement("button"); b.type = "button"; b.textContent = choice.label;
          b.addEventListener("click", async ()=>{
            const baseProb = (typeof choice.probGood === "number") ? choice.probGood : 1.0;
            const pl = state.players[playerIndex];
            const repBonus = Math.max(-0.3, Math.min(0.3, (pl.rating || 0) / 200));
            const prob = Math.max(0.05, Math.min(0.95, baseProb + repBonus));
            const success = state.rng() < prob;
            const res = success ? (choice.success||{}) : (choice.failure||{});
            // apply attributes
            ["learning","mental","rating","responsibility"].forEach(k=>{
              if(typeof res[k] === "number"){
                pl[k] = Math.max(0, Math.round((pl[k]||0) + res[k]));
              }
            });
            ["learning","mental","rating","responsibility"].forEach(k=> flashAttr(playerIndex, k));
            pushLog(`${pl.name}: ${success ? (res.text || choice.label + " → 成功") : (res.text || choice.label + " → 失敗")}`, success ? "ok" : "bad");
            finish({choice, res, success});
          });
          genericActions.appendChild(b);
        });
        const cancel = document.createElement("button"); cancel.type = "button"; cancel.textContent = "やめる";
        cancel.addEventListener("click", ()=> finish(null));
        genericActions.appendChild(cancel);

        genericModal.addEventListener("close", onClose);
        try{ genericModal.showModal(); }catch(e){}
      });
    }

    // resolveCell
    async function resolveCell(playerIndex, index){
      const pl = state.players[playerIndex]; const cell = cells[index]; if(!cell||!pl) return;
      switch(cell.type){
        case "start":
          pushLog(`${pl.name}: プロジェクト開始地点へ`, "ok");
          break;

        case "goal":
          if(!pl.finished){
            pl.finished = true; state.finishedCount += 1; $("#"+tokenId(playerIndex))?.classList.add("finished");
            pl.turnsToGoal = state.turn;
            pushLog(`${pl.name}: プロジェクト完了（ゴール）！`);
            const { rank, estimatedSalary, score } = getRankAndSalary(pl);
            await showCard("ゴール（プロジェクト完了）", `ランク: ${rank} / スコア: ${score} / 推定年収: ${yen(estimatedSalary)}`, `${pl.name}`);
            if(isGameFinished()) showResult();
          }
          break;

        case "bonus":{
          const ev = eventTable[2];
          ["learning","mental","rating","responsibility"].forEach(k=>{
            if(typeof ev[k] === "number"){
              pl[k] = Math.max(0, Math.round((pl[k]||0) + ev[k]));
              flashAttr(playerIndex, k);
            }
          });
          pushLog(`${pl.name}: ボーナスイベント（属性上昇）`, "ok");
          break;
        }

        case "penalty":{
          const ev = eventTable[1];
          ["learning","mental","rating","responsibility"].forEach(k=>{
            if(typeof ev[k] === "number"){
              pl[k] = Math.max(0, Math.round((pl[k]||0) + ev[k]));
              flashAttr(playerIndex, k);
            }
          });
          pushLog(`${pl.name}: ペナルティイベント（属性変動）`, "bad");
          break;
        }

        case "client":{
          const base = 0.55;
          const repBonus = ((pl.rating||50) - 50) / 200;
          const prob = Math.max(0.05, Math.min(0.95, base + repBonus));
          const success = state.rng() < prob;
          if(success){
            pl.learning = Math.max(0, Math.round((pl.learning||0) + 4));
            pl.mental = Math.max(0, Math.round((pl.mental||0) + 2));
            pl.rating = Math.max(0, Math.round((pl.rating||0) + 3));
            flashAttr(playerIndex, "learning"); flashAttr(playerIndex, "mental"); flashAttr(playerIndex, "rating");
            pushLog(`${pl.name}: クライアント成功（学び↑ 評価↑）`, "ok");
          } else {
            pl.mental = Math.max(0, Math.round((pl.mental||0) - 3));
            pl.rating = Math.max(0, Math.round((pl.rating||0) - 1));
            flashAttr(playerIndex, "mental"); flashAttr(playerIndex, "rating");
            pushLog(`${pl.name}: クライアント不調（メンタル↓）`, "bad");
          }
          await showCard("クライアント面談", `学び: ${pl.learning} / メンタル: ${pl.mental}`, `${pl.name}`);
          break;
        }

        case "workshop":{
          const gain = randPick(state.rng, [1,2,3,5]);
          pl.learning = Math.max(0, Math.round((pl.learning||0) + gain));
          pl.rating = Math.max(0, Math.round((pl.rating||0) + 1));
          flashAttr(playerIndex, "learning"); flashAttr(playerIndex, "rating");
          pushLog(`${pl.name}: ワークショップで学び+${gain}`, "ok");
          await showCard("ワークショップ", `学び +${gain}`, `${pl.name}`);
          break;
        }

        case "event":{
          if(state.rng() < BRANCH_CHANCE){
            const defaultBranch = { text: "クライアントへの提案機会", choices: [
              { label:"攻めの提案", probGood:0.5, success:{learning:+3,mental:+1,rating:+4,responsibility:+2,move:1,text:"提案受注！"}, failure:{learning:+1,mental:-2,rating:-1,responsibility:0,move:0,text:"提案失敗"} },
              { label:"守りの提案", probGood:0.8, success:{learning:+1,mental:+1,rating:+1,responsibility:+0,move:0,text:"小さな案件獲得"}, failure:{learning:0,mental:0,rating:0,responsibility:0,move:0,text:"何もしない"} }
            ]};
            const res = await showBranchModal(defaultBranch, playerIndex);
            if(res && res.res && typeof res.res.move === "number" && res.res.move !== 0){
              if(res.res.move > 0) {
                await animateMove(playerIndex, res.res.move);
              } else {
                pl.position = Math.max(0, pl.position + res.res.move);
                placeAllTokens();
                await resolveCell(playerIndex, pl.position);
              }
            } else {
              renderPlayersPanel();
            }
            return;
          }
          const ev2 = randPick(state.rng, eventTable);
          ["learning","mental","rating","responsibility"].forEach(k=>{
            if(typeof ev2[k] === "number"){
              pl[k] = Math.max(0, Math.round((pl[k]||0) + ev2[k]));
              flashAttr(playerIndex, k);
            }
          });
          pushLog(`${pl.name}: ${ev2.text}（属性変動）`, ev2.learning>=0?"ok":"bad");
          await showCard("案件イベント", ev2.text, `${pl.name}`);
          break;
        }
      }
      renderPlayersPanel();
    }

    // dice and movement
    function rollDice(){ const n = Math.floor(state.rng()*6)+1; if(diceEl) diceEl.textContent = n; if(diceEl) diceEl.classList.add("spin"); setTimeout(()=>{ if(diceEl) diceEl.classList.remove("spin"); }, 620); return n; }
    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      const delay = Number(state.speed || 180);
      let pos = pl.position;
      let dir = 1;
      let remaining = steps;
      while(remaining > 0){
        let next = pos + dir;
        if(next >= TOTAL_CELLS){
          if(state.overshoot === "clamp"){
            pos = TOTAL_CELLS-1;
            pl.position = pos;
            placeAllTokens();
            await sleep(delay);
            break;
          } else {
            pos = TOTAL_CELLS-1;
            pl.position = pos;
            placeAllTokens();
            await sleep(delay);
            dir = -1;
          }
        } else if(next < 0){
          pos = 0;
          pl.position = pos;
          placeAllTokens();
          await sleep(delay);
          break;
        } else {
          pos = next;
          pl.position = pos;
          placeAllTokens();
          await sleep(delay);
        }
        remaining--;
      }
      // Wait until cell resolution completes (modals included)
      await resolveCell(playerIndex, pl.position);
      state.animating = false; updateRollState();
    }

    function nextPlayerTurn(){
      const total = state.players.length; if(total === 0) return;
      let i = state.currentPlayerIndex;
      for(let c=0;c<total;c++){ i=(i+1)%total; const p=state.players[i]; if(!p.finished){ state.currentPlayerIndex=i; break; } }
      if(state.players[state.currentPlayerIndex] && state.players[state.currentPlayerIndex].skipTurn){
        const skipped = state.players[state.currentPlayerIndex];
        skipped.skipTurn = false;
        pushLog(`${skipped.name} は休みのためスキップ解除`);
        for(let c=0;c<total;c++){ state.currentPlayerIndex=(state.currentPlayerIndex+1)%total; if(!state.players[state.currentPlayerIndex].finished && !state.players[state.currentPlayerIndex].skipTurn) break; }
      }
      if(isGameFinished()){
        statCurrentEl.textContent = "-";
        return;
      }
      if(state.players[state.currentPlayerIndex] && state.players[state.currentPlayerIndex].finished){
        for(let c=0;c<total;c++){ state.currentPlayerIndex=(state.currentPlayerIndex+1)%total; if(!state.players[state.currentPlayerIndex].finished) break; }
      }
      highlightActiveToken(); renderPlayersPanel(); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
    }
    const isGameFinished = ()=> state.finishedCount === state.players.length;

    // show result
    function showResult(){
      if(!resultDlg) return;
      const rows = state.players.map((p,i)=>({i, name:p.name, score: Math.round(estimateScore(p))})).sort((a,b)=> b.score-a.score);
      resultBody.innerHTML = `<ol>${rows.map(r=>`<li>${r.name}: スコア ${r.score} / ランク ${getRankAndSalary(state.players[r.i]).rank} / ${yen(getRankAndSalary(state.players[r.i]).estimatedSalary)}</li>`).join("")}</ol>`;
      try{ resultDlg.showModal(); }catch(e){}
    }

    // control
    function startGame(){
      if(state.started) return;
      const count = Math.max(1, parseInt(playersCountSel?.value || "2"));
      const initialLearning = 50;
      const initialMental = 50;
      const initialRating = 50;
      const initialResp = 0;
      const names = getPlayerNames();
      state.players = [];
      for(let i=0;i<count;i++){
        state.players.push({
          name: names[i] || `プレイヤー${i+1}`,
          color: PLAYER_COLORS[i % PLAYER_COLORS.length],
          position: 0,
          learning: initialLearning,
          mental: initialMental,
          rating: initialRating,
          responsibility: initialResp,
          achievements: [],
          finished: false,
          skipTurn: false
        });
      }
      state.started = true;
      state.turn = 1;
      state.currentPlayerIndex = 0;
      state.finishedCount = 0;
      state.rng = Math.random;
      renderBoard();
      renderPlayersPanel();
      statTurnEl.textContent = String(state.turn);
      statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
      pushLog("ゲームを開始しました", "ok");
      updateRollState();
      if(btnStart) btnStart.disabled = true;
    }

    async function rollTurn(){
      if(!state.started || state.animating) return;
      if(state.players.length === 0) { pushLog("プレイヤーが設定されていません"); return; }
      const current = state.currentPlayerIndex;
      const val = rollDice();
      await animateMove(current, val);
      const wasLast = (function(){
        const active = state.players.map((p,i)=> ({i, active: !p.finished}));
        const indices = active.filter(a=>a.active).map(a=>a.i);
        if(indices.length === 0) return false;
        return current === indices[indices.length-1];
      })();
      nextPlayerTurn();
      if(wasLast) {
        state.turn = (state.turn || 1) + 1;
        statTurnEl.textContent = String(state.turn);
      }
      updateRollState();
    }

    function resetGame(){
      state.started = false;
      state.turn = 0;
      state.currentPlayerIndex = 0;
      state.players = [];
      state.finishedCount = 0;
      state.animating = false;
      state.rng = Math.random;
      if(logEl) logEl.innerHTML = "";
      renderBoard();
      renderPlayersPanel();
      statTurnEl.textContent = "0";
      statCurrentEl.textContent = "-";
      if(btnStart) btnStart.disabled = false;
      updateRollState();
      pushLog("ゲームをリセットしました");
    }

    function updateRollState(){
      if(btnRoll) btnRoll.disabled = !state.started || state.animating;
    }

    // event wiring
    if(btnStart) btnStart.addEventListener("click", ()=> startGame());
    if(btnRoll) btnRoll.addEventListener("click", ()=> { rollTurn().catch(e=>console.error(e)); });
    if(btnReset) btnReset.addEventListener("click", ()=> resetGame());
    if(btnZoomIn) btnZoomIn.addEventListener('click', ()=> zoomIn());
    if(btnZoomOut) btnZoomOut.addEventListener('click', ()=> zoomOut());

    window.addEventListener('keydown', function (ev) {
      if ((ev.ctrlKey || ev.metaKey) && !ev.shiftKey) {
        if (ev.key === '+' || ev.key === '=') { ev.preventDefault(); zoomIn(); }
        if (ev.key === '-') { ev.preventDefault(); zoomOut(); }
      }
      if (!ev.ctrlKey && !ev.metaKey) {
        if (ev.key === 'z' && !ev.shiftKey) { ev.preventDefault(); zoomIn(); }
        if (ev.key === 'z' && ev.shiftKey) { ev.preventDefault(); zoomOut(); }
        if (ev.key === 'f' || ev.key === 'F') { ev.preventDefault(); fitBoard(); }
        if (ev.key === ' ' || ev.key === 'Enter') {
          if(state.started && !state.animating) { ev.preventDefault(); rollTurn().catch(e=>console.error(e)); }
        }
      }
    });

    // initial render
    renderBoard();
    renderPlayersPanel();
    updateRollState();
    window.dispatchEvent(new CustomEvent('app-ready'));

    // helpers exposed
    function estimateScore(p){
      return ( (p.learning||0) * 0.35 + (p.rating||0) * 0.35 + (p.responsibility||0) * 0.2 + (p.mental||0) * 0.1 );
    }
    function getRankAndSalary(p){
      const score = estimateScore(p);
      const rank = RANKS.find(r => score >= r.min && score <= r.max) || RANKS[0];
      const modifier = 1 + Math.min(0.5, (p.responsibility||0) / 200) + Math.min(0.3, (p.rating||0) / 400);
      const estimated = Math.round(rank.base * modifier / 1000) * 1000;
      return { rank: rank.key, baseSalary: rank.base, estimatedSalary: estimated, score: Math.round(score) };
    }
  })();
  </script>
</body>
</html>
