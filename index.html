<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000;
      --white:#FFFFFF;
      --green:#86BB27;
      --green-alpha: rgba(134,187,39,0.12);
      --green-light:#DFF3C6;
      --gray:#C4C4C4;

      /* Desktop defaults */
      --tile-size-desktop: 68px;
      --token-size-desktop: 30px;
      --tile-gap-desktop: 16px;
      --board-padding-desktop: 24px;
      --token-move-ms:140ms;

      /* Mobile break */
      --mobile-breakpoint: 680px;
      --bottom-bar-height-mobile: 76px;

      /* Default mobile CSS hint */
      --tile-size-mobile: 36px;
      --token-size-mobile: 18px;
      --tile-gap-mobile: 8px;
      --board-padding-mobile: 8px;
    }

    *{box-sizing:border-box}
    /* force bold */
    html, body, body * { font-weight: 900 !important; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white);
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }

    /* ---- Appbar / toolbar ---- */
    .appbar{position:sticky; top:0; z-index:1200; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); display:flex; justify-content:center}
    .toolbar{width:100%; max-width:1300px; display:flex; gap:10px; align-items:center; padding:8px}
    .title{font-size:15px; margin-right:auto; color:var(--black)}
    .group{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--gray); border-radius:10px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:8px; border:1px solid var(--gray); font-weight:900}

    button{padding:8px 12px; border-radius:8px; border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent}

    :focus { outline: 3px solid var(--green); outline-offset:2px; box-shadow: 0 0 0 6px var(--green-alpha); }

    .wrap{width:100%; max-width:1300px; margin:18px auto; display:grid; grid-template-columns:3fr 1fr; gap:12px; align-items:start; padding:0 12px}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

    /* ---- Board / tiles (desktop variables) ---- */
    .board-wrap{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:var(--board-padding-desktop); position:relative; overflow:auto; min-height:520px}
    .board{
      position:relative; width:100%; height:820px; touch-action:none;
      background: linear-gradient(180deg, rgba(0,0,0,0.01), rgba(0,0,0,0.00));
    }

    .tile{
      position:absolute;
      width:var(--tile-size-desktop);
      height:var(--tile-size-desktop);
      background:#f6f8fb;
      border:2px solid rgba(0,0,0,0.06);
      border-radius:8px;
      transform: translate(-50%,-50%);
      display:grid; place-items:center;
      color:var(--black);
      box-shadow: 0 6px 14px rgba(14,20,25,0.06);
      transition: transform 120ms linear;
      z-index:2;
      font-size:12px;
      padding:4px;
      text-align:center;
      line-height:1;
    }
    .tile:hover{ box-shadow: 0 10px 26px rgba(14,20,25,0.12); }

    .tile.event,
    .tile.client,
    .tile.workshop,
    .tile.bonus,
    .tile.penalty {
      border:3px solid var(--green);
      background:#f7fff6;
    }
    .tile.goal{
      background: var(--green);
      color: #fff;
      border-color: var(--green);
      box-shadow: 0 10px 30px rgba(134,187,39,0.18);
    }

    .start-marker{
      position:absolute;
      width:calc(var(--tile-size-desktop) * 0.9);
      height:calc(var(--tile-size-desktop) * 0.28);
      display:grid; place-items:center;
      border-radius:6px; border:1px solid rgba(0,0,0,0.08);
      color:var(--black); background:rgba(134,187,39,0.08);
      z-index:6;
      transform: translate(-50%,-125%);
      pointer-events:none;
      font-size:12px;
    }

    .token{
      position:absolute;
      width:var(--token-size-desktop); height:var(--token-size-desktop); border-radius:50%; display:grid; place-items:center;
      border:2px solid #000; transform: translate(-50%,-50%);
      box-shadow:0 8px 20px rgba(0,0,0,0.08);
      pointer-events:none;
      transition: transform var(--token-move-ms) linear;
      z-index:30;
      color: #fff;
      font-size:12px;
    }
    .token.finished{ opacity:0.85; border-color:var(--gray) }

    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px}
    .stat{display:flex; justify-content:space-between; padding:10px; border-radius:10px}
    .players{margin-top:10px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:8px; padding:8px; border-radius:10px; border:1px solid var(--gray); align-items:center}
    .attr-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;}
    .log{margin-top:12px; border:1px solid var(--gray); border-radius:10px; padding:10px; max-height:300px; overflow:auto; font-size:13px}

    .events-panel{margin-top:12px}
    .events-tabs{display:flex; gap:6px; margin-bottom:8px}
    .events-list{max-height:260px; overflow:auto; border:1px solid #eee; border-radius:8px; padding:6px}
    .event-item{padding:8px; border-bottom:1px dashed #eee; cursor:pointer}
    .event-item:hover{background:#fbfffb}

    /* Modal defaults */
    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:9999}
    .modal-fallback .card{background:#fff; padding:18px; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,0.12); max-width:720px; width:100%; max-height:88vh; overflow:auto; font-size:15px}
    .modal-bottom { align-items:flex-end; }
    .modal-bottom .card { border-radius:12px 12px 0 0; max-width:none; height:88vh; padding:18px; }

    .event-title{margin-bottom:8px; font-size:18px}
    .event-body{white-space:pre-wrap; margin-bottom:12px; line-height:1.6; font-size:15px}
    .event-changes{color:var(--green)}
    .choice-btn{margin-right:8px}

    .results-table{width:100%; border-collapse:collapse; margin-top:8px}
    .results-table th, .results-table td{padding:8px; border-bottom:1px solid #eee; text-align:left;}
    .results-winner{background:linear-gradient(90deg, rgba(134,187,39,0.06), rgba(134,187,39,0.02));}
    .small-muted{color:#666; font-size:13px}

    /* Bottom bar (mobile only, hidden on desktop) */
    .bottom-bar { display:none; }

    /* ============================
       MOBILE OVERRIDES (ONLY)
       ============================ */
    @media (max-width: var(--mobile-breakpoint)) {
      :root {
        --tile-size-mobile: 36px;
        --token-size-mobile: 18px;
        --tile-gap-mobile: 8px;
        --board-padding-mobile: 8px;
        --bottom-bar-height-mobile: 76px;
      }

      .wrap { grid-template-columns:1fr; margin:0; padding:0 6px; gap:8px; }
      .appbar { position:fixed; top:0; left:0; right:0; z-index:1400; }
      .toolbar { padding:8px 10px; align-items:center; gap:8px; }
      .group#control-buttons { display:none; } /* hide desktop controls in header */
      .group#desktop-controls { display:none; }
      #player-names { display:none; }

      .board-wrap{ padding:var(--board-padding-mobile); min-height: calc(100vh - var(--bottom-bar-height-mobile) - 120px); border-radius:10px; }
      .board { height: calc(100vh - var(--bottom-bar-height-mobile) - 140px); }

      .tile{
        width: var(--tile-size-mobile);
        height: var(--tile-size-mobile);
        font-size:13px;
        padding:6px;
        border-radius:8px;
        transform: translate(-50%,-50%) rotate(0deg) !important;
      }

      .token{
        width: var(--token-size-mobile);
        height: var(--token-size-mobile);
        font-size:13px;
      }

      .sidebar { display:none; }

      .bottom-bar {
        display:flex;
        position:fixed;
        inset:auto 0 0 0;
        height: var(--bottom-bar-height-mobile);
        background:var(--white);
        border-top:1px solid rgba(0,0,0,0.06);
        align-items:center;
        justify-content:space-around;
        z-index:1500;
        padding:8px 10px;
        gap:8px;
      }
      .bottom-bar button{ min-width:64px; height:48px; border-radius:10px; padding:10px 12px; font-size:15px; display:flex; align-items:center; justify-content:center; gap:8px; }

      /* Mobile modal: full-height bottom sheet with large buttons */
      .modal-fallback .card{ padding:18px; font-size:16px; border-radius:12px; }
      .modal-bottom .card { height:88vh; padding:18px; border-radius:12px 12px 0 0; }
      .choice-btn{ display:block; width:100%; padding:14px 12px; margin-bottom:10px; border-radius:10px; font-size:15px; text-align:center; }

      /* rules content style (read-only plain text) */
      .rules-content {
        width:100%;
        min-height:220px;
        padding:12px;
        border-radius:8px;
        border:1px solid #ddd;
        font-size:14px;
        font-weight:900;
        font-family:inherit;
        background:#f5f5f5;
        white-space:pre-wrap;
        color:#222;
      }

      .event-title{ font-size:20px; margin-bottom:12px; }
      .event-body{ font-size:16px; line-height:1.6; }

      .start-marker { display:none; transform: translate(-50%,-150%); }

      :focus { outline: 4px solid var(--green); outline-offset:3px; box-shadow: 0 0 0 8px var(--green-alpha); }
    }

    /* Desktop modal rules content */
    .rules-content {
      width:100%;
      min-height:260px;
      padding:12px;
      border-radius:8px;
      border:1px solid #ddd;
      font-size:14px;
      font-weight:900;
      font-family:inherit;
      background:#f9f9f9;
      white-space:pre-wrap;
      color:#222;
    }
  </style>
</head>
<body>
  <div class="appbar" role="banner">
    <div class="toolbar" role="group" aria-label="„Ç≤„Éº„É†Ë®≠ÂÆö">
      <div class="title" aria-hidden="false"><span style="color:var(--green)">M</span>ake an impact that matters</div>

      <div class="group" id="desktop-controls">
        <label for="players-count">‰∫∫Êï∞</label>
        <select id="players-count" aria-label="„Éó„É¨„Ç§„É§„Éº‰∫∫Êï∞"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>

      <div class="group" id="player-names" aria-label="„Éó„É¨„Ç§„É§„ÉºÂêçÂÖ•Âäõ"></div>

      <div class="group" id="control-buttons" style="margin-left:auto;">
        <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>
        <button id="btn-start" class="primary">ÈñãÂßã</button>
        <button id="btn-roll" disabled>„Çµ„Ç§„Ç≥„É≠</button>
        <button id="btn-results">ÁµêÊûú</button>
        <button id="btn-reset">„É™„Çª„ÉÉ„Éà</button>
        <!-- New rules/help button (desktop toolbar) -->
        <button id="btn-rules" aria-label="ÈÅä„Å≥Êñπ„Éª„É´„Éº„É´">„É´„Éº„É´</button>
      </div>
    </div>
  </div>

  <div class="wrap" id="wrap">
    <div class="board-wrap">
      <div class="board" id="board" aria-label="„Éú„Éº„Éâ">
        <div class="start-marker" id="start-marker">START</div>
      </div>
    </div>

    <aside class="sidebar" id="sidebar">
      <div class="stat"><span>„Çø„Éº„É≥</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>ÊâãÁï™</span><strong id="stat-current">-</strong></div>

      <div class="events-panel" id="events-panel">
        <div class="events-tabs" id="events-tabs"></div>
        <div class="events-list" id="events-list"></div>
      </div>

      <div class="players" id="players-panel" aria-label="„Éó„É¨„Ç§„É§„Éº‰∏ÄË¶ß"></div>

      <div class="log" id="log" aria-live="polite"></div>
    </aside>
  </div>

  <!-- bottom bar for mobile (added rules button) -->
  <div class="bottom-bar" id="bottom-bar" role="toolbar" aria-hidden="true">
    <button id="bb-btn-roll" aria-label="„Çµ„Ç§„Ç≥„É≠">üé≤ „Çµ„Ç§„Ç≥„É≠</button>
    <button id="bb-btn-players" aria-label="„Éó„É¨„Ç§„É§„Éº">üë• „Éó„É¨„Ç§„É§„Éº</button>
    <button id="bb-btn-log" aria-label="„É≠„Ç∞">üìù „É≠„Ç∞</button>
    <button id="bb-btn-results" aria-label="ÁµêÊûú">üèÅ ÁµêÊûú</button>
    <button id="bb-btn-rules" aria-label="ÈÅä„Å≥Êñπ„Éª„É´„Éº„É´">üìò „É´„Éº„É´</button>
  </div>

  <script>
  (function(){
    // Initialization on load
    window.addEventListener('load', init);

    const MOBILE_BREAK = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-breakpoint')) || 680;
    const NUM_TILES = 60;

    function parseColorToRgb(str){
      if(!str) return null;
      str = String(str).trim();
      if(str[0] === '#'){
        let hex = str.slice(1);
        if(hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
        if(hex.length !== 6) return null;
        const r = parseInt(hex.slice(0,2),16);
        const g = parseInt(hex.slice(2,4),16);
        const b = parseInt(hex.slice(4,6),16);
        return { r, g, b };
      }
      const m = str.match(/rgba?\(\s*([0-9.]+)[\s,]+([0-9.]+)[\s,]+([0-9.]+)(?:[\s,\/]+[0-9.]+)?\s*\)/i);
      if(m){
        return { r: Math.round(Number(m[1])), g: Math.round(Number(m[2])), b: Math.round(Number(m[3])) };
      }
      return null;
    }
    function perceivedLuminance(rgb){
      if(!rgb) return 0;
      const r = rgb.r/255, g = rgb.g/255, b = rgb.b/255;
      const lin = v => (v <= 0.03928) ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
      const R = lin(r), G = lin(g), B = lin(b);
      return 0.2126*R + 0.7152*G + 0.0722*B;
    }
    function shouldUseDarkTextForBg(bg){
      const rgb = parseColorToRgb(bg);
      if(!rgb) return false;
      const lum = perceivedLuminance(rgb);
      return lum > 0.55;
    }

    // Try to load event templates but don't block UI (fallback handled elsewhere)
    let EVENT_TEMPLATES = null;
    async function loadEventTemplatesExternal(){
      try{
        const res = await fetch('./event-templates.json', { cache: 'no-cache' });
        if(!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        if(!json || (!json.junior && !json.mid && !json.senior)) throw new Error('Invalid JSON shape');
        return json;
      }catch(e){
        return null;
      }
    }

    const $ = s => document.querySelector(s);
    let isMobile = window.matchMedia(`(max-width: ${MOBILE_BREAK}px)`).matches;

    const state = { started:false, turn:0, currentPlayerIndex:0, players:[], animating:false, rng: Math.random };

    let tileCoords = [];
    let mobileLayout = { tileSize: null, tokenSize: null, cols: 6 };

    async function init(){
      EVENT_TEMPLATES = await loadEventTemplatesExternal();
      bindUI();
      renderPlayerNameInputs();
      layoutTiles();
      renderPlayersPanel();
      renderEventsPanel();
      updateBottomBarVisibility();
      updateRollState();
      window.addEventListener('resize', onResize);
    }

    function onResize(){
      const prev = isMobile;
      isMobile = window.matchMedia(`(max-width: ${MOBILE_BREAK}px)`).matches;
      if(prev !== isMobile) updateBottomBarVisibility();
      layoutTiles();
    }

    function bindUI(){
      const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset"), btnResults = $("#btn-results");
      const btnRules = $("#btn-rules");
      const bbRoll = $("#bb-btn-roll"), bbPlayers = $("#bb-btn-players"), bbLog = $("#bb-btn-log"), bbResults = $("#bb-btn-results");
      const bbRules = $("#bb-btn-rules");
      const playersCountSel = $("#players-count");

      playersCountSel.addEventListener('change', renderPlayerNameInputs);

      btnStart.addEventListener('click', startGame);
      btnRoll.addEventListener('click', rollTurn);
      btnReset.addEventListener('click', resetGame);
      btnResults.addEventListener('click', showFinalResultsModal);

      // rules button (desktop)
      if(btnRules) btnRules.addEventListener('click', openRulesModal);

      if(bbRoll) bbRoll.addEventListener('click', ()=> { if(!$("#btn-roll").disabled) rollTurn(); });
      if(bbPlayers) bbPlayers.addEventListener('click', ()=> openBottomSheet('players'));
      if(bbLog) bbLog.addEventListener('click', ()=> openBottomSheet('log'));
      if(bbResults) bbResults.addEventListener('click', showFinalResultsModal);
      // rules button (mobile bottom bar)
      if(bbRules) bbRules.addEventListener('click', openRulesModal);

      window.addEventListener("keydown", (e)=>{
        if((e.key === " " || e.key === "Enter") && state.started && !state.animating){
          e.preventDefault();
          rollTurn();
        }
      });
    }

    function updateBottomBarVisibility(){
      const bb = $("#bottom-bar");
      if(!bb) return;
      if(isMobile){
        bb.setAttribute('aria-hidden','false');
        bb.style.display = 'flex';
        const desktopControls = document.getElementById('desktop-controls');
        if(desktopControls) desktopControls.style.display = 'none';
        const playerNames = document.getElementById('player-names');
        if(playerNames) playerNames.style.display = 'none';
      } else {
        bb.setAttribute('aria-hidden','true');
        bb.style.display = 'none';
        const desktopControls = document.getElementById('desktop-controls');
        if(desktopControls) desktopControls.style.display = '';
        const playerNames = document.getElementById('player-names');
        if(playerNames) playerNames.style.display = '';
      }
    }

    function renderPlayerNameInputs(){
      const wrap = $("#player-names");
      if(!wrap) return;
      wrap.innerHTML = "";
      const count = Math.max(1, Number($("#players-count").value) || 2);
      for(let i=0;i<count;i++){
        const inp = document.createElement("input");
        inp.type = "text";
        inp.placeholder = `Player ${i+1}`;
        inp.value = `„Éó„É¨„Ç§„É§„Éº${i+1}`;
        inp.style.width = isMobile ? "88px" : "120px";
        wrap.appendChild(inp);
      }
    }
    function getPlayerNames(){ return Array.from(document.querySelectorAll('#player-names input')).map((el,idx)=> el.value.trim() || `„Éó„É¨„Ç§„É§„Éº${idx+1}`); }

    function pushLog(text, kind){
      const logEl = $("#log");
      if(!logEl) return;
      const p = document.createElement("div");
      p.textContent = `[${(new Date()).toLocaleTimeString()}] ${text}`;
      if(kind === "ok") p.style.color = "green";
      if(kind === "bad") p.style.color = "#333";
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    /* ===== Grid path (mobile) & spiral (desktop) kept - omitted here for brevity in comment ===== */
    function buildGridPathFixedCols(N, rect, requestedTileSize, gap, colsFixed = 6){
      const padding = Math.max(8, requestedTileSize * 0.3);
      const usableW = Math.max(80, rect.width - padding*2);
      const cols = colsFixed;
      const totalGap = (cols - 1) * gap;
      let effectiveTileSize = Math.floor((usableW - totalGap) / cols);
      const minTile = 28;
      if(effectiveTileSize < minTile) effectiveTileSize = minTile;
      effectiveTileSize = Math.min(effectiveTileSize, requestedTileSize);
      const gridWidth = cols * effectiveTileSize + totalGap;
      const startX = Math.max(padding + effectiveTileSize/2, (rect.width - gridWidth)/2 + effectiveTileSize/2);
      const spacingX = effectiveTileSize + gap;
      const rows = Math.ceil(N / cols);
      const spacingY = effectiveTileSize + gap;
      const startY = padding + effectiveTileSize/2;
      const coords = [];
      for(let r=0;r<rows;r++){
        const rowArr = [];
        for(let c=0;c<cols;c++){
          const x = startX + c * spacingX;
          const y = startY + r * spacingY;
          rowArr.push({x,y,ang:0});
        }
        if(r % 2 === 0){
          for(let i=0;i<rowArr.length;i++){
            if(coords.length < N) coords.push(rowArr[i]);
          }
        } else {
          for(let i=rowArr.length-1;i>=0;i--){
            if(coords.length < N) coords.push(rowArr[i]);
          }
        }
      }
      const clampMargin = effectiveTileSize / 2 + 4;
      for(const c of coords){
        c.x = Math.max(clampMargin, Math.min(rect.width - clampMargin, c.x));
        c.y = Math.max(clampMargin, Math.min(rect.height - clampMargin, c.y));
      }
      if(coords.length > N) coords.length = N;
      return { coords, effectiveTileSize, cols };
    }

    const BASE_JITTER = 12;
    function buildConnectedPath(N, containerW, containerH, tileSize, gap){
      const cx = containerW/2, cy = containerH/2;
      const coords = [];
      const margin = Math.max(tileSize*1.6, 28);
      let left = margin, top = margin, right = containerW - margin, bottom = containerH - margin;
      const ringInset = tileSize + gap + Math.round(tileSize*0.4);

      function perimeterPoints(l,t,r,b, spacing){
        const w = Math.max(1, r - l), h = Math.max(1, b - t);
        const perim = 2*(w + h);
        const count = Math.max(4, Math.floor(perim / spacing));
        let topCount = Math.max(1, Math.round(count * (w / perim)));
        let rightCount = Math.max(1, Math.round(count * (h / perim)));
        let bottomCount = Math.max(1, Math.round(count * (w / perim)));
        let leftCount = Math.max(1, Math.round(count * (h / perim)));
        let sum = topCount + rightCount + bottomCount + leftCount;
        let idxAdjust = 0;
        while(sum < count){ if(idxAdjust%4===0) topCount++; else if(idxAdjust%4===1) rightCount++; else if(idxAdjust%4===2) bottomCount++; else leftCount++; idxAdjust++; sum++; }
        while(sum > count){ if(idxAdjust%4===0 && topCount>1) topCount--; else if(idxAdjust%4===1 && rightCount>1) rightCount--; else if(idxAdjust%4===2 && bottomCount>1) bottomCount--; else if(idxAdjust%4===3 && leftCount>1) leftCount--; idxAdjust++; sum--; }
        const pts = [];
        for(let i=0;i<topCount;i++){ const x = l + (i+0.5) * (w / topCount); const y = t; pts.push({x,y}); }
        for(let i=0;i<rightCount;i++){ const x = r; const y = t + (i+0.5) * (h / rightCount); pts.push({x,y}); }
        for(let i=0;i<bottomCount;i++){ const x = r - (i+0.5) * (w / bottomCount); const y = b; pts.push({x,y}); }
        for(let i=0;i<leftCount;i++){ const x = l; const y = b - (i+0.5) * (h / leftCount); pts.push({x,y}); }
        return pts;
      }

      const rings = [];
      let attempts = 0;
      while(coords.length < N - 1 && right - left > tileSize && bottom - top > tileSize && attempts < 24){
        const pts = perimeterPoints(left, top, right, bottom, tileSize + gap);
        rings.push({pts, l:left, t:top, r:right, b:bottom});
        left += ringInset; top += ringInset; right -= ringInset; bottom -= ringInset;
        attempts++;
      }

      let prevExit = null;
      for(let ri = 0; ri < rings.length && coords.length < N - 1; ri++){
        const ring = rings[ri];
        const pts = ring.pts.slice();
        let startIdx = 0;
        if(prevExit){
          let best = 0, bestD = Infinity;
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - prevExit.x, dy = pts[k].y - prevExit.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        } else {
          let best = 0, bestD = Infinity;
          const topLeft = {x: ring.l + 6, y: ring.t + 6};
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - topLeft.x, dy = pts[k].y - topLeft.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        }

        for(let k=0;k<pts.length && coords.length < N - 1;k++){
          const idx = (startIdx + k) % pts.length;
          const jitterX = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          const jitterY = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          coords.push({x: pts[idx].x + jitterX, y: pts[idx].y + jitterY, ang: (Math.random()*2-1)*6});
        }
        prevExit = coords[coords.length-1];
        if(ri < rings.length - 1 && coords.length < N - 1){
          const inner = rings[ri+1];
          const innerCenter = {x: (inner.l + inner.r)/2, y: (inner.t + inner.b)/2};
          const connX = prevExit.x + (innerCenter.x - prevExit.x) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          const connY = prevExit.y + (innerCenter.y - prevExit.y) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          coords.push({x: connX, y: connY, ang: (Math.random()*2-1)*6});
          prevExit = coords[coords.length-1];
        }
      }

      if(coords.length < N - 1){
        const remaining = (N - 1) - coords.length;
        for(let i=0;i<remaining;i++){
          const angle = (i/remaining) * Math.PI * 2;
          const radius = Math.min(containerW, containerH) * 0.11 + (i%3) * (tileSize*0.4);
          const x = cx + Math.cos(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          const y = cy + Math.sin(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          coords.push({x,y,ang:(Math.random()*2-1)*8});
        }
      }

      coords.push({x: cx, y: cy, ang:0});
      const clampMargin = tileSize;
      for(const c of coords){
        c.x = Math.max(clampMargin, Math.min(containerW - clampMargin, c.x));
        c.y = Math.max(clampMargin, Math.min(containerH - clampMargin, c.y));
      }
      if(coords.length > N) coords.length = N;
      return coords;
    }

    function layoutTiles(){
      const board = $("#board");
      if(!board) return;
      board.querySelectorAll(".tile").forEach(n=>n.remove());
      const rect = board.getBoundingClientRect();
      const isM = window.matchMedia(`(max-width: ${MOBILE_BREAK}px)`).matches;
      const requestedTileSize = isM ? getCssNumber('--tile-size-mobile', 36) : getCssNumber('--tile-size-desktop', 68);
      const gap = isM ? getCssNumber('--tile-gap-mobile', 8) : getCssNumber('--tile-gap-desktop', 16);

      let coords = [];
      let effectiveTileSize = requestedTileSize;
      let cols = null;

      if(isM){
        const grid = buildGridPathFixedCols(NUM_TILES, rect, requestedTileSize, gap, 6); // fixed 6 columns
        coords = grid.coords;
        effectiveTileSize = grid.effectiveTileSize;
        cols = grid.cols;
        mobileLayout.tileSize = effectiveTileSize;
        mobileLayout.cols = cols;
        mobileLayout.tokenSize = Math.max(12, Math.round(effectiveTileSize * 0.5));
      } else {
        coords = buildConnectedPath(NUM_TILES, rect.width, rect.height, requestedTileSize, gap);
        mobileLayout.tileSize = null;
        mobileLayout.tokenSize = null;
        mobileLayout.cols = null;
      }

      tileCoords = coords;

      coords.forEach((c, idx)=>{
        const div = document.createElement("div");
        div.className = "tile";
        div.dataset.pathIndex = String(idx);

        // On mobile show single-letter markers for Start/Goal so they don't overflow
        if(isM){
          if(idx === 0) div.textContent = 'S';
          else if(idx === NUM_TILES - 1) div.textContent = 'G';
          else div.textContent = '';
        } else {
          if(idx === NUM_TILES - 1){
            div.classList.add("goal");
            div.textContent = "GOAL";
          }
        }

        // type classes
        if(idx !== NUM_TILES - 1){
          if(idx % 11 === 0) div.classList.add("client");
          if(idx % 13 === 0) div.classList.add("workshop");
          if(idx % 6 === 0) div.classList.add("event");
          if(idx % 5 === 0) div.classList.add("bonus");
          if(idx % 7 === 0) div.classList.add("penalty");
        }

        div.style.left = `${c.x}px`;
        div.style.top = `${c.y}px`;
        const rot = (isM ? 0 : (c.ang || ((Math.random()*2-1)*6)));
        div.style.transform = `translate(-50%,-50%) rotate(${rot}deg)`;

        if(isM && mobileLayout.tileSize){
          div.style.width = `${mobileLayout.tileSize}px`;
          div.style.height = `${mobileLayout.tileSize}px`;
          div.style.borderRadius = '6px';
          div.style.fontSize = Math.max(12, Math.round(mobileLayout.tileSize * 0.55)) + 'px';
          div.style.lineHeight = '1';
        } else {
          div.style.width = ''; div.style.height = '';
        }

        board.appendChild(div);
      });

      // start marker: hidden on mobile (CSS) and positioned for desktop
      const START_MARKER = $("#start-marker");
      if(tileCoords && tileCoords[0] && START_MARKER){
        const t0 = tileCoords[0];
        START_MARKER.style.left = `${t0.x}px`;
        START_MARKER.style.top = `${t0.y}px`;
        START_MARKER.style.display = mobileLayout.tileSize ? 'none' : 'grid';
      } else if(START_MARKER){
        START_MARKER.style.display = 'none';
      }

      placeAllTokens();
    }

    function ensureToken(i){
      let t = document.getElementById(`token-${i}`);
      if(!t){
        t = document.createElement("div"); t.className = "token"; t.id = `token-${i}`;
        t.textContent = String(i+1);
        const palette = ["#86BB27","#DFF3C6","#C4C4C4","#2B2B2B"];
        const bg = palette[i % palette.length];
        t.style.background = bg;
        if(shouldUseDarkTextForBg(bg)) t.style.color = '#000'; else t.style.color = '#fff';
        document.getElementById('board').appendChild(t);
      }
      if(mobileLayout.tokenSize){
        t.style.width = `${mobileLayout.tokenSize}px`;
        t.style.height = `${mobileLayout.tokenSize}px`;
        t.style.fontSize = Math.max(10, Math.round(mobileLayout.tokenSize * 0.6)) + 'px';
      } else {
        t.style.width = '';
        t.style.height = '';
        t.style.fontSize = '';
      }
      return t;
    }

    function placeAllTokens(){
      const bRect = $("#board").getBoundingClientRect();
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        const pos = (typeof pl.position === "number" && pl.position >= 0) ? pl.position : "__start";
        if(!groups.has(pos)) groups.set(pos, []);
        groups.get(pos).push(i);
      });

      const tileSize = mobileLayout.tileSize || getCssNumber('--tile-size-desktop', 68);

      if(groups.has("__start")){
        const startIdxs = groups.get("__start");
        const sRect = $("#start-marker").getBoundingClientRect();
        const sx = (sRect.left - bRect.left) + sRect.width/2;
        const sy = (sRect.top - bRect.top) + sRect.height/2;
        startIdxs.forEach((pi,k)=>{
          const t = ensureToken(pi);
          if(shouldUseDarkTextForBg(t.style.background)) t.style.color = '#000'; else t.style.color = '#fff';
          const offX = ((k % 2) - 0.5) * Math.max(8, tileSize*0.32);
          const offY = (Math.floor(k/2) - 0.5) * Math.max(8, tileSize*0.32);
          t.style.transform = `translate(${sx + offX}px, ${sy + offY}px)`;
        });
      }

      groups.forEach((idxs, pos)=>{
        if(pos === "__start") return;
        const center = tileCoords[pos];
        if(!center) return;
        const n = idxs.length;
        const baseR = Math.max(8, tileSize * 0.28);
        if(n === 1){
          const t = ensureToken(idxs[0]);
          if(shouldUseDarkTextForBg(t.style.background)) t.style.color = '#000'; else t.style.color = '#fff';
          t.style.transform = `translate(${center.x}px, ${center.y}px)`;
        } else {
          const perOuter = 6;
          const outerCount = Math.min(n, perOuter);
          const innerCount = Math.max(0, n - perOuter);
          let used = 0;
          const outerR = baseR;
          for(let k=0;k<outerCount;k++){
            const ang = (k / outerCount) * Math.PI * 2 - Math.PI/2;
            const x = center.x + Math.cos(ang) * outerR;
            const y = center.y + Math.sin(ang) * outerR;
            const t = ensureToken(idxs[used++]);
            if(shouldUseDarkTextForBg(t.style.background)) t.style.color = '#000'; else t.style.color = '#fff';
            t.style.transform = `translate(${x}px, ${y}px)`;
          }
          if(innerCount > 0){
            const innerR = baseR * 0.55;
            for(let k=0;k<innerCount;k++){
              const ang = (k / innerCount) * Math.PI * 2 - Math.PI/2;
              const x = center.x + Math.cos(ang) * innerR;
              const y = center.y + Math.sin(ang) * innerR;
              const t = ensureToken(idxs[used++]);
              if(shouldUseDarkTextForBg(t.style.background)) t.style.color = '#000'; else t.style.color = '#fff';
              t.style.transform = `translate(${x}px, ${y}px)`;
            }
          }
        }
      });
    }

    function moveTokenStep(playerIndex, pos){
      return new Promise(resolve=>{
        const t = ensureToken(playerIndex);
        const c = (typeof pos === "number" && tileCoords[pos]) ? tileCoords[pos] : null;
        const bRect = $("#board").getBoundingClientRect();
        if(!c){
          const sRect = $("#start-marker").getBoundingClientRect();
          const x = (sRect.left - bRect.left) + sRect.width/2;
          const y = (sRect.top - bRect.top) + sRect.height/2;
          t.style.transform = `translate(${x}px, ${y}px)`;
          setTimeout(()=> resolve(), (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 140) + 20);
          return;
        }
        let finished = false;
        function onEnd(e){
          if(e && e.target !== t) return;
          if(finished) return;
          finished = true;
          t.removeEventListener('transitionend', onEnd);
          setTimeout(()=> resolve(), 20);
        }
        t.addEventListener('transitionend', onEnd);
        setTimeout(()=>{ if(!finished){ finished=true; t.removeEventListener('transitionend', onEnd); resolve(); } }, (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 140) + 220);
        t.style.transform = `translate(${c.x}px, ${c.y}px)`;
      });
    }

    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      try{
        let pos = (typeof pl.position === "number") ? pl.position : -1;
        let remaining = steps;
        while(remaining > 0){
          const next = pos + 1;
          if(next >= NUM_TILES){
            pos = NUM_TILES - 1;
            pl.position = pos;
            await moveTokenStep(playerIndex, pos);
            break;
          } else {
            pos = next;
            pl.position = pos;
            await moveTokenStep(playerIndex, pos);
          }
          remaining--;
        }
        placeAllTokens();
        const tileEl = document.querySelector(`.tile[data-path-index="${pl.position}"]`);
        if(tileEl && (tileEl.classList.contains('event') || tileEl.classList.contains('client') || tileEl.classList.contains('workshop') || tileEl.classList.contains('bonus') || tileEl.classList.contains('penalty')) ){
          await handleEventTile(playerIndex);
        } else {
          await resolveCell(playerIndex, pl.position);
        }
      }catch(e){ console.error(e); }
      finally{ state.animating = false; updateRollState(); }
    }

    function updateRollState(){
      const rbtn = document.getElementById('btn-roll');
      const bbRoll = document.getElementById('bb-btn-roll');
      const disabled = !(state.started && !state.animating);
      if(rbtn) rbtn.disabled = disabled;
      if(bbRoll) bbRoll.disabled = disabled;
    }

    async function rollTurn(){
      if(!state.started || state.animating) return;
      const current = state.currentPlayerIndex;
      const val = Math.floor(Math.random()*6)+1;
      const diceEl = $("#dice");
      if(diceEl) diceEl.textContent = String(val);
      pushLog(`${state.players[current].name} „Åå„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çä„Åæ„Åó„Åü`);
      await animateMove(current, val);
      nextPlayerTurn();
    }

    function nextPlayerTurn(){
      const total = state.players.length;
      if(total === 0) return;
      let i = state.currentPlayerIndex;
      for(let c=0;c<total;c++){
        i = (i+1) % total;
        const cand = state.players[i];
        if(!cand) continue;
        if(cand.finished) continue;
        state.currentPlayerIndex = i;
        $("#stat-current").textContent = state.players[i].name;
        highlightActive();
        return;
      }
      $("#stat-current").textContent = "-";
    }

    function highlightActive(){
      Array.from($("#players-panel").children).forEach((row, idx)=>{
        if(idx === state.currentPlayerIndex) row.style.boxShadow = "0 0 0 3px rgba(134,187,39,0.12) inset";
        else row.style.boxShadow = "";
      });
      highlightActiveToken();
    }
    function highlightActiveToken(){
      state.players.forEach((pl,i)=>{
        const t = document.getElementById(`token-${i}`);
        if(!t) return;
        if(i === state.currentPlayerIndex) t.style.outline = "3px solid rgba(0,0,0,0.08)";
        else t.style.outline = "none";
      });
    }

    function renderPlayersPanel(){
      const playersPanelEl = $("#players-panel");
      if(!playersPanelEl) return;
      playersPanelEl.innerHTML = "";
      state.players.forEach((pl, i)=>{
        const row = document.createElement("div"); row.className = "player-row";
        const left = document.createElement("div"); left.style.display = "flex"; left.style.alignItems = "center"; left.style.gap = "8px";
        const badge = document.createElement("div"); badge.style.width = "18px"; badge.style.height = "18px"; badge.style.borderRadius = "50%";
        badge.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#000000"][i % 4]) || "#86BB27";
        left.appendChild(badge);
        const name = document.createElement("div"); name.textContent = pl.name;
        left.appendChild(name);
        const right = document.createElement("div"); right.className = "attr-list";
        right.innerHTML = `<div>Â≠¶„Å≥:${pl.learning}</div><div>Ë©ï‰æ°:${pl.rating}</div><div>„É°„É≥„Çø„É´:${pl.mental}</div><div>„É¢„ÉÅ„Éô:${pl.motivation}</div><div>Ë≤¨‰ªª:${pl.responsibility}</div>`;
        row.appendChild(left); row.appendChild(right);
        playersPanelEl.appendChild(row);
      });
      highlightActive();
    }

    function renderEventsPanel(){
      const list = $("#events-list");
      if(!list) return;
      list.innerHTML = "";
      if(EVENT_TEMPLATES){
        const makeItem = (title, arr) => {
          const d = document.createElement('div'); d.className='event-item';
          d.textContent = `${title}: ${arr.length}‰ª∂`;
          list.appendChild(d);
        };
        if(EVENT_TEMPLATES.junior) makeItem('Junior', EVENT_TEMPLATES.junior);
        if(EVENT_TEMPLATES.mid) makeItem('Mid', EVENT_TEMPLATES.mid);
        if(EVENT_TEMPLATES.senior) makeItem('Senior', EVENT_TEMPLATES.senior);
      } else {
        list.textContent = '„Ç§„Éô„É≥„Éà„ÉÜ„É≥„Éó„É¨„Éº„ÉàË™≠„ÅøËæº„Åø„Å™„Åó';
      }
    }

    function removeFallbacks(){ document.querySelectorAll('.modal-fallback').forEach(e=>e.remove()); }
    function createModalCard(isBottom){
      removeFallbacks();
      const overlay = document.createElement('div'); overlay.className='modal-fallback';
      if(isBottom) overlay.classList.add('modal-bottom');
      const card = document.createElement('div'); card.className='card';
      overlay.appendChild(card);
      document.body.appendChild(overlay);
      return { overlay, card };
    }

    // Generic simple card
    function showCard(title, body){
      return new Promise(resolve=>{
        const isBottom = isMobile;
        const { overlay, card } = createModalCard(isBottom);
        const h = document.createElement('div'); h.className='event-title'; h.textContent = title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = body;
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
        ok.addEventListener('click', ()=>{ overlay.remove(); resolve(true); });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(b); card.appendChild(actions);
        ok.focus();
      });
    }

    function openBottomSheet(kind){
      const isBottom = true;
      const { overlay, card } = createModalCard(isBottom);
      const h = document.createElement('div'); h.className='event-title'; h.textContent = (kind === 'players' ? '„Éó„É¨„Ç§„É§„Éº' : '„É≠„Ç∞');
      const content = document.createElement('div'); content.style.overflow='auto'; content.style.maxHeight='70vh';
      if(kind === 'players'){
        const clone = $("#players-panel").cloneNode(true);
        clone.style.display = 'block';
        content.appendChild(clone);
      } else {
        const clone = $("#log").cloneNode(true);
        clone.style.display = 'block';
        content.appendChild(clone);
      }
      const actions = document.createElement('div'); actions.style.textAlign='right';
      const close = document.createElement('button'); close.className='primary'; close.textContent='Èñâ„Åò„Çã';
      close.addEventListener('click', ()=> overlay.remove());
      actions.appendChild(close);
      card.appendChild(h); card.appendChild(content); card.appendChild(actions);
      close.focus();
    }

    // --- RULES modal (read-only plain text) ---
    function openRulesModal(){
      const isBottom = isMobile;
      const { overlay, card } = createModalCard(isBottom);
      const h = document.createElement('div'); h.className='event-title'; h.textContent = 'ÈÅä„Å≥Êñπ / „É´„Éº„É´';
      const body = document.createElement('div'); body.className = 'event-body';
      // plain non-editable text block with bold initial text
      const content = document.createElement('div');
      content.className = 'rules-content';
      // use <strong> to ensure bold rendering; we also set font-weight in CSS but keep <strong> as requested
      const strong = document.createElement('strong');
      strong.textContent = '„Åì„Åì„Å´„É´„Éº„É´„ÇíÂÖ•„Çå„Çã';
      content.appendChild(strong);
      body.appendChild(content);

      const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.justifyContent = 'flex-end'; actions.style.gap = '8px';
      const close = document.createElement('button'); close.className = 'primary'; close.textContent = 'Èñâ„Åò„Çã';
      close.addEventListener('click', ()=> overlay.remove());
      actions.appendChild(close);

      card.appendChild(h); card.appendChild(body); card.appendChild(actions);
      // focus close button so users can't accidentally focus text
      close.focus();
    }

    // --- other game/event functions remain unchanged from prior implementation ---
    function applyAttributeChanges(playerIndex, changes){
      const pl = state.players[playerIndex];
      if(!pl) return;
      const attrs = ['learning','rating','mental','motivation','responsibility'];
      attrs.forEach(a=>{
        if(typeof changes[a] === 'number' && changes[a] !== 0){
          pl[a] = Math.max(0, (pl[a]||0) + Math.round(changes[a]));
        }
      });
      pushLog(`${pl.name}: Â±ûÊÄß„ÅåÂ§âÂåñ„Åó„Åæ„Åó„Åü ‚Üí ${Object.entries(changes).filter(([k,v])=>v!==0).map(([k,v])=> `${k} ${v>0?'+':''}${v}`).join(', ')}`, "ok");
      renderPlayersPanel();
    }

    // (handleEventTile, pickEventForPlayer, resolveCell, final results, start/reset etc. remain the same)
    function eventStageForPlayer(pl){
      const pos = typeof pl.position === "number" ? pl.position : 0;
      if(pos >= 30) return "senior";
      if(pos >= 15) return "mid";
      return "junior";
    }
    function pickEventForPlayer(playerIndex){
      const pl = state.players[playerIndex];
      if(!pl) return null;
      const stage = eventStageForPlayer(pl);
      const pool = (EVENT_TEMPLATES && EVENT_TEMPLATES[stage]) ? EVENT_TEMPLATES[stage] : [];
      if(!pool || !pool.length) return null;
      const weights = pool.map(c => {
        let w = 1;
        const ch = c.changes || {};
        if((pl.learning||0) < 40 && (ch.learning || 0) > 0) w += 1.6;
        if((pl.motivation||0) < 40 && (ch.motivation || 0) > 0) w += 1.4;
        if((pl.rating||0) < 40 && (ch.rating || 0) > 0) w += 1.2;
        if(c.choices) w += 0.3;
        return w;
      });
      const total = weights.reduce((a,b)=>a+b,0);
      let r = state.rng() * total;
      for(let i=0;i<pool.length;i++){
        r -= weights[i];
        if(r <= 0) return pool[i];
      }
      return pool[pool.length-1];
    }

    async function handleEventTile(playerIndex){
      const tmpl = pickEventForPlayer(playerIndex);
      if(!tmpl) return;
      if(tmpl.choices && Array.isArray(tmpl.choices)){
        await showChoiceModal(playerIndex, tmpl);
      } else {
        await showEventModal(playerIndex, tmpl);
      }
    }

    async function showEventModal(playerIndex, tmpl){
      const isBottom = isMobile;
      const { overlay, card } = createModalCard(isBottom);
      const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
      const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
      const chg = document.createElement('div'); chg.className='event-changes';
      const changes = tmpl.changes || {};
      const parts = [];
      if(changes.learning) parts.push(`Â≠¶„Å≥ Ôºã${changes.learning}`);
      if(changes.rating) parts.push(`Ë©ï‰æ° Ôºã${changes.rating}`);
      if(changes.mental) parts.push(`„É°„É≥„Çø„É´ Ôºã${changes.mental}`);
      if(changes.motivation) parts.push(`„É¢„ÉÅ„Éô Ôºã${changes.motivation}`);
      if(changes.responsibility) parts.push(`Ë≤¨‰ªª Ôºã${changes.responsibility}`);
      chg.textContent = parts.join('„ÄÄ');
      const actions = document.createElement('div'); actions.style.textAlign='right';
      const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
      ok.addEventListener('click', ()=>{
        applyAttributeChanges(playerIndex, changes);
        overlay.remove();
      });
      actions.appendChild(ok);
      card.appendChild(h); card.appendChild(b); card.appendChild(chg); card.appendChild(actions);
      ok.focus();
    }

    async function showChoiceModal(playerIndex, tmpl){
      const isBottom = isMobile;
      const { overlay, card } = createModalCard(isBottom);
      const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
      const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
      const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.justifyContent = 'flex-end'; actions.style.gap = '8px';
      (tmpl.choices||[]).forEach(choice=>{
        const btn = document.createElement('button'); btn.type='button'; btn.className='choice-btn'; btn.textContent = choice.label;
        if(isBottom){ btn.style.display = 'block'; btn.style.width = '100%'; btn.style.marginBottom = '10px'; }
        btn.addEventListener('click', async ()=> {
          overlay.remove();
          const isOrderChoice = /ÂèóÊ≥®/.test(choice.label);
          if(isOrderChoice){
            const success = Math.random() < 0.5;
            if(success){
              applyAttributeChanges(playerIndex, choice.changes || {});
              await showCard(choice.resultText || "ÂèóÊ≥®„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü", "");
            } else {
              applyAttributeChanges(playerIndex, { learning: 2 });
              const failText = choice.resultText ? `${choice.resultText}\n\n„Åó„Åã„ÅóÂ§±Êïó„Åã„Çâ„ÇÇÂ≠¶„Å≥„Åå„ÅÇ„Çä„Åæ„Åó„Åü„ÄÇÂ≠¶„Å≥ +2` : "Â§±Êïó„Åã„Çâ„ÇÇÂ≠¶„Çì„Å†ÔºÅ Â≠¶„Å≥ +2";
              await showCard("Â§±Êïó„Åã„Çâ„ÇÇÂ≠¶„Çì„Å†ÔºÅ", failText);
            }
          } else {
            applyAttributeChanges(playerIndex, choice.changes || {});
            await showCard(choice.resultText || "ÈÅ∏ÊäûÁµêÊûú", "");
          }
        });
        actions.appendChild(btn);
      });
      const cancel = document.createElement('button'); cancel.type='button'; cancel.textContent='„ÇÑ„ÇÅ„Çã';
      if(isBottom){ cancel.style.display='block'; cancel.style.width='100%'; cancel.style.marginTop='8px'; }
      cancel.addEventListener('click', ()=> overlay.remove());
      actions.appendChild(cancel);
      card.appendChild(h); card.appendChild(b); card.appendChild(actions);
      const firstBtn = card.querySelector('button.choice-btn');
      if(firstBtn) firstBtn.focus();
    }

    async function resolveCell(playerIndex, pathIndex){
      const pl = state.players[playerIndex];
      if(pl == null) return;
      const tileEl = document.querySelector(`.tile[data-path-index="${pathIndex}"]`);
      if(!tileEl){ renderPlayersPanel(); return; }
      if(tileEl.classList.contains("goal")){
        if(!pl.finished){
          pl.finished = true;
          pl.finishedAt = Date.now();
        }
        pushLog(`${pl.name}: „Ç¥„Éº„É´ÔºÅ`, "ok");
        await showCard("„Ç¥„Éº„É´", `${pl.name} „Åå„Ç¥„Éº„É´„Åó„Åæ„Åó„Åü`);
        renderPlayersPanel();
        const allFinished = state.players.length > 0 && state.players.every(p => !!p.finished);
        if(allFinished){
          setTimeout(()=> showFinalResultsModal(), 400);
        }
      } else {
        renderPlayersPanel();
      }
    }

    const SCORE_WEIGHTS = { rating: 3.0, learning: 1.5, motivation: 1.2, mental: 1.0, responsibility: 2.0 };
    function computeFinalResults(){
      const rows = state.players.map((p, i) => {
        const attrs = {
          learning: Number(p.learning || 0),
          rating: Number(p.rating || 0),
          mental: Number(p.mental || 0),
          motivation: Number(p.motivation || 0),
          responsibility: Number(p.responsibility || 0)
        };
        const score = Math.round(
          attrs.rating * SCORE_WEIGHTS.rating +
          attrs.learning * SCORE_WEIGHTS.learning +
          attrs.motivation * SCORE_WEIGHTS.motivation +
          attrs.mental * SCORE_WEIGHTS.mental +
          attrs.responsibility * SCORE_WEIGHTS.responsibility
        );
        return {
          index: i,
          name: p.name,
          score,
          attrs,
          finishedAt: p.finishedAt || null,
          finished: !!p.finished
        };
      });

      rows.sort((a,b)=>{
        if(b.score !== a.score) return b.score - a.score;
        if(a.finished && b.finished){
          if(a.finishedAt && b.finishedAt) return a.finishedAt - b.finishedAt;
          if(a.finishedAt) return -1;
          if(b.finishedAt) return 1;
        }
        return a.name.localeCompare(b.name, 'ja');
      });

      let lastScore = null, lastRank = 0, count = 0;
      rows.forEach(r=>{
        count++;
        if(r.score !== lastScore){
          lastRank = count;
          lastScore = r.score;
        }
        r.rank = lastRank;
      });

      return rows;
    }

    function showFinalResultsModal(){
      const results = computeFinalResults();
      const isBottom = isMobile;
      const { overlay, card } = createModalCard(isBottom);
      const title = document.createElement('div'); title.className='event-title'; title.textContent = 'ÊúÄÁµÇÁµêÊûú';
      const subtitle = document.createElement('div'); subtitle.className='small-muted'; subtitle.textContent = `ÈõÜË®à: ${new Date().toLocaleString()}`;
      card.appendChild(title); card.appendChild(subtitle);
      const table = document.createElement('table'); table.className='results-table';
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr><th>È†Ü‰Ωç</th><th>ÂêçÂâç</th><th>„Çπ„Ç≥„Ç¢</th><th>Â≠¶„Å≥</th><th>Ë©ï‰æ°</th><th>„É°„É≥„Çø„É´</th><th>„É¢„ÉÅ„Éô</th><th>Ë≤¨‰ªª</th><th>ÂÇôËÄÉ</th></tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      results.forEach((r,i)=>{
        const tr = document.createElement('tr');
        if(i===0) tr.classList.add('results-winner');
        const note = r.finished ? (r.finishedAt ? `„Ç¥„Éº„É´Ê∏à (${new Date(r.finishedAt).toLocaleTimeString()})` : '„Ç¥„Éº„É´Ê∏à') : '';
        tr.innerHTML = `<td>${r.rank}</td><td>${r.name}</td><td>${r.score}</td>
          <td>${r.attrs.learning}</td><td>${r.attrs.rating}</td><td>${r.attrs.mental}</td><td>${r.attrs.motivation}</td><td>${r.attrs.responsibility}</td>
          <td class="small-muted">${note}</td>`;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      card.appendChild(table);
      const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px'; actions.style.marginTop='12px';
      const btnClose = document.createElement('button'); btnClose.className='primary'; btnClose.textContent='Èñâ„Åò„Çã';
      btnClose.addEventListener('click', ()=> overlay.remove());
      actions.appendChild(btnClose);
      card.appendChild(actions);
      btnClose.focus();
    }

    function startGame(){
      if(state.started) return;
      const names = getPlayerNames();
      state.players = names.map((n,i)=>({
        name: n,
        position: 0,
        learning: 50,
        rating: 50,
        mental: 50,
        motivation: 50,
        responsibility: 0,
        finished: false,
        finishedAt: null
      }));
      state.started = true;
      state.turn = 1;
      state.currentPlayerIndex = 0;
      $("#stat-turn").textContent = String(state.turn);
      $("#stat-current").textContent = state.players[state.currentPlayerIndex].name;
      layoutTiles();
      renderPlayersPanel();
      pushLog("„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Åæ„Åó„ÅüÔºà„Éó„É¨„Ç§„É§„Éº„ÅØ„Çπ„Çø„Éº„Éà„Éû„Çπ„Å´ÈÖçÁΩÆ„Åï„Çå„Åæ„ÅôÔºâ", "ok");
      state.animating = false;
      updateRollState();
    }

    function resetGame(){
      state.started = false;
      state.turn = 0;
      state.currentPlayerIndex = 0;
      state.players = [];
      $("#stat-turn").textContent = "0";
      $("#stat-current").textContent = "-";
      document.querySelectorAll(".token").forEach(t=>t.remove());
      $("#players-panel").innerHTML = "";
      pushLog("„Ç≤„Éº„É†„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü", "ok");
      state.animating = false;
      updateRollState();
    }

    // expose a couple helpers for debugging
    window.createModalCard = createModalCard;
    window.__game = { state, layoutTiles, startGame, resetGame };

    function getCssNumber(name, fallback){
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : fallback;
    }
  })();
  </script>
</body>
</html>
