<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>人生ゲーム ver-12</title>
  <!-- Favicon (as requested) -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --board-cols:8; --board-rows:5; --cell-size:72px;
      --accent:#ff6b6b; --bg:#fffaf0; --text:#222; --active:#4c9aff;
      --ok:#00c853; --warn:#ff8f00; --bad:#e53935; --muted:#94a3b8;
      --zoom-step:8px;
      --board-max-width: calc(var(--cell-size) * var(--board-cols) + 32px);
      --kpi-bar-height:10px;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; align-items:stretch;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--text); background:var(--bg);
      min-height:100vh;
    }

    /* ===== App Bar / Toolbar ===== */
    .appbar{position:sticky; top:0; z-index:40; width:100%; display:flex; justify-content:center; background:linear-gradient(180deg, rgba(255,250,240,.98), rgba(255,250,240,.9)); backdrop-filter:saturate(1.05)}
    .toolbar{width:100%; padding:8px 10px; display:flex; flex-wrap:wrap; align-items:center; gap:8px}
    .title{font-weight:800; font-size:16px; color:#111; letter-spacing:.02em; white-space:nowrap; margin-right:auto}

    .group{display:flex; align-items:center; gap:6px; padding:6px 8px; background:#fff; border:1px solid #e6e8eb; border-radius:10px}
    label{font-size:12px; color:#555}
    select,input[type="number"],input[type="text"],input[type="range"],textarea,select{padding:6px 8px; border-radius:8px; border:1px solid #ddd}
    input[type="range"]{width:120px}
    button{padding:8px 10px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer; font-weight:600}
    button.primary{background:var(--accent); color:#fff; border-color:transparent}
    button:disabled{opacity:.5; cursor:not-allowed}
    .dice{width:40px; height:40px; display:grid; place-items:center; border-radius:8px; border:1px solid #e2e8f0; background:#fff; font-weight:800}
    .dice.spin{animation:spin .6s ease}
    @keyframes spin{0%{transform:rotate(0)}50%{transform:rotate(180deg) scale(1.05)}100%{transform:rotate(360deg)}}

    /* ===== Layout ===== */
    .wrap{width:100%; padding:12px; display:grid; grid-template-columns:3fr 1.1fr; gap:10px; flex:1; align-items:start}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* ===== Board ===== */
    .board-wrap{display:flex; justify-content:center; align-items:flex-start}
    .board{background:#fff; border:2px solid #eee; border-radius:12px; padding:8px; position:relative; display:grid; gap:6px;
      grid-template-columns:repeat(var(--board-cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      justify-content:center; align-content:start;
      max-width: var(--board-max-width);
    }
    .cell{background:#f9fafb; border:1px solid #e6e8eb; border-radius:10px; padding:6px; display:grid; place-items:center; font-size:12px; position:relative; cursor:default}
    .cell.start{background:#d1f7c4}
    .cell.goal{background:#cde7ff}
    .cell.event{background:#fff4cc}
    .cell.penalty{background:#ffe0e0}
    .cell.bonus{background:#e8ffea}
    .cell .idx{position:absolute; top:4px; left:6px; font-size:10px; color:#999}

    /* ===== Tokens ===== */
    .token{width:28px; height:28px; border-radius:50%; border:2px solid #333; display:grid; place-items:center; color:#fff; font-size:12px; font-weight:700; box-shadow:0 4px 10px rgba(0,0,0,.15); transition:transform .18s ease}
    .token.finished{opacity:.6; border-color:#777}
    .token.active{outline:3px solid rgba(76,154,255,.5)}

    /* ===== Sidebar ===== */
    .sidebar{background:#fff; border:2px solid #eee; border-radius:12px; padding:12px; display:grid; gap:12px; height:fit-content}
    .stat{display:flex; justify-content:space-between; gap:8px; padding:8px 10px; background:#f5f7fa; border-radius:10px}
    .players{display:grid; gap:8px}
    .player-row{display:grid; grid-template-columns:1.35fr .8fr .8fr .8fr; gap:8px; align-items:center; padding:8px 10px; background:#fafcff; border:1px solid #eee; border-radius:10px}
    .player-row.active{border-color:var(--active); box-shadow:0 0 0 2px rgba(76,154,255,.2) inset}
    .badge{width:18px; height:18px; border-radius:50%; border:2px solid #333; display:inline-block; margin-right:6px}
    .ach-badge{background:#ffd54f;color:#111;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px}
    .money{justify-self:end; font-weight:700; transition:color 240ms ease, transform 240ms ease}
    .money.flash-plus{color:#0a7a2d; transform:scale(1.06)}
    .money.flash-minus{color:#b00020; transform:scale(.96)}

    /* KPI dashboard */
    .kpi{display:grid; gap:8px; padding:8px; border-radius:8px; background:#fff; border:1px solid #eee}
    .kpi-row{display:grid; grid-template-columns:1fr 80px; gap:8px; align-items:center}
    .kpi-bar{height:var(--kpi-bar-height); background:#eee; border-radius:6px; overflow:hidden}
    .kpi-bar > .fill{height:100%; background:linear-gradient(90deg,#4c9aff,#00c853); width:0%}

    .log{border:1px solid #eee; border-radius:10px; background:#fafcff; padding:10px; max-height:300px; overflow:auto; font-size:13px; line-height:1.4}
    .log p{margin:0 0 6px}
    .log p.ok{color:var(--ok)}
    .log p.bad{color:var(--bad)}
    .footer{font-size:12px; color:#777}

    /* ===== Tooltips / Overlays ===== */
    #tooltip{position:fixed; pointer-events:none; z-index:50; background:rgba(20,20,20,0.95); color:#fff; padding:8px 10px; border-radius:6px; font-size:13px; max-width:260px; display:none}
    .kbd{background:#111;color:#fff;padding:2px 6px;border-radius:4px;font-weight:700;font-size:12px;display:inline-block}

    /* ===== Modal ===== */
    dialog.modal{border:none; border-radius:12px; padding:0; width:min(92vw,760px)}
    .card{padding:16px; border-radius:12px; background:#fff}
    .card h3{margin:0 0 6px}
    .card p{margin:0 0 8px}
    .card .muted{color:#64748b; font-size:12px}
    .card .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}
    .card .actions button{min-width:84px}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e5e7eb; padding:8px; text-align:left}
    th{background:#f8fafc}

    /* Other helpers */
    .tiny{font-size:12px;padding:6px 8px}
    .slot-select{min-width:120px}
    .help-list{line-height:1.6}
    .choice-row{display:flex; gap:6px; align-items:center; margin-bottom:6px}
    .choice-row input[type="number"]{width:84px}
    .choice-row input[type="text"]{flex:1}
    .branch-editor { display:grid; gap:8px; }
    .choices-list{border:1px dashed #ddd; padding:8px; border-radius:8px; max-height:260px; overflow:auto}
    .ach-list{display:grid; gap:6px; max-height:360px; overflow:auto}
    .ach-row{display:flex; justify-content:space-between; align-items:center; padding:8px; border-radius:8px; background:#fff; border:1px solid #eee}
    .ach-locked{opacity:0.55}
  </style>
</head>
<body>
  <!-- App Bar -->
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title" id="app-title">人生ゲーム ver-12</div>

      <div class="group"><label for="scenario-select">ケース</label>
        <select id="scenario-select"></select>
        <button id="btn-manage-scenarios" class="tiny">管理</button>
      </div>

      <div class="group"><label for="players-count">人数</label><select id="players-count"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option></select></div>
      <div class="group"><label for="initial-money">初期資金</label><input id="initial-money" type="number" value="20000" min="0" step="1000" /></div>

      <div class="group"><label for="rng-seed">シード</label><input id="rng-seed" type="text" placeholder="任意(空=ランダム)" /></div>
      <div class="group"><label for="speed">速度</label><input id="speed" type="range" min="80" max="400" value="180" /></div>

      <div class="group"><label for="overshoot">ゴール超過</label><select id="overshoot"><option value="clamp" selected>止まる</option><option value="bounce">反射</option></select></div>
      <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>

      <button id="btn-start" class="primary">開始</button>
      <button id="btn-roll" disabled>サイコロ</button>
      <button id="btn-reset">リセット</button>

      <div class="group">
        <label>保存スロット</label>
        <select id="save-slot" class="slot-select">
          <option value="1">Slot 1</option>
          <option value="2">Slot 2</option>
          <option value="3">Slot 3</option>
        </select>
        <button id="btn-save-slot" class="tiny">保存</button>
        <button id="btn-load-slot" class="tiny">読込</button>
        <button id="btn-delete-slot" class="tiny">削除</button>
      </div>

      <button id="btn-save" title="ローカルに保存">保存（手動）</button>
      <button id="btn-load" title="保存から読込">読込</button>
      <button id="btn-export" title="JSONエクスポート">Export</button>
      <input id="file-import" type="file" accept="application/json" hidden />
      <button id="btn-import" title="JSONインポート">Import</button>

      <button id="btn-settings" title="プレイヤー設定">設定</button>
      <button id="btn-import-personas" title="ペルソナJSONを読み込む">ペルソナ読み込み</button>
      <button id="btn-manage-personas" title="ペルソナ管理">ペルソナ管理</button>

      <div class="group">
        <button id="btn-zoom-in" title="ズームイン">ズーム＋</button>
        <button id="btn-zoom-out" title="ズームアウト">ズーム−</button>
        <button id="btn-fit" title="画面に合わせる">フィット</button>
      </div>

      <div class="group">
        <button id="btn-history" title="イベント履歴">履歴</button>
        <button id="btn-shortcuts" title="ショートカット">操作ヘルプ</button>
        <button id="btn-achievements" title="実績">実績</button>
      </div>

      <input id="file-personas" type="file" accept="application/json" hidden />
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <main class="board" id="board" aria-label="ボード"></main>
    </div>
    <aside class="sidebar">
      <div class="kpi" id="kpi-dashboard" aria-live="polite">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <strong>KPI ダッシュボード</strong>
          <small id="scenario-summary" class="muted"></small>
        </div>
        <div class="kpi-row"><div>予算残高</div><div id="kpi-budget" style="text-align:right">-</div></div>
        <div class="kpi-row"><div>クライアント満足度</div><div style="width:100%"><div class="kpi-bar"><div id="kpi-client-fill" class="fill" style="width:0%"></div></div></div></div>
        <div class="kpi-row"><div>進捗</div><div style="width:100%"><div class="kpi-bar"><div id="kpi-progress-fill" class="fill" style="width:0%"></div></div></div></div>
        <div class="kpi-row"><div>インパクト(累積収支)</div><div id="kpi-impact" style="text-align:right">-</div></div>
      </div>

      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>
      <div class="players" id="players-panel"></div>
      <div class="log" id="log" aria-live="polite" aria-atomic="false"></div>
      <div class="footer">Space/Enterでサイコロ。全員がゴールすると結果発表。</div>
    </aside>
  </div>

  <!-- Tooltip -->
  <div id="tooltip" role="tooltip" aria-hidden="true"></div>

  <!-- Scenario Manager Modal -->
  <dialog class="modal" id="scenario-modal" aria-labelledby="scenario-title">
    <div class="card">
      <h3 id="scenario-title">ケース（シナリオ）管理</h3>
      <p class="small">案件テンプレートを追加・編集・削除できます。KPIは簡易で設定します。</p>
      <table style="width:100%; border-collapse:collapse">
        <thead><tr><th>#</th><th>タイトル</th><th>予算</th><th>期限(ターン)</th><th>KPI(target)</th><th>アクション</th></tr></thead>
        <tbody id="scenario-tbody"></tbody>
      </table>
      <div style="display:flex; gap:8px; margin-top:8px">
        <button id="scenario-add">シナリオ追加</button>
        <button id="scenario-save" class="primary">保存</button>
        <button id="scenario-close">閉じる</button>
      </div>
    </div>
  </dialog>

  <!-- History Modal -->
  <dialog class="modal" id="history-modal" aria-labelledby="history-title">
    <div class="card">
      <h3 id="history-title">イベント履歴</h3>
      <div id="history-body" style="max-height:360px; overflow:auto;"></div>
      <div class="actions">
        <button id="history-close" class="primary">閉じる</button>
        <button id="history-clear">クリア</button>
      </div>
    </div>
  </dialog>

  <!-- Shortcuts Modal -->
  <dialog class="modal" id="shortcuts-modal" aria-labelledby="shortcuts-title">
    <div class="card">
      <h3 id="shortcuts-title">操作ショートカット</h3>
      <div class="help-list">
        Space / Enter: サイコロを振る<br>
        S: 保存スロットをクイック保存<br>
        L: 保存スロットをクイック読込<br>
        H: このヘルプを開く/閉じる<br>
        Z / Shift+Z: ズームイン / ズームアウト<br>
        F: 盤面を画面にフィット<br>
      </div>
      <div class="actions"><button id="shortcuts-close" class="primary">閉じる</button></div>
    </div>
  </dialog>

  <!-- Settings Modal -->
  <dialog class="modal" id="settings-modal" aria-labelledby="settings-title">
    <div class="card">
      <h3 id="settings-title">プレイヤー設定</h3>
      <p class="small">人数は上部の「人数」で切り替え。あらかじめ用意したペルソナから選べます。</p>
      <div id="settings-list" class="settings-list"></div>
      <div class="actions">
        <button id="settings-cancel">キャンセル</button>
        <button id="settings-save" class="primary">保存</button>
      </div>
    </div>
  </dialog>

  <!-- Persona Manager Modal -->
  <dialog class="modal" id="persona-modal" aria-labelledby="persona-title">
    <div class="card">
      <h3 id="persona-title">ペルソナ管理</h3>
      <p class="small">ペルソナを追加・編集・削除できます。イベントはGUIで詳しく編集できます。</p>
      <table class="persona-table" id="persona-table">
        <thead><tr><th>#</th><th>表示名</th><th>色</th><th>イベント（簡易編集）</th><th>分岐イベント</th><th>アクション</th></tr></thead>
        <tbody id="persona-tbody"></tbody>
      </table>
      <div style="display:flex; gap:8px; margin-top:8px">
        <button id="persona-add">ペルソナ追加</button>
        <button id="persona-save" class="primary">保存</button>
        <button id="persona-export">エクスポート</button>
        <button id="persona-close">閉じる</button>
      </div>
    </div>
  </dialog>

  <!-- Branch Editor Modal (rich) -->
  <dialog class="modal" id="branch-editor-modal" aria-labelledby="branch-editor-title">
    <div class="card">
      <h3 id="branch-editor-title">分岐イベントエディタ</h3>
      <div id="branch-editor" class="branch-editor">
        <label>イベント本文 (プレイヤーに表示される説明)</label>
        <input id="branch-text" type="text" placeholder="イベントの説明を入力" />
        <div>
          <strong>選択肢</strong>
          <div class="choices-list" id="choices-list"></div>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="branch-add-choice">選択肢を追加</button>
            <button id="branch-preview" class="primary">プレビュー（乱数で判定）</button>
            <div style="flex:1"></div>
            <button id="branch-save" class="primary">保存</button>
            <button id="branch-cancel">キャンセル</button>
          </div>
        </div>
      </div>
    </div>
  </dialog>

  <!-- Generic Event Modal -->
  <dialog class="modal" id="modal" aria-labelledby="modal-title">
    <div class="card">
      <h3 id="modal-title">イベント</h3>
      <div id="modal-text" style="white-space:normal;"></div>
      <div class="muted" id="modal-sub"></div>
      <div class="actions" id="modal-actions">
        <button id="modal-close" class="primary">OK</button>
      </div>
    </div>
  </dialog>

  <!-- Result Modal -->
  <dialog class="modal" id="result" aria-labelledby="result-title">
    <div class="card">
      <h3 id="result-title">結果発表</h3>
      <div id="result-body"></div>
      <div class="actions"><button id="result-close" class="primary">閉じる</button></div>
    </div>
  </dialog>

  <!-- Achievements Modal -->
  <dialog class="modal" id="achievements-modal" aria-labelledby="achievements-title">
    <div class="card">
      <h3 id="achievements-title">実績</h3>
      <div class="ach-list" id="ach-list"></div>
      <div class="actions">
        <button id="ach-close" class="primary">閉じる</button>
        <button id="ach-reset">リセット</button>
      </div>
    </div>
  </dialog>

  <script>
  // ===========================
  // ver-12: Adds Scenario Templates + KPI Dashboard
  // Full integrated script; includes scenarios, KPI logic, persona, achievements, UI helpers
  // ===========================
  (function(){
    const $ = s => document.querySelector(s);
    // DOM refs
    const boardEl = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const playersCountSel = $("#players-count"), initialMoneyInput = $("#initial-money");
    const rngSeedInput = $("#rng-seed"), speedInput = $("#speed"), overshootSel = $("#overshoot");
    const scenarioSelect = $("#scenario-select"), btnManageScenarios = $("#btn-manage-scenarios");
    const kpiBudgetEl = $("#kpi-budget"), kpiClientFill = $("#kpi-client-fill"), kpiProgressFill = $("#kpi-progress-fill"), kpiImpactEl = $("#kpi-impact"), scenarioSummaryEl = $("#scenario-summary");
    // Modals
    const scenarioModal = $("#scenario-modal"), scenarioTbody = $("#scenario-tbody"), scenarioAddBtn = $("#scenario-add"), scenarioSaveBtn = $("#scenario-save"), scenarioCloseBtn = $("#scenario-close");
    // other existing refs (history, achievements...) are used by other parts of previous code
    const btnHistory = $("#btn-history"), historyModal = $("#history-modal"), historyBody = $("#history-body"), historyClose = $("#history-close"), historyClear = $("#history-clear");
    const btnShortcuts = $("#btn-shortcuts"), shortcutsModal = $("#shortcuts-modal"), shortcutsClose = $("#shortcuts-close");
    const settingsBtn = $("#btn-settings"), settingsModal = $("#settings-modal"), settingsListEl = $("#settings-list"), settingsSaveBtn = $("#settings-save"), settingsCancelBtn = $("#settings-cancel");
    const filePersonas = $("#file-personas"), btnImportPersonas = $("#btn-import-personas");
    const personaModal = $("#persona-modal"), personaTbody = $("#persona-tbody"), personaAddBtn = $("#persona-add"), personaSaveBtn = $("#persona-save"), personaExportBtn = $("#persona-export"), personaCloseBtn = $("#persona-close");
    const branchEditorModal = $("#branch-editor-modal"), branchTextInput = $("#branch-text"), choicesListEl = $("#choices-list");
    const branchAddChoiceBtn = $("#branch-add-choice"), branchSaveBtn = $("#branch-save"), branchCancelBtn = $("#branch-cancel"), branchPreviewBtn = $("#branch-preview");
    const genericModal = $("#modal"), genericTitle = $("#modal-title"), genericText = $("#modal-text"), genericSub = $("#modal-sub"), genericActions = $("#modal-actions");
    const resultDlg = $("#result"), resultBody = $("#result-body"), resultClose = $("#result-close");
    const btnAchievements = $("#btn-achievements"), achModal = $("#achievements-modal"), achListEl = $("#ach-list"), achClose = $("#ach-close"), achReset = $("#ach-reset");

    // constants
    const BOARD_COLS = 8, BOARD_ROWS = 5, TOTAL_CELLS = BOARD_COLS * BOARD_ROWS;
    const PLAYER_COLORS = ["#ff6b6b", "#4c9aff", "#00c853", "#ff8f00", "#9c27b0", "#00acc1"];
    const BRANCH_CHANCE = 0.30;

    // Scenario store (templates)
    const SCENARIO_KEY = "ltm-scenarios-v1";
    let scenarios = [];
    const DEFAULT_SCENARIOS = [
      {
        id: "dx-intro",
        title: "DX導入支援（中小企業）",
        description: "レガシーシステムのクラウド移行と業務効率化。期限と予算が厳しい。",
        budget: 200000,
        deadlineTurns: 20,
        kpis: { clientSatisfactionTarget: 80, progressTarget: 100, budgetTarget: 0 /* lower is ok */ }
      },
      {
        id: "process-revamp",
        title: "業務改革（コスト削減）",
        description: "現場の抵抗が強いがコスト削減を求められている案件。",
        budget: 150000,
        deadlineTurns: 16,
        kpis: { clientSatisfactionTarget: 70, progressTarget: 100, budgetTarget: 0 }
      },
      {
        id: "strategy",
        title: "中期経営計画策定",
        description: "経営層向けの戦略提案。成果は満足度依存。",
        budget: 120000,
        deadlineTurns: 12,
        kpis: { clientSatisfactionTarget: 85, progressTarget: 100, budgetTarget: 0 }
      }
    ];

    // personas/achievements/state (reusing earlier structures conceptually)
    let personasStore = [], PERSONAS = [], personaEventMap = {}, personaBranchMap = {};
    function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
    function saveScenarios(){ try{ localStorage.setItem(SCENARIO_KEY, JSON.stringify(scenarios)); }catch(e){} }
    function loadScenarios(){ try{ const s = localStorage.getItem(SCENARIO_KEY); if(s) { scenarios = JSON.parse(s); return; } }catch(e){} scenarios = deepClone(DEFAULT_SCENARIOS); saveScenarios(); }
    loadScenarios();

    // Populate scenario select
    function rebuildScenarioSelect(){
      scenarioSelect.innerHTML = "";
      scenarios.forEach(s=>{
        const opt = document.createElement("option"); opt.value = s.id; opt.textContent = s.title; scenarioSelect.appendChild(opt);
      });
    }
    rebuildScenarioSelect();

    // Current scenario runtime
    let currentScenario = null;
    // KPIs runtime object
    let KPIs = {
      budgetRemaining: 0,
      clientSatisfaction: 50, // 0-100
      progress: 0, // 0-100
      impact: 0 // cumulative money
    };

    function loadScenarioToState(sid){
      const s = scenarios.find(x=>x.id===sid) || scenarios[0];
      currentScenario = deepClone(s);
      KPIs.budgetRemaining = currentScenario.budget;
      KPIs.clientSatisfaction = 50;
      KPIs.progress = 0;
      KPIs.impact = 0;
      updateKPIDisplay();
      scenarioSummaryEl.textContent = `${currentScenario.title}`;
    }

    // Scenario manager UI
    function renderScenarioTable(){
      scenarioTbody.innerHTML = "";
      scenarios.forEach((s, idx)=>{
        const tr = document.createElement("tr");
        const tdIdx = document.createElement("td"); tdIdx.textContent = String(idx+1);
        const tdTitle = document.createElement("td"); const titleInput = document.createElement("input"); titleInput.type="text"; titleInput.value = s.title;
        tdTitle.appendChild(titleInput);
        const tdBudget = document.createElement("td"); const bInput = document.createElement("input"); bInput.type="number"; bInput.value = s.budget;
        tdBudget.appendChild(bInput);
        const tdDeadline = document.createElement("td"); const dInput = document.createElement("input"); dInput.type="number"; dInput.value = s.deadlineTurns;
        tdDeadline.appendChild(dInput);
        const tdKPI = document.createElement("td"); const kInput = document.createElement("input"); kInput.type="text"; kInput.value = `CS:${s.kpis.clientSatisfactionTarget},P:${s.kpis.progressTarget}`;
        tdKPI.appendChild(kInput);
        const tdAct = document.createElement("td");
        const del = document.createElement("button"); del.textContent = "削除";
        del.addEventListener("click", ()=> { if(!confirm("削除しますか？")) return; scenarios.splice(idx,1); renderScenarioTable(); rebuildScenarioSelect(); saveScenarios(); });
        tdAct.appendChild(del);
        tr.appendChild(tdIdx); tr.appendChild(tdTitle); tr.appendChild(tdBudget); tr.appendChild(tdDeadline); tr.appendChild(tdKPI); tr.appendChild(tdAct);
        scenarioTbody.appendChild(tr);
      });
    }
    scenarioAddBtn.addEventListener("click", ()=> {
      const id = `sc-${Date.now()}`;
      scenarios.push({ id, title:`新しいケース${scenarios.length+1}`, description:"", budget:100000, deadlineTurns:12, kpis:{ clientSatisfactionTarget:75, progressTarget:100 } });
      renderScenarioTable(); rebuildScenarioSelect();
    });
    scenarioSaveBtn.addEventListener("click", ()=>{
      // read table
      const rows = scenarioTbody.querySelectorAll("tr");
      rows.forEach((tr, idx)=>{
        const inputs = tr.querySelectorAll("input");
        const title = inputs[0].value || `ケース${idx+1}`;
        const budget = Number(inputs[1].value) || 100000;
        const deadline = Number(inputs[2].value) || 12;
        const kpiTxt = inputs[3].value || "";
        const csMatch = /CS:(\d+)/.exec(kpiTxt);
        const pMatch = /P:(\d+)/.exec(kpiTxt);
        const cs = csMatch ? Number(csMatch[1]) : 75;
        const p = pMatch ? Number(pMatch[1]) : 100;
        scenarios[idx].title = title;
        scenarios[idx].budget = budget;
        scenarios[idx].deadlineTurns = deadline;
        scenarios[idx].kpis.clientSatisfactionTarget = cs;
        scenarios[idx].kpis.progressTarget = p;
      });
      saveScenarios();
      rebuildScenarioSelect();
      pushLog("シナリオを保存しました", "ok");
      scenarioModal.close();
    });
    scenarioCloseBtn.addEventListener("click", ()=> scenarioModal.close());
    btnManageScenarios.addEventListener("click", ()=> { renderScenarioTable(); scenarioModal.showModal(); });

    scenarioSelect.addEventListener("change", ()=> {
      const sid = scenarioSelect.value;
      loadScenarioToState(sid);
    });

    // initialize selected scenario
    if(scenarios.length>0){ scenarioSelect.value = scenarios[0].id; loadScenarioToState(scenarios[0].id); }

    // KPI UI
    function updateKPIDisplay(){
      kpiBudgetEl.textContent = `¥${Number(KPIs.budgetRemaining).toLocaleString()}`;
      kpiImpactEl.textContent = `¥${Number(KPIs.impact).toLocaleString()}`;
      kpiClientFill.style.width = `${Math.max(0, Math.min(100, KPIs.clientSatisfaction))}%`;
      kpiProgressFill.style.width = `${Math.max(0, Math.min(100, KPIs.progress))}%`;
    }

    // generic helpers (RNG, board)
    function createRNG(seed){ if(!seed) return Math.random; let h = 2166136261 >>> 0; for (let i=0;i<seed.length;i++){ h ^= seed.charCodeAt(i); h = Math.imul(h, 16777619); } return () => { h += 0x6D2B79F5; let t = Math.imul(h ^ h>>>15, 1 | h); t ^= t + Math.imul(t ^ t>>>7, 61 | t); return ((t ^ t>>>14) >>> 0) / 4294967296; }; }
    const randPick = (rng, arr)=> arr[Math.floor(rng()*arr.length)];
    const yen = n => "¥" + Number(n).toLocaleString("ja-JP");
    const sleep = ms => new Promise(res=>setTimeout(res, ms));

    // board cells (same as before)
    const cells = Array.from({length:TOTAL_CELLS},(_,i)=>({index:i,type:"none",label:""}));
    cells[0] = {index:0,type:"start",label:"スタート"};
    cells[TOTAL_CELLS-1] = {index:TOTAL_CELLS-1,type:"goal",label:"ゴール"};
    const mark = (idxs, type, label)=> idxs.forEach(i=>{cells[i].type=type; cells[i].label=label});
    mark([3,6,9,12,15,18,23,27,31,33], "event", "イベント");
    mark([4,10,16,22,30], "bonus", "ボーナス");
    mark([8,14,20,26,34], "penalty", "ペナルティ");

    // Achievements definitions (kept simple)
    const ACHIEVEMENTS = [
      { id: "early_goal", name:"スピードゴール", desc:"早くゴールする", type:"goal_turn", threshold:12 },
      { id: "rich_100k", name:"お金持ち", desc:"所持金が¥100,000を超えた", type:"max_money", threshold:100000 },
      { id: "bonus_collector", name:"ボーナス好き", desc:"ボーナスマスに3回止まる", type:"bonus_count", threshold:3 },
      { id: "branch_master", name:"分岐の達人", desc:"分岐で成功を2回", type:"branch_success", threshold:2 },
      { id: "big_gain", name:"一発大当たり", desc:"1度に大きく稼ぐ", type:"single_gain", threshold:80000 },
      { id: "winner", name:"優勝", desc:"ゲーム終了時に1位", type:"end_rank", threshold:1 },
    ];

    // minimal persona defaults (for compatibility)
    const DEFAULT_PERSONAS = [
      { id:"shinsotsu", displayName:"新卒さん", color:"#ff6b6b", events: [{ text:"研修で評価されて昇給チャンス+¥15,000", money:15000 }], branchEvents: [] },
      { id:"chuto", displayName:"中途さん", color:"#4c9aff", events: [{ text:"即戦力でプロジェクト入り+¥25,000", money:25000 }], branchEvents: [] },
      { id:"shigodeki", displayName:"しごできさん", color:"#00c853", events: [{ text:"成果報酬で+¥40,000", money:40000 }], branchEvents: [] },
      { id:"shacho", displayName:"社長さん", color:"#ff8f00", events: [{ text:"事業が当たって大儲け+¥100,000", money:100000 }], branchEvents: [] },
    ];
    function initPersonas(){ try{ const s = localStorage.getItem("imported-personas"); if(s){ const d = JSON.parse(s); if(d && d.personas) { personasStore = d.personas; PERSONAS = personasStore.map(p=>p.displayName); personaEventMap = {}; personaBranchMap = {}; personasStore.forEach(p=>{ personaEventMap[p.displayName] = p.events.slice(); if(p.branchEvents) personaBranchMap[p.displayName]=p.branchEvents.slice(); }); return; } } }catch(e){} personasStore = deepClone(DEFAULT_PERSONAS); PERSONAS = personasStore.map(p=>p.displayName); personaEventMap = {}; personaBranchMap = {}; personasStore.forEach(p=>{ personaEventMap[p.displayName] = p.events.slice(); if(p.branchEvents) personaBranchMap[p.displayName]=p.branchEvents.slice(); }); }
    initPersonas();

    // game state
    let state = {
      started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false,
      rng: Math.random, seed:"", speed:180, overshoot:"clamp",
      playerSettings: []
    };

    function ensurePlayerSettings(count = 4){
      if(!state.playerSettings || !Array.isArray(state.playerSettings)) state.playerSettings = [];
      for(let i=0;i<count;i++){
        if(!state.playerSettings[i]) {
          state.playerSettings[i] = { persona: PERSONAS[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length] };
        }
      }
      state.playerSettings.length = count;
    }

    // Rendering & board helpers (square cells ensured in CSS)
    function indexToGrid(index){
      const row = Math.floor(index/BOARD_COLS);
      let col = index % BOARD_COLS;
      if(row % 2 === 1) col = BOARD_COLS-1-col;
      return {row, col};
    }
    function renderBoard(){
      boardEl.innerHTML = "";
      cells.forEach(cell=>{
        const div = document.createElement("div");
        div.className = "cell "+(cell.type!="none"?cell.type:"");
        div.dataset.index = String(cell.index);
        const idx = document.createElement("div"); idx.className = "idx"; idx.textContent = String(cell.index); div.appendChild(idx);
        const label = document.createElement("div"); label.textContent = cell.label||""; div.appendChild(label);
        const {row,col} = indexToGrid(cell.index); div.style.gridRowStart = row+1; div.style.gridColumnStart = col+1;
        div.addEventListener("mouseenter", e=> showCellTooltip(cell, e));
        div.addEventListener("mousemove", e=> moveTooltip(e));
        div.addEventListener("mouseleave", hideTooltip);
        boardEl.appendChild(div);
      });
      // tokens
      state.players.forEach((pl,i)=>{
        const token=document.createElement("div"); token.className="token"; token.id=tokenId(i); token.textContent=String(i+1); token.style.background=pl.color; if(pl.finished) token.classList.add("finished");
        token.style.position = "absolute"; token.style.left = "0px"; token.style.top = "0px";
        token.addEventListener("mouseenter", e=> showPlayerTooltip(pl, e));
        token.addEventListener("mousemove", e=> moveTooltip(e));
        token.addEventListener("mouseleave", hideTooltip);
        boardEl.appendChild(token);
      });
      placeAllTokens(); highlightActiveToken();
    }
    function tokenId(i){ return `token-${i}` }
    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        if(!groups.has(pl.position)) groups.set(pl.position, []);
        groups.get(pl.position).push(i);
      });
      groups.forEach((idxs, pos)=>{
        const targetCell = boardEl.querySelector(`.cell[data-index="${pos}"]`);
        if(!targetCell) return;
        const rectBoard = boardEl.getBoundingClientRect();
        const rc = targetCell.getBoundingClientRect();
        const cx = rc.left - rectBoard.left + rc.width/2; const cy = rc.top - rectBoard.top + rc.height/2;
        const r = Math.min(rc.width, rc.height) / 3.2;
        const n = idxs.length; const baseAngle = -90;
        idxs.forEach((pi, k)=>{
          const angle = baseAngle + (n===1?0: (k-(n-1)/2) * 30);
          const rad = angle * Math.PI / 180;
          const x = cx + r * Math.cos(rad) - 14; const y = cy + r * Math.sin(rad) - 14;
          const t = $("#"+tokenId(pi)); if(t) t.style.transform = `translate(${x}px, ${y}px)`;
        });
      });
    }
    function highlightActiveToken(){
      state.players.forEach((_,i)=>{
        const t=$("#"+tokenId(i)); if(!t) return; if(i===state.currentPlayerIndex) t.classList.add("active"); else t.classList.remove("active");
      });
    }

    // Sidebar players
    function moneyId(i){return `money-${i}`}
    function renderPlayersPanel(){
      playersPanelEl.innerHTML="";
      state.players.forEach((pl,i)=>{
        const row=document.createElement("div"); row.className="player-row"+(i===state.currentPlayerIndex?" active":"");
        const left=document.createElement("div");
        const badge=document.createElement("span"); badge.className="badge"; badge.style.background=pl.color; left.appendChild(badge);
        const nameText=document.createElement("span"); nameText.textContent = pl.name + (pl.finished?"（ゴール）":""); left.appendChild(nameText);
        const ach = document.createElement("div"); ach.style.marginLeft="8px"; ach.innerHTML = `<span class="ach-badge">${(pl.achievements||[]).length}</span>`;
        left.appendChild(ach);
        const pos=document.createElement("div"); pos.textContent = "位置: "+pl.position;
        const money=document.createElement("div"); money.className="money"; money.id=moneyId(i); money.textContent=yen(pl.money);
        const status=document.createElement("div"); status.textContent = pl.skipTurn?"次ターン休み":"";
        row.appendChild(left); row.appendChild(pos); row.appendChild(money); row.appendChild(status);
        playersPanelEl.appendChild(row);
      });
      updateKPIDisplay();
    }
    function flashMoney(i,delta){ const el=$("#"+moneyId(i)); if(!el) return; const cls=delta>=0?"flash-plus":"flash-minus"; el.classList.add(cls); setTimeout(()=>el.classList.remove(cls), 400) }

    // Log & History
    function pushLog(text, kind){ const p=document.createElement("p"); p.textContent=text; if(kind) p.classList.add(kind); logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }
    function showHistory(){ historyBody.innerHTML = ""; const items = Array.from(logEl.querySelectorAll("p")).slice(-200); if(items.length===0) historyBody.textContent = "履歴がありません"; items.reverse().forEach(p => { const d = document.createElement("div"); d.textContent = p.textContent; d.className = p.className; historyBody.appendChild(d); }); historyModal.showModal(); }
    historyClose.addEventListener("click", ()=> historyModal.close());
    historyClear.addEventListener("click", ()=> { if(!confirm("履歴をクリアしますか？")) return; logEl.innerHTML=""; historyBody.innerHTML=""; pushLog("履歴をクリアしました"); historyModal.close(); });

    // Tooltip
    const tooltip = $("#tooltip");
    function showCellTooltip(cell, e){
      const info = []; info.push(`マス #${cell.index}`); if(cell.type) info.push(`タイプ: ${cell.type}`); if(cell.label) info.push(`${cell.label}`);
      const recent = Array.from(logEl.querySelectorAll("p")).slice(-20).reverse().find(p => p.textContent.includes(String(cell.index)));
      if(recent) info.push(`最近: ${recent.textContent}`);
      tooltip.innerHTML = info.join("<br>"); tooltip.style.display = "block"; moveTooltip(e);
    }
    function showPlayerTooltip(pl, e){ const info=[]; info.push(`${pl.name}`); info.push(`所持金: ${yen(pl.money)}`); info.push(`位置: ${pl.position}`); if(pl.finished) info.push("ゴール済み"); tooltip.innerHTML = info.join("<br>"); tooltip.style.display = "block"; moveTooltip(e); }
    function moveTooltip(e){ const pad = 12; tooltip.style.left = (e.clientX + pad) + "px"; tooltip.style.top = Math.min(window.innerHeight - 80, e.clientY + pad) + "px"; }
    function hideTooltip(){ tooltip.style.display = "none"; }

    // Modal helpers (on-screen)
    function showCard(title, text, sub){
      genericTitle.textContent = title;
      if(typeof text === "string" && /<\/?[a-z][\s\S]*>/i.test(text)){ genericText.innerHTML = text; } else { genericText.textContent = text; }
      genericSub.textContent = sub || "";
      genericActions.innerHTML = "";
      const ok = document.createElement("button"); ok.className = "primary"; ok.textContent = "OK"; ok.addEventListener("click", ()=> genericModal.close());
      genericActions.appendChild(ok);
      genericModal.showModal();
    }

    // Achievements (simple award)
    function awardAchievement(playerIndex, achId){
      const p = state.players[playerIndex]; if(!p) return;
      p.achievements = p.achievements || [];
      if(p.achievements.find(a=>a.id===achId)) return;
      const def = ACHIEVEMENTS.find(a=>a.id===achId); if(!def) return;
      p.achievements.push({ id:def.id, name:def.name, desc:def.desc, awardedAt:new Date().toISOString() });
      pushLog(`${p.name} が実績を獲得: ${def.name}`, "ok");
      showCard("実績獲得！", def.name, def.desc);
      renderPlayersPanel();
    }
    function evaluatePlayerAchievements(i){
      const p = state.players[i]; if(!p) return;
      if(p.turnsToGoal && p.turnsToGoal <= 12) awardAchievement(i, "early_goal");
      if((p.maxMoneyReached||0) >= 100000) awardAchievement(i, "rich_100k");
      if((p.bonusCount||0) >= 3) awardAchievement(i, "bonus_collector");
      if((p.branchSuccessCount||0) >= 2) awardAchievement(i, "branch_master");
      if((p.highestSingleGain||0) >= 80000) awardAchievement(i, "big_gain");
    }
    function evaluateEndAchievements(){ const rows = state.players.map((p,i)=>({i, money:p.money})).sort((a,b)=> b.money-a.money); if(rows[0]) awardAchievement(rows[0].i, "winner"); }
    function updateAchievementsModal(){ achListEl.innerHTML = ""; ACHIEVEMENTS.forEach(a=>{ const div=document.createElement("div"); div.className="ach-row"; const left=document.createElement("div"); left.innerHTML=`<strong>${a.name}</strong><div class="muted small">${a.desc}</div>`; const right=document.createElement("div"); const makers = state.players.map((p, idx)=> ({p, idx})).filter(o=> (o.p.achievements||[]).find(x=>x.id===a.id)); right.innerHTML = makers.length>0 ? makers.map(m=>m.p.name).join(", ") : `<span class="ach-locked">未獲得</span>`; div.appendChild(left); div.appendChild(right); achListEl.appendChild(div); }); }
    achClose.addEventListener("click", ()=> achModal.close());
    achReset.addEventListener("click", ()=> { if(!confirm("全実績をリセットしますか？")) return; state.players.forEach(p=>{ p.achievements=[]; p.bonusCount=0; p.branchSuccessCount=0; p.maxMoneyReached=p.money; p.highestSingleGain=0; p.turnsToGoal=null; }); pushLog("実績をリセットしました"); updateAchievementsModal(); });

    // Branch modal logic (integrated)
    function showBranchModal(branchEv, playerIndex){
      genericTitle.textContent = "分岐イベント"; genericText.textContent = branchEv.text; genericSub.textContent = `あなた: ${state.players[playerIndex].name}`; genericActions.innerHTML="";
      branchEv.choices.forEach(choice=>{
        const b = document.createElement("button"); b.textContent = choice.label;
        b.addEventListener("click", async ()=>{
          const prob = (typeof choice.probGood === "number") ? choice.probGood : 1.0;
          const success = state.rng() < prob;
          const pl = state.players[playerIndex];
          const res = success ? (choice.success||{}) : (choice.failure||{});
          // update money & KPI
          if(typeof res.money === "number" && res.money !== 0){
            const delta = res.money;
            pl.money += delta;
            KPIs.budgetRemaining -= Math.max(0, Math.abs(delta));
            KPIs.impact += delta;
            if(delta > (pl.highestSingleGain || 0)) pl.highestSingleGain = delta;
            if(pl.money > (pl.maxMoneyReached || 0)) pl.maxMoneyReached = pl.money;
            flashMoney(playerIndex, delta);
          }
          if(success) pl.branchSuccessCount = (pl.branchSuccessCount||0) + 1;
          // adjust client satisfaction and progress heuristically
          if(success){ KPIs.clientSatisfaction = Math.min(100, KPIs.clientSatisfaction + 5); KPIs.progress = Math.min(100, KPIs.progress + 3); }
          else { KPIs.clientSatisfaction = Math.max(0, KPIs.clientSatisfaction - 4); KPIs.progress = Math.max(0, KPIs.progress - 1); }
          updateKPIDisplay();
          pushLog(`${pl.name}: ${(res.text || (success?"成功":"失敗"))} ${res.money?yen(res.money):""}`, success?"ok":"bad");
          if(typeof res.move === "number" && res.move !== 0){
            if(res.move > 0) await animateMove(playerIndex, res.move);
            else { pl.position = Math.max(0, pl.position + res.move); placeAllTokens(); resolveCell(playerIndex, pl.position); }
          } else {
            renderPlayersPanel();
          }
          evaluatePlayerAchievements(playerIndex);
          genericModal.close();
        });
        genericActions.appendChild(b);
      });
      const cancel = document.createElement("button"); cancel.textContent = "やめる"; cancel.addEventListener("click", ()=> genericModal.close());
      genericActions.appendChild(cancel);
      genericModal.showModal();
    }

    // resolveCell with KPI updates
    function resolveCell(playerIndex, index){
      const pl = state.players[playerIndex]; const cell = cells[index]; if(!cell||!pl) return;
      switch(cell.type){
        case "start": pushLog(`${pl.name}: スタート！`, "ok"); break;
        case "goal":
          if(!pl.finished){
            pl.finished = true; state.finishedCount += 1; $("#"+tokenId(playerIndex))?.classList.add("finished");
            pl.turnsToGoal = state.turn;
            pushLog(`${pl.name}: ゴール！`); showCard("ゴール", `${pl.name} がゴール！`, `残高: ${yen(pl.money)}`);
            evaluatePlayerAchievements(playerIndex);
          }
          break;
        case "bonus":{
          const amount = randPick(state.rng, [5000,8000,10000,15000,20000]); pl.money += amount; KPIs.budgetRemaining -= amount; KPIs.impact += amount;
          pl.bonusCount = (pl.bonusCount||0)+1;
          if(amount > (pl.highestSingleGain||0)) pl.highestSingleGain = amount;
          if(pl.money > (pl.maxMoneyReached||0)) pl.maxMoneyReached = pl.money;
          kpiProgressInc(5);
          KPIs.clientSatisfaction = Math.min(100, KPIs.clientSatisfaction + 2);
          flashMoney(playerIndex, amount);
          pushLog(`${pl.name}: ボーナス ${yen(amount)} 獲得（残高: ${yen(pl.money)}）`, "ok");
          evaluatePlayerAchievements(playerIndex);
          break;
        }
        case "penalty":{
          const amount = randPick(state.rng, [5000,8000,10000,15000,20000]); pl.money -= amount; KPIs.budgetRemaining -= amount; KPIs.impact -= amount;
          KPIs.clientSatisfaction = Math.max(0, KPIs.clientSatisfaction - 3);
          kpiProgressInc(-1);
          flashMoney(playerIndex, -amount);
          pushLog(`${pl.name}: ペナルティ ${yen(amount)}（残高: ${yen(pl.money)}）`, "bad");
          break;
        }
        case "event":{
          if(state.rng() < BRANCH_CHANCE){
            const pb = personaBranchMap[pl.name];
            if(pb && pb.length>0){ const be = randPick(state.rng, pb); showBranchModal(be, playerIndex); return; }
            const defaultBranch = { text: "分岐イベント（サンプル）", choices: [
              { label:"挑戦する", probGood:0.6, success:{money:20000,move:1,text:"成功！"}, failure:{money:-10000,move:0,text:"失敗…"} },
              { label:"やめる", probGood:1.0, success:{money:0,move:0,text:"何も起きない"}, failure:{money:0,move:0,text:""} }
            ]};
            showBranchModal(defaultBranch, playerIndex); return;
          }
          const personaEvents = personaEventMap[pl.name];
          if(personaEvents && personaEvents.length>0 && state.rng() < 0.7){
            const ev = randPick(state.rng, personaEvents);
            pl.money += ev.money; KPIs.budgetRemaining -= ev.money; KPIs.impact += ev.money;
            if(ev.money > (pl.highestSingleGain||0)) pl.highestSingleGain = ev.money;
            if(pl.money > (pl.maxMoneyReached||0)) pl.maxMoneyReached = pl.money;
            if(state.rng() < 0.10){ pl.skipTurn = true; pushLog(`${pl.name}: 次はスキップ`); }
            kpiProgressInc(2);
            KPIs.clientSatisfaction = Math.min(100, KPIs.clientSatisfaction + (ev.money>0?2:-2));
            flashMoney(playerIndex, ev.money);
            pushLog(`${pl.name}: ${ev.text}（残高: ${yen(pl.money)}）`, ev.money>=0?"ok":"bad");
            evaluatePlayerAchievements(playerIndex);
            renderPlayersPanel();
            showCard("イベント", ev.text, `${pl.name} / 残高: ${yen(pl.money)}`);
            return;
          }
          const ev = randPick(state.rng, eventTable);
          pl.money += ev.money; KPIs.budgetRemaining -= ev.money; KPIs.impact += ev.money;
          if(ev.money > (pl.highestSingleGain||0)) pl.highestSingleGain = ev.money;
          if(pl.money > (pl.maxMoneyReached||0)) pl.maxMoneyReached = pl.money;
          if(state.rng() < 0.10){ pl.skipTurn = true; pushLog(`${pl.name}: 次はスキップ`); }
          kpiProgressInc(1);
          KPIs.clientSatisfaction = Math.min(100, KPIs.clientSatisfaction + (ev.money>0?1:-1));
          flashMoney(playerIndex, ev.money);
          pushLog(`${pl.name}: ${ev.text}（残高: ${yen(pl.money)}）`, ev.money>=0?"ok":"bad");
          showCard("イベント", ev.text, `${pl.name} / 残高: ${yen(pl.money)}`);
          evaluatePlayerAchievements(playerIndex);
          break;
        }
      }
      renderPlayersPanel();
    }
    function kpiProgressInc(n){ KPIs.progress = Math.max(0, Math.min(100, KPIs.progress + n)); updateKPIDisplay(); }

    // Dice & move
    function rollDice(){ const n = Math.floor(state.rng()*6)+1; diceEl.textContent = n; diceEl.classList.add("spin"); setTimeout(()=>diceEl.classList.remove("spin"), 620); return n; }
    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      const delay = Number(speedInput.value || state.speed);
      let pos = pl.position; let remain = steps;
      while(remain>0){
        let next = pos + 1;
        if(next >= TOTAL_CELLS-1){
          if(state.overshoot === "clamp"){ next = TOTAL_CELLS-1; pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
          else {
            const extra = remain - 1 - ((TOTAL_CELLS-1) - pos - 1);
            pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay);
            for(let b=0; b<extra; b++){ pos -= 1; pl.position = pos; placeAllTokens(); await sleep(delay); }
            remain = 0; break;
          }
        }
        pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); remain--;
      }
      resolveCell(playerIndex, pl.position);
      state.animating = false; updateRollState();
    }
    function nextPlayerTurn(){ const total = state.players.length; let i = state.currentPlayerIndex; for(let c=0;c<total;c++){ i=(i+1)%total; const p=state.players[i]; if(!p.finished){ state.currentPlayerIndex=i; break; } } highlightActiveToken(); renderPlayersPanel(); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name; }
    const isGameFinished = ()=> state.finishedCount === state.players.length;

    // Save/Load (slots) snapshot - include scenario & KPIs
    const SAVE_KEY = "life-game-save-v12";
    function snapshot(){ return JSON.stringify({
      started:state.started, turn:state.turn, currentPlayerIndex:state.currentPlayerIndex, finishedCount:state.finishedCount,
      players:state.players, seed:state.seed, overshoot:state.overshoot, speed:Number(speedInput.value||state.speed),
      playerSettings: state.playerSettings, personas: personasStore,
      scenarioId: currentScenario?.id || null, KPIs
    }); }
    function restore(json){ try{ const d = JSON.parse(json); state.started = d.started; state.turn = d.turn; state.currentPlayerIndex = d.currentPlayerIndex; state.finishedCount = d.finishedCount; state.players = d.players || []; state.seed = d.seed||""; state.overshoot = d.overshoot||"clamp"; state.rng = createRNG(state.seed||""); speedInput.value = String(d.speed||180); overshootSel.value = state.overshoot; rngSeedInput.value = state.seed; state.playerSettings = d.playerSettings || []; if(Array.isArray(d.personas)) { personasStore = d.personas; initPersonas(); } if(d.scenarioId) loadScenarioToState(d.scenarioId); if(d.KPIs) { KPIs = d.KPIs; updateKPIDisplay(); } renderBoard(); renderPlayersPanel(); statTurnEl.textContent = String(state.turn); statCurrentEl.textContent = state.players[state.currentPlayerIndex]?.name || "-"; pushLog("保存データを読み込みました。", "ok"); }catch(e){ alert("読み込みに失敗しました"); } }
    $("#btn-save").addEventListener("click", ()=>{ localStorage.setItem(SAVE_KEY, snapshot()); pushLog("保存しました", "ok"); });
    $("#btn-load").addEventListener("click", ()=>{ const s=localStorage.getItem(SAVE_KEY); if(!s) return alert("保存がありません"); restore(s); });
    $("#btn-export").addEventListener("click", ()=>{ const blob = new Blob([snapshot()], {type:"application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href=url; a.download="life-game-save.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
    // slot buttons (simple)
    $("#btn-save-slot").addEventListener("click", ()=> { const slot = $("#save-slot").value; try { localStorage.setItem("life-game-slot-"+slot, snapshot()); pushLog(`スロット ${slot} に保存しました`); } catch(e){ alert("保存に失敗しました"); }});
    $("#btn-load-slot").addEventListener("click", ()=> { const slot = $("#save-slot").value; const s = localStorage.getItem("life-game-slot-"+slot); if(!s) return alert("スロットに保存がありません"); restore(s); });
    $("#btn-delete-slot").addEventListener("click", ()=> { const slot = $("#save-slot").value; if(!confirm(`スロット ${slot} を削除しますか？`)) return; localStorage.removeItem("life-game-slot-"+slot); pushLog(`スロット ${slot} を削除しました`); });

    // Persona import
    btnImportPersonas.addEventListener("click", ()=> filePersonas.click());
    filePersonas.addEventListener("change", async e=>{ const f=e.target.files?.[0]; if(!f) return; try{ const txt = await f.text(); const json = JSON.parse(txt); if(!json || !Array.isArray(json.personas)) throw new Error("形式不正"); personasStore = json.personas; initPersonas(); localStorage.setItem("imported-personas", JSON.stringify({ personas: personasStore })); pushLog("ペルソナを読み込みました", "ok"); }catch(err){ alert("読み込みに失敗しました"); } finally { filePersonas.value=""; } });

    // Settings modal (simplified)
    function buildSettingsForm(){ const count = parseInt($("#players-count").value,10) || 4; ensurePlayerSettings(count); settingsListEl.innerHTML=""; for(let i=0;i<count;i++){ const s = state.playerSettings[i] || { persona: PERSONAS[i] || `プレイヤー${i+1}`, color:PLAYER_COLORS[i % PLAYER_COLORS.length] }; const row = document.createElement("div"); row.className = "settings-row"; const idx = document.createElement("div"); idx.textContent = `${i+1}`; idx.style.width="24px"; idx.style.textAlign="center"; idx.style.fontWeight="700"; const personaSelect = document.createElement("select"); PERSONAS.forEach(p=>{ const opt = document.createElement("option"); opt.value=p; opt.textContent=p; personaSelect.appendChild(opt); }); personaSelect.value = s.persona; const colorInput = document.createElement("input"); colorInput.type="color"; colorInput.value = s.color; row.appendChild(idx); row.appendChild(personaSelect); row.appendChild(colorInput); settingsListEl.appendChild(row); } }
    settingsBtn.addEventListener("click", ()=>{ buildSettingsForm(); settingsModal.showModal(); });
    settingsSaveBtn.addEventListener("click", ()=>{ const rows = settingsListEl.querySelectorAll(".settings-row"); rows.forEach((row, idx)=>{ const personaSelect = row.querySelector('select'); const colorInput = row.querySelector('input[type="color"]'); state.playerSettings[idx] = { persona: personaSelect.value, color: colorInput.value }; }); settingsModal.close(); pushLog("プレイヤー設定を保存しました", "ok"); });

    // Start / Reset / Roll wiring with scenario integration
    btnStart.addEventListener("click", ()=>{
      if(state.started) return;
      const count = parseInt($("#players-count").value,10); const initial = parseInt($("#initial-money").value,10)||0;
      const seed = ($("#rng-seed").value||"").trim(); state.seed = seed; state.rng = createRNG(seed);
      ensurePlayerSettings(count);
      // load selected scenario
      if(!currentScenario) loadScenarioToState(scenarioSelect.value || (scenarios[0] && scenarios[0].id));
      state.players = Array.from({length:count},(_,i)=>{
        const s = state.playerSettings[i] || { persona: PERSONAS[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length] };
        return { name: s.persona, color: s.color, position:0, money:initial, finished:false, skipTurn:false, achievements:[], bonusCount:0, branchSuccessCount:0, maxMoneyReached:initial, highestSingleGain:0, turnsToGoal:null };
      });
      state.started=true; state.turn=1; state.currentPlayerIndex=0; state.finishedCount=0; state.overshoot = $("#overshoot").value; state.speed = Number($("#speed").value||180);
      // KPIs are already set by loadScenarioToState
      pushLog(`ゲーム開始！ケース: ${currentScenario.title} | 初期資金: ${yen(initial)} | プレイヤー数: ${count}`, "ok");
      renderBoard(); renderPlayersPanel(); statTurnEl.textContent=String(state.turn); statCurrentEl.textContent=state.players[state.currentPlayerIndex].name; btnRoll.disabled=false; diceEl.textContent='-';
    });

    btnReset.addEventListener("click", ()=>{ Object.assign(state, {started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false}); btnRoll.disabled=true; logEl.innerHTML=""; statTurnEl.textContent="0"; statCurrentEl.textContent="-"; diceEl.textContent='-'; renderBoard(); playersPanelEl.innerHTML=""; pushLog("リセットしました"); });

    btnRoll.addEventListener("click", async ()=>{
      if(!state.started || state.animating) return;
      const pl = state.players[state.currentPlayerIndex]; if(!pl || pl.finished){ nextPlayerTurn(); return; }
      if(pl.skipTurn){ pushLog(`${pl.name}: ターンをスキップします`); pl.skipTurn=false; state.turn+=1; statTurnEl.textContent=String(state.turn); nextPlayerTurn(); return; }
      const dice = rollDice(); pushLog(`${pl.name}: サイコロ → ${dice}`);
      const remaining = (TOTAL_CELLS-1) - pl.position; const steps = state.overshoot==="clamp"? Math.min(dice, remaining): dice;
      await animateMove(state.currentPlayerIndex, steps);
      // update scenario deadline check
      if(currentScenario && state.turn >= currentScenario.deadlineTurns){
        // if deadline exceeded, degrade satisfaction
        KPIs.clientSatisfaction = Math.max(0, KPIs.clientSatisfaction - 10);
        updateKPIDisplay();
        pushLog("期限が近づいています。クライアント満足度が低下しました。", "bad");
      }
      state.turn += 1; statTurnEl.textContent = String(state.turn);
      if(isGameFinished()){ pushLog("全員ゴール！ゲーム終了！"); btnRoll.disabled=true; setTimeout(()=> { evaluateEndAchievements(); openResult(); }, 200); return; }
      nextPlayerTurn(); btnRoll.disabled=false;
    });

    function openResult(){ evaluateEndAchievements(); const rows = state.players.map((p,i)=>({i, name:p.name, money:p.money})).sort((a,b)=> b.money-a.money); let html = `<table><thead><tr><th>順位</th><th>プレイヤー</th><th>所持金</th><th>差額</th></tr></thead><tbody>`; const top = rows[0]?.money ?? 0; rows.forEach((r,idx)=>{ const diff = r.money - top; html += `<tr><td>${idx+1}</td><td>${r.name}</td><td>${yen(r.money)}</td><td>${diff===0?"-":yen(diff)}</td></tr>`; }); html += `</tbody></table>`; resultBody.innerHTML = html; resultDlg.showModal(); }

    resultClose.addEventListener("click", ()=> resultDlg.close());

    // keyboard shortcuts (dialog-aware)
    window.addEventListener("keydown", e=>{
      const openDialog = document.querySelector('dialog.modal[open]');
      if(openDialog && !(openDialog.id === "shortcuts-modal" && (e.key.toLowerCase()==='h'))) {
        if(e.key.toLowerCase() === 'h'){ e.preventDefault(); if(shortcutsModal.open) shortcutsModal.close(); else shortcutsModal.showModal(); }
        return;
      }
      if(e.code==="Space" || e.key==="Enter"){ e.preventDefault(); btnRoll.click(); }
      if(e.key.toLowerCase()==='r' && !state.animating){ btnReset.click(); }
      if(e.key.toLowerCase()==='s'){ e.preventDefault(); $("#btn-save-slot").click(); }
      if(e.key.toLowerCase()==='l'){ e.preventDefault(); $("#btn-load-slot").click(); }
      if(e.key.toLowerCase()==='h'){ e.preventDefault(); shortcutsModal.showModal(); }
      if(e.key.toLowerCase()==='z'){ if(e.shiftKey) { /* zoom out */ setCellSize(Math.max(44,getCellSize()-8)); } else { setCellSize(getCellSize()+8); } }
      if(e.key.toLowerCase()==='f'){ fitBoard(); }
    });

    // Zoom helpers
    function getCellSize(){ const v = getComputedStyle(document.documentElement).getPropertyValue('--cell-size')||'72px'; return parseInt(v); }
    function setCellSize(px){ document.documentElement.style.setProperty('--cell-size', px+'px'); document.documentElement.style.setProperty('--board-max-width', `calc(${px}px * var(--board-cols) + 32px)`); placeAllTokens(); }
    function zoomIn(){ setCellSize(getCellSize()+parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zoom-step'))); }
    function zoomOut(){ setCellSize(Math.max(44, getCellSize()-parseInt(getComputedStyle(document.documentElement).getPropertyValue('--zoom-step')))); }
    function fitBoard(){ const toolbarRect = document.querySelector('.appbar').getBoundingClientRect(); const viewportH = window.innerHeight; const availableH = viewportH - toolbarRect.height - 48; const maxCellH = Math.floor((availableH - 16) / BOARD_ROWS); const current = getCellSize(); const newSize = Math.max(44, Math.min(current, maxCellH)); setCellSize(newSize); }

    $("#btn-zoom-in").addEventListener("click", zoomIn);
    $("#btn-zoom-out").addEventListener("click", zoomOut);
    $("#btn-fit").addEventListener("click", fitBoard);

    // ensure roll-button state sync when dialogs close
    function updateRollState(){ btnRoll.disabled = !state.started || state.animating; }
    document.querySelectorAll('dialog.modal').forEach(d => { d.addEventListener('close', updateRollState); d.addEventListener('cancel', updateRollState); });

    // initial render & scenario load
    rebuildScenarioSelect();
    if(scenarios.length>0) loadScenarioToState(scenarios[0].id);
    ensurePlayerSettings(parseInt(playersCountSel.value,10) || 4);
    renderBoard();
    setTimeout(()=> { fitBoard(); }, 80);
    window.addEventListener("resize", ()=> placeAllTokens());

    // Expose debug
    window._life = { state, scenarios, loadScenarioToState, KPIs, updateKPIDisplay };

    // End IIFE
  })();
  </script>
</body>
</html>
