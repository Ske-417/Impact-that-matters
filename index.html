<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      /* Allowed palette:
         - #000000 (black)
         - #FFFFFF (white)
         - #86BB27 (green)
         - #C4C4C4 (gray)
         - #DFF3C6 (lightened 86BB27)
      */
      --black: #000000;
      --white: #FFFFFF;
      --green: #86BB27;
      --green-light: #DFF3C6;
      --gray: #C4C4C4;

      --board-cols:10; --board-rows:6; --cell-size:68px;
      --board-max-width: calc(var(--cell-size) * var(--board-cols) + 32px);
      --btn-radius: 12px;
      --card-radius: 14px;
      --card-shadow: 0 12px 30px rgba(0,0,0,0.08);
      --btn-shadow: 0 6px 14px rgba(0,0,0,0.06);
    }

    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; align-items:stretch;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); min-height:100vh;
      font-weight:700; /* all text bold as requested */
    }

    /* App Bar */
    .appbar{
      position:sticky; top:0; z-index:1100; width:100%;
      display:flex; justify-content:center; background:var(--white);
      border-bottom:1px solid rgba(0,0,0,0.06); box-shadow: 0 4px 18px rgba(0,0,0,0.03);
    }
    .toolbar{width:100%; padding:6px 10px; display:flex; flex-wrap:wrap; align-items:center; gap:10px}
    .title{font-weight:900; font-size:15px; color:var(--black); white-space:nowrap; margin-right:auto}
    .group{display:flex; align-items:center; gap:8px; padding:8px 10px; background:var(--white); border:1px solid var(--gray); border-radius:14px}
    label{font-size:12px; color:var(--black)}
    select,input[type="text"]{padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white); color:var(--black)}
    button{padding:8px 12px; border-radius:var(--btn-radius); border:1px solid var(--gray); background:var(--white); cursor:pointer; color:var(--black); box-shadow:none; font-weight:900}
    button.primary{background:var(--green); color:var(--white); border-color:transparent; box-shadow:var(--btn-shadow)}
    button:disabled{opacity:.45; cursor:not-allowed}
    button:hover:not(:disabled){ transform:translateY(-2px); box-shadow:0 8px 18px rgba(0,0,0,0.07) }

    .player-names { display:flex; gap:8px; align-items:center; }
    .player-names input { width:140px; padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white); color:var(--black); font-weight:900; transition: box-shadow .12s, border-color .12s }
    .player-names input:focus{outline:none; border-color:var(--green); box-shadow:0 0 0 6px rgba(134,187,39,0.08);}

    /* Layout */
    .wrap{width:100%; padding:16px; display:grid; grid-template-columns:3fr 1.1fr; gap:12px; flex:1; align-items:start}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* Board */
    .board-wrap{display:flex; justify-content:center; align-items:flex-start; overflow:auto; width:100%; padding-bottom:8px; -webkit-overflow-scrolling:touch; z-index:1}
    .board{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:12px; position:relative; display:grid; gap:8px; grid-template-columns:repeat(var(--board-cols), var(--cell-size)); grid-auto-rows: var(--cell-size); justify-content:center; align-content:start; min-width:var(--board-max-width)}
    .cell{background:var(--white); border:1px solid var(--gray); border-radius:12px; padding:8px; display:grid; place-items:center; font-size:12px; position:relative; color:var(--black); font-weight:900}
    .cell.start{background:var(--green-light); border-color:var(--green)}
    .cell.goal{background:var(--green); border-color:var(--green)}
    .cell.event, .cell.bonus, .cell.workshop, .cell.client { background:var(--green-light); border-color:var(--green); color:var(--black) }
    .cell.penalty{background:#FBFBFB; border-color:var(--gray)}
    .cell .idx{position:absolute; top:6px; left:8px; font-size:10px; color:var(--black)}

    /* Tokens */
    .token{width:30px; height:30px; border-radius:50%; border:2px solid var(--black); display:grid; place-items:center; color:var(--white); font-size:12px; font-weight:900; box-shadow:0 8px 20px rgba(0,0,0,0.06)}
    .token.finished{opacity:.9; border-color:var(--gray)}
    .token.active{outline:3px solid rgba(0,0,0,0.08)}

    /* Sidebar */
    .sidebar{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:14px; display:grid; gap:12px; height:fit-content; z-index:2}
    .stat{display:flex; justify-content:space-between; gap:8px; padding:10px 12px; background:var(--white); border-radius:12px}
    .players{display:grid; gap:10px; min-height:72px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:10px; align-items:center; padding:10px 12px; background:var(--white); border:1px solid var(--gray); border-radius:12px}
    .player-row.active{border-color:rgba(0,0,0,0.12); box-shadow:0 0 0 2px rgba(134,187,39,0.06) inset}
    .badge{width:20px; height:20px; border-radius:50%; border:2px solid var(--black); display:inline-block; margin-right:8px}
    .left-col{display:flex; align-items:center; gap:10px}
    .name-wrap{display:flex; flex-direction:column}
    .player-name{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; font-weight:900}
    .rank{font-weight:900; color:var(--black)}
    .salary{font-weight:900; color:var(--black); font-size:13px}
    .attr-list{display:flex; gap:8px; justify-content:flex-end; align-items:center}
    .attr{font-size:12px; background:var(--white); padding:6px 10px; border-radius:10px; border:1px solid var(--gray); min-width:86px; text-align:center; color:var(--black); font-weight:900}

    .log{border:1px solid var(--gray); border-radius:12px; background:var(--white); padding:12px; max-height:320px; overflow:auto; font-size:13px; line-height:1.4}
    .log p{margin:0 0 8px}
    .log p.ok{color:var(--green)}
    .log p.bad{color:var(--black)}

    /* modal card */
    .card{padding:16px; border-radius:var(--card-radius); background:var(--white); box-shadow:var(--card-shadow); border:1px solid var(--gray)}
    .card h3{margin:0 0 8px; color:var(--black); font-weight:900}
    .card p{margin:0 0 8px; font-weight:900}
    .card .muted{color:var(--black); opacity:0.7; font-size:13px; font-weight:900}
    .card .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:12px}

    /* fallback overlay for environments without dialog support */
    .modal-fallback { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:1600 }
    .modal-fallback .card { max-width:520px; width:calc(100% - 40px) }

    dialog button{pointer-events:auto}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title" id="app-title"><span style="color:var(--green); font-weight:900">M</span>ake an impact that matters</div>

      <div class="group"><label for="players-count">人数</label>
        <select id="players-count"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>

      <div class="group player-names" id="player-names"></div>

      <div class="group" style="gap:8px;">
        <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>
        <button id="btn-start" class="primary" type="button">開始</button>
        <button id="btn-roll" disabled type="button">サイコロ</button>
        <button id="btn-reset" type="button">リセット</button>
      </div>

      <div class="group" style="margin-left:auto;">
        <button id="btn-settings" title="プレイヤー設定" type="button">設定</button>
        <button id="btn-zoom-in" title="ズームイン" type="button">ズーム＋</button>
        <button id="btn-zoom-out" title="ズームアウト" type="button">ズーム−</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <main class="board" id="board" aria-label="ボード"></main>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>

      <div class="players" id="players-panel"></div>

      <div class="log" id="log" aria-live="polite" aria-atomic="false"></div>

      <div class="card">
        <div style="display:flex; gap:8px; justify-content:space-between; align-items:center">
          <div style="font-weight:900">履歴</div>
          <div style="display:flex; gap:8px">
            <button id="btn-history" type="button">履歴を表示</button>
            <button id="history-clear" type="button">履歴クリア</button>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <div id="tooltip" role="tooltip" aria-hidden="true" style="display:none;"></div>

  <dialog class="modal" id="modal" aria-labelledby="modal-title">
    <div class="card">
      <h3 id="modal-title">イベント</h3>
      <div id="modal-text" style="white-space:normal;"></div>
      <div class="muted" id="modal-sub"></div>
      <div class="actions" id="modal-actions"></div>
    </div>
  </dialog>

  <dialog class="modal" id="result" aria-labelledby="result-title">
    <div class="card"><h3 id="result-title">結果発表</h3><div id="result-body"></div><div class="actions"><button id="result-close" class="primary" type="button">閉じる</button></div></div>
  </dialog>

  <script>
  (function(){
    const $ = s => document.querySelector(s);
    const boardEl = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const playersCountSel = $("#players-count");
    const playerNamesEl = $("#player-names");
    const btnZoomIn = $("#btn-zoom-in"), btnZoomOut = $("#btn-zoom-out");
    const btnHistory = $("#btn-history"), historyClear = $("#history-clear");
    const genericModal = $("#modal"), genericTitle = $("#modal-title"), genericText = $("#modal-text"), genericSub = $("#modal-sub"), genericActions = $("#modal-actions");
    const resultDlg = $("#result"), resultBody = $("#result-body");

    const BOARD_COLS = 10, BOARD_ROWS = 6, TOTAL_CELLS = BOARD_COLS * BOARD_ROWS;
    const PLAYER_COLORS = ["#86BB27","#DFF3C6","#C4C4C4","#000000","#86BB27"];
    const BRANCH_CHANCE = 0.36;

    // Persistent history buffer (keeps logs even after reset)
    const HISTORY_KEY = "itmatters_history_v1";
    let state = {
      started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false,
      rng: Math.random, speed:180, overshoot:"clamp",
      history: []
    };

    // load history
    try{
      const saved = localStorage.getItem(HISTORY_KEY);
      if(saved){ state.history = JSON.parse(saved); }
    }catch(e){ state.history = []; }

    function persistHistory(){ try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(state.history)); }catch(e){} }

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
    function randPick(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }
    function tokenId(i){ return `token-${i}` }
    function yen(n){ return "¥" + Number(n).toLocaleString("ja-JP"); }
    function timeNow(){ return (new Date()).toISOString(); }

    function appendLogToDom(item){
      if(!logEl) return;
      const p = document.createElement("p");
      p.textContent = `[${item.ts.slice(11,19)}] ${item.text}`;
      if(item.kind) p.classList.add(item.kind);
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function pushLog(text, kind){
      const item = { ts: timeNow(), text: String(text), kind: kind || "" };
      state.history.push(item);
      persistHistory();
      appendLogToDom(item);
    }

    function showHistory(){
      const overlay = document.createElement("div");
      overlay.className = "modal-fallback";
      const card = document.createElement("div"); card.className = "card";
      const h = document.createElement("h3"); h.textContent = "イベント履歴";
      const body = document.createElement("div"); body.style.maxHeight = "60vh"; body.style.overflow = "auto"; body.style.marginTop = "8px";
      if(state.history.length === 0){ body.textContent = "履歴がありません"; }
      else {
        state.history.slice().reverse().forEach(it=>{
          const d = document.createElement("div");
          d.style.padding = "6px 0";
          d.textContent = `[${it.ts.slice(0,19)}] ${it.text}`;
          if(it.kind) d.classList.add(it.kind);
          body.appendChild(d);
        });
      }
      const actions = document.createElement("div"); actions.className = "actions";
      const close = document.createElement("button"); close.className = "primary"; close.type = "button"; close.textContent = "閉じる";
      close.addEventListener("click", ()=> overlay.remove());
      actions.appendChild(close);
      card.appendChild(h); card.appendChild(body); card.appendChild(actions);
      overlay.appendChild(card);
      document.body.appendChild(overlay);
      close.focus();
    }

    if(historyClear) historyClear.addEventListener("click", ()=>{
      if(!confirm("履歴を完全にクリアしますか？")) return;
      state.history = [];
      persistHistory();
      if(logEl) logEl.innerHTML = "";
      pushLog("履歴をクリアしました", "ok");
    });
    if(btnHistory) btnHistory.addEventListener("click", showHistory);

    // player name inputs
    function renderPlayerNameInputs(){
      const count = Math.max(1, parseInt(playersCountSel.value || "2"));
      playerNamesEl.innerHTML = "";
      for(let i=0;i<count;i++){
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = `Player ${i+1} 名前`;
        input.id = `player-name-${i}`;
        input.value = `プレイヤー${i+1}`;
        playerNamesEl.appendChild(input);
      }
    }
    playersCountSel.addEventListener("change", renderPlayerNameInputs);
    renderPlayerNameInputs();

    function getPlayerNames(){
      const inputs = playerNamesEl.querySelectorAll("input");
      return Array.from(inputs).map((inp, i) => inp.value.trim() || `プレイヤー${i+1}`);
    }

    // board setup
    const cells = Array.from({length:TOTAL_CELLS},(_,i)=>({index:i,type:"none",label:""}));
    cells[0] = {index:0,type:"start",label:"スタート"};
    cells[TOTAL_CELLS-1] = {index:TOTAL_CELLS-1,type:"goal",label:"ゴール"};
    (function markCells(){
      for(let i=1;i<TOTAL_CELLS-1;i++){
        if(i % 11 === 0) { cells[i].type = "client"; cells[i].label = "クライアント"; }
        else if(i % 13 === 0) { cells[i].type = "workshop"; cells[i].label = "ワークショップ"; }
        else if(i % 6 === 0) { cells[i].type = "event"; cells[i].label = "案件/イベント"; }
        else if(i % 5 === 0) { cells[i].type = "bonus"; cells[i].label = "案件成功"; }
        else if(i % 7 === 0) { cells[i].type = "penalty"; cells[i].label = "コスト"; }
        else { cells[i].type = "none"; cells[i].label = ""; }
      }
    })();

    function indexToGrid(index){
      const row = Math.floor(index/BOARD_COLS);
      let col = index % BOARD_COLS;
      if(row % 2 === 1) col = BOARD_COLS-1-col;
      return {row, col};
    }

    function renderBoard(){
      if(!boardEl) return;
      boardEl.innerHTML = "";
      cells.forEach(cell=>{
        const div = document.createElement("div");
        div.className = "cell "+(cell.type!="none"?cell.type:"");
        div.dataset.index = String(cell.index);
        const idx = document.createElement("div"); idx.className = "idx"; idx.textContent = String(cell.index); div.appendChild(idx);
        const isEventish = ["event","bonus","workshop","client"].includes(cell.type);
        const label = document.createElement("div");
        label.textContent = isEventish ? "イベント" : (cell.label||"");
        div.appendChild(label);
        const {row,col} = indexToGrid(cell.index); div.style.gridRowStart = row+1; div.style.gridColumnStart = col+1;
        boardEl.appendChild(div);
      });
      // tokens
      state.players.forEach((pl,i)=>{
        const token=document.createElement("div"); token.className="token"; token.id=tokenId(i); token.textContent=String(i+1);
        token.style.background = PLAYER_COLORS[i % PLAYER_COLORS.length];
        token.style.color = (i === 1 || i === 2) ? 'var(--black)' : 'var(--white)';
        if(pl.finished) token.classList.add("finished");
        token.style.position = "absolute"; token.style.left = "0px"; token.style.top = "0px";
        boardEl.appendChild(token);
      });
      placeAllTokens(); highlightActiveToken();
    }

    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        if(!groups.has(pl.position)) groups.set(pl.position, []);
        groups.get(pl.position).push(i);
      });
      groups.forEach((idxs, pos)=>{
        const targetCell = boardEl.querySelector(`.cell[data-index="${pos}"]`);
        if(!targetCell) return;
        const rectBoard = boardEl.getBoundingClientRect();
        const rc = targetCell.getBoundingClientRect();
        const cx = rc.left - rectBoard.left + rc.width/2; const cy = rc.top - rectBoard.top + rc.height/2;
        const r = Math.min(rc.width, rc.height) / 3.2;
        const n = idxs.length; const baseAngle = -90;
        idxs.forEach((pi, k)=>{
          const angle = baseAngle + (n===1?0: (k-(n-1)/2) * 30);
          const rad = angle * Math.PI / 180;
          const x = cx + r * Math.cos(rad) - 14; const y = cy + r * Math.sin(rad) - 14;
          const t = $("#"+tokenId(pi)); if(t) t.style.transform = `translate(${x}px, ${y}px)`;
        });
      });
      state.players.forEach((pl,i)=>{
        const t = $("#"+tokenId(i)); if(!t) return;
        if(typeof pl.position !== "number") t.style.transform = "translate(-9999px,-9999px)";
      });
    }

    function highlightActiveToken(){
      state.players.forEach((_,i)=>{
        const t=$("#"+tokenId(i)); if(!t) return; if(i===state.currentPlayerIndex) t.classList.add("active"); else t.classList.remove("active");
      });
    }

    function renderPlayersPanel(){
      if(!playersPanelEl) return;
      playersPanelEl.innerHTML = "";
      if(!state.players || state.players.length === 0){
        const placeholder = document.createElement("div");
        placeholder.className = "card";
        placeholder.style.textAlign = "center";
        placeholder.textContent = "プレイヤーを設定して「開始」を押してください";
        playersPanelEl.appendChild(placeholder);
        return;
      }
      state.players.forEach((pl,i)=>{
        const row=document.createElement("div"); row.className="player-row"+(i===state.currentPlayerIndex?" active":"");
        const left = document.createElement("div"); left.className = "left-col";
        const badge=document.createElement("span"); badge.className="badge"; badge.style.background=pl.color; left.appendChild(badge);
        const nameWrap = document.createElement("div"); nameWrap.className = "name-wrap";
        const name = document.createElement("div"); name.className = "player-name"; name.textContent = pl.name;
        const { rank, estimatedSalary } = getRankAndSalary(pl);
        const rankEl = document.createElement("div"); rankEl.className = "rank"; rankEl.textContent = rank;
        const salEl = document.createElement("div"); salEl.className = "salary"; salEl.textContent = `${yen(estimatedSalary)}`;
        nameWrap.appendChild(name); nameWrap.appendChild(rankEl); nameWrap.appendChild(salEl);
        left.appendChild(nameWrap);
        const right = document.createElement("div"); right.className = "attr-list";
        const aLearning = document.createElement("div"); aLearning.className="attr"; aLearning.id=`learning-${i}`; aLearning.textContent = `学び: ${pl.learning}`;
        const aMental = document.createElement("div"); aMental.className="attr"; aMental.id=`mental-${i}`; aMental.textContent = `メンタル: ${pl.mental}`;
        const aRating = document.createElement("div"); aRating.className="attr"; aRating.id=`rating-${i}`; aRating.textContent = `評価: ${pl.rating}`;
        const aResp = document.createElement("div"); aResp.className="attr"; aResp.id=`responsibility-${i}`; aResp.textContent = `責任: ${pl.responsibility}`;
        right.appendChild(aLearning); right.appendChild(aMental); right.appendChild(aRating); right.appendChild(aResp);
        row.appendChild(left); row.appendChild(right);
        playersPanelEl.appendChild(row);
      });
    }

    // boilerplate helpers
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    // Robust modal helpers with fallback
    function showCard(title, text, sub, {timeout = 30000} = {}) {
      return new Promise(resolve => {
        if(!genericModal){ resolve(); return; }
        genericTitle.textContent = title || "";
        genericText.textContent = text || "";
        genericSub.textContent = sub || "";
        genericActions.innerHTML = "";
        const ok = document.createElement("button");
        ok.className = "primary"; ok.type = "button"; ok.textContent = "OK";
        let finished = false, timer = null;
        function cleanup(){
          if(timer){ clearTimeout(timer); timer = null; }
          try{ genericModal.removeEventListener("close", onClose); }catch(e){}
          try{ document.removeEventListener("keydown", onKey); }catch(e){}
        }
        function finish(val){
          if(finished) return; finished = true; cleanup();
          try{ if(genericModal.open) genericModal.close(); }catch(e){}
          const fb = document.querySelector(".modal-fallback"); if(fb) fb.remove();
          resolve(val);
        }
        function onOk(){ finish(); }
        function onClose(){ finish(); }
        function onKey(e){ if(e.key === "Escape") finish(); }

        ok.addEventListener("click", onOk);
        genericActions.appendChild(ok);

        try{
          genericModal.addEventListener("close", onClose);
          document.addEventListener("keydown", onKey);
          timer = setTimeout(()=> finish(), timeout);
          genericModal.showModal();
          ok.focus();
          return;
        }catch(err){
          cleanup();
        }

        // fallback overlay
        const overlay = document.createElement("div"); overlay.className = "modal-fallback";
        const card = document.createElement("div"); card.className = "card";
        card.innerHTML = `<h3>${escapeHtml(title||"")}</h3><div style="white-space:normal">${escapeHtml(text||"")}</div><div class="muted" style="margin-top:8px">${escapeHtml(sub||"")}</div>`;
        const actionsWrap = document.createElement("div"); actionsWrap.className = "actions";
        const ok2 = document.createElement("button"); ok2.className = "primary"; ok2.type = "button"; ok2.textContent = "OK";
        actionsWrap.appendChild(ok2); card.appendChild(actionsWrap); overlay.appendChild(card); document.body.appendChild(overlay);

        function fbOnOk(){ finish(); }
        function fbOnKey(e){ if(e.key === "Escape") finish(); }
        function fbOnClickOutside(e){ if(e.target === overlay) finish(); }

        ok2.addEventListener("click", fbOnOk);
        document.addEventListener("keydown", fbOnKey);
        overlay.addEventListener("click", fbOnClickOutside);

        timer = setTimeout(()=> finish(), timeout);
      });
    }

    function showBranchModal(branchEv, playerIndex, {timeout = 30000} = {}) {
      return new Promise(resolve => {
        if(!genericModal){ resolve(null); return; }
        genericTitle.textContent = "案件分岐 (提案)";
        genericText.textContent = branchEv.text || "";
        genericSub.textContent = `あなた: ${state.players[playerIndex].name}`;
        genericActions.innerHTML = "";

        let resolved = false, timer = null;
        function cleanup(){
          if(timer){ clearTimeout(timer); timer = null; }
          try{ genericModal.removeEventListener("close", onClose); }catch(e){}
          try{ document.removeEventListener("keydown", onKey); }catch(e){}
        }
        function finish(val){
          if(resolved) return; resolved = true; cleanup();
          try{ if(genericModal.open) genericModal.close(); }catch(e){}
          const fb = document.querySelector(".modal-fallback"); if(fb) fb.remove();
          resolve(val);
        }
        function onClose(){ finish(null); }
        function onKey(e){ if(e.key === "Escape") finish(null); }

        const buttons = [];
        branchEv.choices.forEach(choice=>{
          const b = document.createElement("button"); b.type = "button"; b.textContent = choice.label;
          b.addEventListener("click", ()=>{
            buttons.forEach(btn => btn.disabled = true);
            const baseProb = (typeof choice.probGood === "number") ? choice.probGood : 1.0;
            const pl = state.players[playerIndex];
            const repBonus = Math.max(-0.3, Math.min(0.3, (pl.rating || 0) / 200));
            const prob = Math.max(0.05, Math.min(0.95, baseProb + repBonus));
            const success = state.rng() < prob;
            const res = success ? (choice.success||{}) : (choice.failure||{});
            ["learning","mental","rating","responsibility"].forEach(k=>{
              if(typeof res[k] === "number") pl[k] = Math.max(0, Math.round((pl[k]||0) + res[k]));
            });
            ["learning","mental","rating","responsibility"].forEach(k=> flashAttr(playerIndex, k));
            pushLog(`${pl.name}: ${success ? (res.text || choice.label + " → 成功") : (res.text || choice.label + " → 失敗")}`, success ? "ok" : "bad");
            finish({choice, res, success});
          });
          genericActions.appendChild(b);
          buttons.push(b);
        });
        const cancel = document.createElement("button"); cancel.type = "button"; cancel.textContent = "やめる";
        cancel.addEventListener("click", ()=> finish(null));
        genericActions.appendChild(cancel);
        buttons.push(cancel);

        try{
          genericModal.addEventListener("close", onClose);
          document.addEventListener("keydown", onKey);
          timer = setTimeout(()=> finish(null), timeout);
          genericModal.showModal();
          return;
        }catch(e){
          cleanup();
        }

        // fallback overlay with choices
        const overlay = document.createElement("div"); overlay.className = "modal-fallback";
        const card = document.createElement("div"); card.className = "card";
        const h = document.createElement("h3"); h.textContent = "案件分岐 (提案)";
        const body = document.createElement("div"); body.style.whiteSpace = "normal"; body.textContent = branchEv.text || "";
        const muted = document.createElement("div"); muted.className = "muted"; muted.style.marginTop = "8px"; muted.textContent = `あなた: ${state.players[playerIndex].name}`;
        const actionsWrap = document.createElement("div"); actionsWrap.className = "actions";
        const fbButtons = [];
        branchEv.choices.forEach(choice=>{
          const b = document.createElement("button"); b.type = "button"; b.textContent = choice.label;
          b.addEventListener("click", ()=>{
            fbButtons.forEach(btn=>btn.disabled = true);
            const baseProb = (typeof choice.probGood === "number") ? choice.probGood : 1.0;
            const pl = state.players[playerIndex];
            const repBonus = Math.max(-0.3, Math.min(0.3, (pl.rating || 0) / 200));
            const prob = Math.max(0.05, Math.min(0.95, baseProb + repBonus));
            const success = state.rng() < prob;
            const res = success ? (choice.success||{}) : (choice.failure||{});
            ["learning","mental","rating","responsibility"].forEach(k=>{
              if(typeof res[k] === "number") pl[k] = Math.max(0, Math.round((pl[k]||0) + res[k]));
            });
            ["learning","mental","rating","responsibility"].forEach(k=> flashAttr(playerIndex, k));
            pushLog(`${pl.name}: ${success ? (res.text || choice.label + " → 成功") : (res.text || choice.label + " → 失敗")}`, success ? "ok" : "bad");
            finish({choice, res, success});
          });
          actionsWrap.appendChild(b);
          fbButtons.push(b);
        });
        const fbCancel = document.createElement("button"); fbCancel.type = "button"; fbCancel.textContent = "やめる"; fbCancel.addEventListener("click", ()=> finish(null));
        actionsWrap.appendChild(fbCancel); fbButtons.push(fbCancel);
        card.appendChild(h); card.appendChild(body); card.appendChild(muted); card.appendChild(actionsWrap); overlay.appendChild(card); document.body.appendChild(overlay);

        function fbOnKey(e){ if(e.key === "Escape") finish(null); }
        function fbOnClickOutside(e){ if(e.target === overlay) finish(null); }
        document.addEventListener("keydown", fbOnKey);
        overlay.addEventListener("click", fbOnClickOutside);
        timer = setTimeout(()=> finish(null), timeout);
      });
    }

    function flashAttr(playerIndex, attrName){
      try{
        const el = document.getElementById(`${attrName}-${playerIndex}`);
        if(!el) return;
        el.classList.add('flash-attr');
        setTimeout(()=> el.classList.remove('flash-attr'), 520);
      }catch(e){}
    }

    // resolveCell
    async function resolveCell(playerIndex, index){
      const pl = state.players[playerIndex]; const cell = cells[index]; if(!cell||!pl) return;
      switch(cell.type){
        case "start": pushLog(`${pl.name}: スタート`, "ok"); break;
        case "goal":
          if(!pl.finished){
            pl.finished = true; state.finishedCount += 1; $("#"+tokenId(playerIndex))?.classList.add("finished");
            pl.turnsToGoal = state.turn;
            pushLog(`${pl.name}: ゴール！`);
            const { rank, estimatedSalary } = getRankAndSalary(pl);
            await showCard("ゴール（プロジェクト完了）", `ランク: ${rank} / 推定年収: ${yen(estimatedSalary)}`, `${pl.name}`);
            if(isGameFinished()) showResult();
          }
          break;
        case "bonus":{
          const ev = eventTable[2];
          ["learning","mental","rating","responsibility"].forEach(k=>{ if(typeof ev[k] === "number"){ pl[k] = Math.max(0, Math.round((pl[k]||0)+ev[k])); flashAttr(playerIndex,k); }});
          pushLog(`${pl.name}: ボーナスイベント（属性上昇）`, "ok");
          break;
        }
        case "penalty":{
          const ev = eventTable[1];
          ["learning","mental","rating","responsibility"].forEach(k=>{ if(typeof ev[k] === "number"){ pl[k] = Math.max(0, Math.round((pl[k]||0)+ev[k])); flashAttr(playerIndex,k); }});
          pushLog(`${pl.name}: コスト（属性変動）`, "bad");
          break;
        }
        case "client":{
          const base = 0.55;
          const repBonus = ((pl.rating||50)-50)/200;
          const prob = Math.max(0.05, Math.min(0.95, base+repBonus));
          const success = state.rng() < prob;
          if(success){ pl.learning = Math.max(0, pl.learning+4); pl.mental = Math.max(0, pl.mental+2); pl.rating = Math.max(0, pl.rating+3); flashAttr(playerIndex,"learning"); flashAttr(playerIndex,"mental"); flashAttr(playerIndex,"rating"); pushLog(`${pl.name}: クライアント成功`, "ok"); }
          else { pl.mental = Math.max(0, pl.mental-3); pl.rating = Math.max(0, pl.rating-1); flashAttr(playerIndex,"mental"); flashAttr(playerIndex,"rating"); pushLog(`${pl.name}: クライアント不調`, "bad"); }
          await showCard("クライアント面談", `学び: ${pl.learning} / メンタル: ${pl.mental}`, `${pl.name}`);
          break;
        }
        case "workshop":{
          const gain = randPick(state.rng,[1,2,3,5]);
          pl.learning = Math.max(0, pl.learning+gain); pl.rating = Math.max(0, pl.rating+1); flashAttr(playerIndex,"learning"); flashAttr(playerIndex,"rating");
          pushLog(`${pl.name}: ワークショップで学び+${gain}`, "ok");
          await showCard("ワークショップ", `学び +${gain}`, `${pl.name}`);
          break;
        }
        case "event":{
          if(state.rng() < BRANCH_CHANCE){
            const defaultBranch = { text: "クライアントへの提案機会", choices:[
              { label:"攻めの提案", probGood:0.5, success:{learning:+3,mental:+1,rating:+4,responsibility:+2,move:1,text:"提案受注！"}, failure:{learning:+1,mental:-2,rating:-1,responsibility:0,move:0,text:"提案失敗"} },
              { label:"守りの提案", probGood:0.8, success:{learning:+1,mental:+1,rating:+1,responsibility:+0,move:0,text:"小さな案件獲得"}, failure:{learning:0,mental:0,rating:0,responsibility:0,move:0,text:"何もしない"} }
            ]};
            try{
              const res = await showBranchModal(defaultBranch, playerIndex);
              if(res && res.res && typeof res.res.move === "number" && res.res.move !== 0){
                if(res.res.move > 0) { await animateMove(playerIndex, res.res.move); }
                else { pl.position = Math.max(0, pl.position + res.res.move); placeAllTokens(); await resolveCell(playerIndex, pl.position); }
              } else { renderPlayersPanel(); }
            }catch(e){ console.error(e); renderPlayersPanel(); }
            return;
          }
          const ev2 = randPick(state.rng, eventTable);
          ["learning","mental","rating","responsibility"].forEach(k=>{ if(typeof ev2[k] === "number"){ pl[k] = Math.max(0, Math.round((pl[k]||0)+ev2[k])); flashAttr(playerIndex,k); }});
          pushLog(`${pl.name}: ${ev2.text}（属性変動）`, ev2.learning>=0?"ok":"bad");
          await showCard("案件イベント", ev2.text, `${pl.name}`);
          break;
        }
      }
      renderPlayersPanel();
    }

    const eventTable = [
      { text:"短期支援入り", learning:+6, mental:+2, rating:+3, responsibility:+1 },
      { text:"見積り漏れでトラブル", learning:+2, mental:-6, rating:-1, responsibility:0 },
      { text:"紹介で新規案件獲得", learning:+4, mental:+3, rating:+5, responsibility:+2 },
      { text:"資料誤記で修正対応", learning:+3, mental:-2, rating:-1, responsibility:+1 },
      { text:"アップセル成功", learning:+5, mental:+3, rating:+4, responsibility:+2 },
      { text:"請求遅延で対応", learning:+1, mental:-3, rating:0, responsibility:+1 },
      { text:"分析が評価される", learning:+7, mental:+1, rating:+4, responsibility:0 },
      { text:"外注コスト増で調整", learning:+1, mental:-4, rating:-1, responsibility:+1 },
      { text:"プロトタイプが好評", learning:+8, mental:+5, rating:+6, responsibility:+3 },
      { text:"内部調整で停滞", learning:0, mental:-1, rating:0, responsibility:0 }
    ];

    const RANKS = [
      { key: "アナリスト", min: -Infinity, max: 59.999, base: 5000000 },
      { key: "コンサルタント", min: 60, max: 84.999, base: 8500000 },
      { key: "シニアコンサルタント", min: 85, max: 109.999, base: 12000000 },
      { key: "マネージャー", min: 110, max: Infinity, base: 18000000 }
    ];
    function estimateScore(p){
      return ( (p.learning||0) * 0.35 + (p.rating||0) * 0.35 + (p.responsibility||0) * 0.2 + (p.mental||0) * 0.1 );
    }
    function getRankAndSalary(p){
      const score = estimateScore(p);
      const rank = RANKS.find(r => score >= r.min && score <= r.max) || RANKS[0];
      const modifier = 1 + Math.min(0.5, (p.responsibility||0) / 200) + Math.min(0.3, (p.rating||0) / 400);
      const estimated = Math.round(rank.base * modifier / 1000) * 1000;
      return { rank: rank.key, baseSalary: rank.base, estimatedSalary: estimated, score: Math.round(score) };
    }

    // movement and control
    function rollDice(){ const n = Math.floor(state.rng()*6)+1; if(diceEl) diceEl.textContent = n; return n; }
    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      try{
        const delay = Number(state.speed || 180);
        let pos = pl.position, dir = 1, remaining = steps;
        while(remaining > 0){
          let next = pos + dir;
          if(next >= TOTAL_CELLS){
            if(state.overshoot === "clamp"){ pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
            else { pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay); dir = -1; }
          } else if(next < 0){ pos = 0; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
          else { pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); }
          remaining--;
        }
        await resolveCell(playerIndex, pl.position);
      }catch(e){ console.error("animateMove error:", e); }
      finally{ state.animating = false; updateRollState(); }
    }

    function updateRollState(){
      try{
        if(!btnRoll) return;
        btnRoll.disabled = !(state.started && !state.animating);
        if(!btnRoll.disabled) btnRoll.removeAttribute('aria-disabled'); else btnRoll.setAttribute('aria-disabled','true');
      }catch(e){
        console.error("updateRollState error:", e);
        if(btnRoll) btnRoll.disabled = true;
      }
    }

    function startGame(){
      if(state.started) return;
      try{
        const count = Math.max(1, parseInt(playersCountSel?.value || "2"));
        const names = getPlayerNames();
        state.players = [];
        for(let i=0;i<count;i++){
          state.players.push({ name: names[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length], position:0, learning:50, mental:50, rating:50, responsibility:0, achievements:[], finished:false, skipTurn:false });
        }
        state.started = true; state.turn = 1; state.currentPlayerIndex = 0; state.finishedCount = 0; state.rng = Math.random;
        renderBoard(); renderPlayersPanel(); statTurnEl.textContent = String(state.turn); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
        pushLog("ゲームを開始しました","ok"); updateRollState();
        if(btnStart) btnStart.disabled = true;
      }catch(e){
        console.error("startGame error:", e);
        state.started = false; updateRollState(); if(btnStart) btnStart.disabled = false; pushLog("ゲーム開始に失敗しました（コンソール確認）","bad");
      }
    }

    async function rollTurn(){
      if(!state.started || state.animating) return;
      if(state.players.length === 0){ pushLog("プレイヤーが設定されていません"); return; }
      const current = state.currentPlayerIndex;
      const val = rollDice();
      await animateMove(current, val);
      const wasLast = (function(){ const active = state.players.map((p,i)=>({i,active:!p.finished})); const indices = active.filter(a=>a.active).map(a=>a.i); if(indices.length===0) return false; return current === indices[indices.length-1]; })();
      nextPlayerTurn();
      if(wasLast){ state.turn = (state.turn || 1) + 1; statTurnEl.textContent = String(state.turn); }
      updateRollState();
    }

    function resetGame(){
      state.started = false; state.turn = 0; state.currentPlayerIndex = 0; state.players = []; state.finishedCount = 0; state.animating = false; state.rng = Math.random;
      renderBoard(); renderPlayersPanel(); statTurnEl.textContent = "0"; statCurrentEl.textContent = "-";
      if(btnStart) btnStart.disabled = false;
      pushLog("ゲームをリセットしました","ok");
      updateRollState();
    }

    // event wiring
    if(btnStart) btnStart.addEventListener("click", ()=> startGame());
    if(btnRoll) btnRoll.addEventListener("click", ()=> { rollTurn().catch(e=>console.error(e)); });
    if(btnReset) btnReset.addEventListener("click", ()=> resetGame());
    if(btnZoomIn) btnZoomIn.addEventListener('click', ()=> { document.documentElement.style.fontSize = 'calc(100% + 8px)'; });
    if(btnZoomOut) btnZoomOut.addEventListener('click', ()=> { document.documentElement.style.fontSize = '100%'; });

    // init
    try{ state.history.forEach(it => appendLogToDom(it)); }catch(e){}
    renderBoard(); renderPlayersPanel(); updateRollState(); window.dispatchEvent(new CustomEvent('app-ready'));
  })();
  </script>
</body>
</html>
