<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000; --white:#FFFFFF; --green:#86BB27; --green-light:#DFF3C6; --gray:#C4C4C4;
      --cell-size:68px; /* tile size */
      --tile-size: var(--cell-size);
      --tile-gap: 16px; /* baseline gap */
      --board-padding: 24px;
      --token-size:30px;
      --token-move-ms:120ms; /* per-tile move duration */
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); font-weight:900;
    }

    /* Appbar */
    .appbar{position:sticky; top:0; z-index:1100; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); display:flex; justify-content:center}
    .toolbar{width:100%; max-width:1300px; display:flex; gap:10px; align-items:center; padding:8px}
    .title{font-weight:900; font-size:15px; margin-right:auto; color:var(--black)}
    .group{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--gray); border-radius:10px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:8px; border:1px solid var(--gray)}

    button{padding:8px 12px; border-radius:8px; border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent}
    #btn-roll, #btn-reset{ font-weight:900; }

    .wrap{width:100%; max-width:1300px; margin:18px auto; display:grid; grid-template-columns:3fr 1fr; gap:12px; align-items:start; padding:0 12px}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* Board */
    .board-wrap{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:var(--board-padding); position:relative; overflow:hidden; min-height:520px}
    .board{
      position:relative; width:100%; height:820px; touch-action:none; /* slightly taller */
    }

    /* tiles: normal tiles have thin grey border, eventish tiles green border */
    .tile{
      position:absolute;
      width:var(--tile-size);
      height:var(--tile-size);
      background:var(--white);
      border:1px solid var(--gray); /* normal */
      border-radius:6px;
      transform: translate(-50%,-50%);
      display:grid; place-items:center;
      font-weight:900; color:var(--black);
      box-shadow: 0 6px 18px rgba(0,0,0,0.03);
      transition: transform 120ms linear;
      z-index:2;
    }
    .tile.event,
    .tile.client,
    .tile.workshop,
    .tile.bonus,
    .tile.penalty {
      border:2px solid var(--green); /* unified green for event tiles */
      background: #fbfff6;
    }
    .tile.goal{ background: var(--green); color: #fff; border-color: var(--green) }

    /* START_MARKER: will be positioned dynamically to match tile 0 */
    .start-marker{
      position:absolute;
      width:calc(var(--tile-size) * 0.9);
      height:calc(var(--tile-size) * 0.28);
      display:grid; place-items:center;
      border-radius:6px; border:1px solid rgba(0,0,0,0.08);
      color:var(--black); font-weight:900; background:rgba(134,187,39,0.08);
      z-index:6;
      transform: translate(-50%,-125%); /* place slightly above the tile */
      pointer-events:none;
      font-size:12px;
    }

    .token{
      position:absolute;
      width:var(--token-size); height:var(--token-size); border-radius:50%; display:grid; place-items:center; color:#fff; font-weight:900;
      border:2px solid #000; transform: translate(-50%,-50%);
      box-shadow:0 8px 20px rgba(0,0,0,0.06);
      pointer-events:none;
      transition: transform var(--token-move-ms) linear;
      z-index:20;
    }
    .token.finished{ opacity:0.85; border-color:var(--gray) }

    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px}
    .stat{display:flex; justify-content:space-between; padding:10px; border-radius:10px}
    .players{margin-top:10px}
    .player-row{display:flex; justify-content:space-between; gap:8px; padding:8px; border-radius:10px; border:1px solid var(--gray); align-items:center}
    .log{margin-top:12px; border:1px solid var(--gray); border-radius:10px; padding:10px; max-height:300px; overflow:auto}

    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:9999}
    .modal-fallback .card{background:#fff; padding:16px; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,0.12)}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title"><span style="color:var(--green)">M</span>ake an impact that matters</div>

      <div class="group">
        <label for="players-count">人数</label>
        <select id="players-count"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>

      <div class="group" id="player-names"></div>

      <div class="group" style="margin-left:auto;">
        <div class="dice" id="dice">-</div>
        <button id="btn-start" class="primary">開始</button>
        <button id="btn-roll" disabled>サイコロ</button>
        <button id="btn-reset">リセット</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <div class="board" id="board" aria-label="ボード">
        <div class="start-marker" id="start-marker">START</div>
      </div>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>

      <div class="players" id="players-panel"></div>

      <div class="log" id="log" aria-live="polite"></div>
    </aside>
  </div>

  <script>
  (function(){
    const $ = s => document.querySelector(s);
    const board = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const playersCountSel = $("#players-count"), playerNamesWrap = $("#player-names");
    const START_MARKER = $("#start-marker");

    const TILE_SIZE = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 68;
    const NUM_TILES = 60; // last is goal
    const BASE_JITTER = 12;
    const GAP = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 16;
    const TOKEN_MOVE_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 120;

    let tileCoords = [];
    let state = {
      started:false,
      turn:0,
      currentPlayerIndex:0,
      players:[],
      animating:false,
      rng: Math.random,
      history: []
    };

    // player name UI
    function renderPlayerNameInputs(){
      playerNamesWrap.innerHTML = "";
      const count = Math.max(1, Number(playersCountSel.value) || 2);
      for(let i=0;i<count;i++){
        const inp = document.createElement("input");
        inp.type = "text";
        inp.placeholder = `Player ${i+1}`;
        inp.value = `プレイヤー${i+1}`;
        inp.style.width = "120px";
        playerNamesWrap.appendChild(inp);
      }
    }
    playersCountSel.addEventListener("change", renderPlayerNameInputs);
    renderPlayerNameInputs();
    function getPlayerNames(){
      return Array.from(playerNamesWrap.querySelectorAll("input")).map((el,idx)=> el.value.trim() || `プレイヤー${idx+1}`);
    }

    // Build connected path (rings + connectors)
    function buildConnectedPath(N, containerW, containerH, tileSize, gap){
      const cx = containerW/2, cy = containerH/2;
      const coords = [];
      const margin = Math.max(tileSize*1.6, 28);
      let left = margin, top = margin, right = containerW - margin, bottom = containerH - margin;
      const ringInset = tileSize + gap + Math.round(tileSize*0.4);

      function perimeterPoints(l,t,r,b, spacing){
        const w = Math.max(1, r - l), h = Math.max(1, b - t);
        const perim = 2*(w + h);
        const count = Math.max(4, Math.floor(perim / spacing));
        let topCount = Math.max(1, Math.round(count * (w / perim)));
        let rightCount = Math.max(1, Math.round(count * (h / perim)));
        let bottomCount = Math.max(1, Math.round(count * (w / perim)));
        let leftCount = Math.max(1, Math.round(count * (h / perim)));
        let sum = topCount + rightCount + bottomCount + leftCount;
        let idxAdjust = 0;
        while(sum < count){ if(idxAdjust%4===0) topCount++; else if(idxAdjust%4===1) rightCount++; else if(idxAdjust%4===2) bottomCount++; else leftCount++; idxAdjust++; sum++; }
        while(sum > count){ if(idxAdjust%4===0 && topCount>1) topCount--; else if(idxAdjust%4===1 && rightCount>1) rightCount--; else if(idxAdjust%4===2 && bottomCount>1) bottomCount--; else if(idxAdjust%4===3 && leftCount>1) leftCount--; idxAdjust++; sum--; }
        const pts = [];
        for(let i=0;i<topCount;i++){ const x = l + (i+0.5) * (w / topCount); const y = t; pts.push({x,y}); }
        for(let i=0;i<rightCount;i++){ const x = r; const y = t + (i+0.5) * (h / rightCount); pts.push({x,y}); }
        for(let i=0;i<bottomCount;i++){ const x = r - (i+0.5) * (w / bottomCount); const y = b; pts.push({x,y}); }
        for(let i=0;i<leftCount;i++){ const x = l; const y = b - (i+0.5) * (h / leftCount); pts.push({x,y}); }
        return pts;
      }

      const rings = [];
      let attempts = 0;
      while(coords.length < N - 1 && right - left > tileSize && bottom - top > tileSize && attempts < 24){
        const pts = perimeterPoints(left, top, right, bottom, tileSize + gap);
        rings.push({pts, l:left, t:top, r:right, b:bottom});
        left += ringInset; top += ringInset; right -= ringInset; bottom -= ringInset;
        attempts++;
      }

      let prevExit = null;
      for(let ri = 0; ri < rings.length && coords.length < N - 1; ri++){
        const ring = rings[ri];
        const pts = ring.pts.slice();
        let startIdx = 0;
        if(prevExit){
          let best = 0, bestD = Infinity;
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - prevExit.x, dy = pts[k].y - prevExit.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        } else {
          let best = 0, bestD = Infinity;
          const topCenter = {x:(ring.l+ring.r)/2, y:ring.t};
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - topCenter.x, dy = pts[k].y - topCenter.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        }

        for(let k=0;k<pts.length && coords.length < N - 1;k++){
          const idx = (startIdx + k) % pts.length;
          const jitterX = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          const jitterY = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          coords.push({x: pts[idx].x + jitterX, y: pts[idx].y + jitterY, ang: (Math.random()*2-1)*6});
        }
        prevExit = coords[coords.length-1];
        if(ri < rings.length - 1 && coords.length < N - 1){
          const inner = rings[ri+1];
          const innerCenter = {x: (inner.l + inner.r)/2, y: (inner.t + inner.b)/2};
          const connX = prevExit.x + (innerCenter.x - prevExit.x) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          const connY = prevExit.y + (innerCenter.y - prevExit.y) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          coords.push({x: connX, y: connY, ang: (Math.random()*2-1)*6});
          prevExit = coords[coords.length-1];
        }
      }

      if(coords.length < N - 1){
        const remaining = (N - 1) - coords.length;
        for(let i=0;i<remaining;i++){
          const angle = (i/remaining) * Math.PI * 2;
          const radius = Math.min(containerW, containerH) * 0.11 + (i%3) * (tileSize*0.4);
          const x = cx + Math.cos(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          const y = cy + Math.sin(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          coords.push({x,y,ang:(Math.random()*2-1)*8});
        }
      }

      coords.push({x: cx, y: cy, ang:0});

      const clampMargin = tileSize;
      for(const c of coords){
        c.x = Math.max(clampMargin, Math.min(containerW - clampMargin, c.x));
        c.y = Math.max(clampMargin, Math.min(containerH - clampMargin, c.y));
      }
      if(coords.length > N) coords.length = N;
      return coords;
    }

    function layoutTiles(){
      board.querySelectorAll(".tile").forEach(n=>n.remove());
      const rect = board.getBoundingClientRect();
      const coords = buildConnectedPath(NUM_TILES, rect.width, rect.height, TILE_SIZE, GAP);
      tileCoords = coords;
      coords.forEach((c, idx)=>{
        const div = document.createElement("div");
        div.className = "tile";
        div.dataset.pathIndex = String(idx);
        if(idx === NUM_TILES - 1){
          div.classList.add("goal");
        } else if(idx % 11 === 0){
          div.classList.add("client");
        } else if(idx % 13 === 0){
          div.classList.add("workshop");
        } else if(idx % 6 === 0){
          div.classList.add("event");
        } else if(idx % 5 === 0){
          div.classList.add("bonus");
        } else if(idx % 7 === 0){
          div.classList.add("penalty");
        }
        div.style.left = `${c.x}px`;
        div.style.top = `${c.y}px`;
        const rot = c.ang || ((Math.random()*2-1)*6);
        div.style.transform = `translate(-50%,-50%) rotate(${rot}deg)`;
        board.appendChild(div);
      });

      // align START_MARKER to tile 0 (slight offset above tile)
      if(tileCoords && tileCoords[0]){
        const t0 = tileCoords[0];
        START_MARKER.style.left = `${t0.x}px`;
        START_MARKER.style.top = `${t0.y}px`;
        START_MARKER.style.display = 'grid';
      } else {
        START_MARKER.style.display = 'none';
      }

      placeAllTokens();
    }

    function ensureToken(i){
      let t = document.getElementById(`token-${i}`);
      if(!t){
        t = document.createElement("div"); t.className = "token"; t.id = `token-${i}`;
        t.textContent = String(i+1);
        t.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#000000"][i % 4]) || "#86BB27";
        board.appendChild(t);
      }
      return t;
    }

    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        const pos = (typeof pl.position === "number" && pl.position >= 0) ? pl.position : "__start";
        if(!groups.has(pos)) groups.set(pos, []);
        groups.get(pos).push(i);
      });
      const bRect = board.getBoundingClientRect();
      if(groups.has("__start")){
        const startIdxs = groups.get("__start");
        const sRect = START_MARKER.getBoundingClientRect();
        const sx = (sRect.left - bRect.left) + sRect.width/2;
        const sy = (sRect.top - bRect.top) + sRect.height/2;
        startIdxs.forEach((pi,k)=>{
          const t = ensureToken(pi);
          const offX = ((k % 2) - 0.5) * 18;
          const offY = (Math.floor(k/2) - 0.5) * 18;
          t.style.transform = `translate(${sx + offX}px, ${sy + offY}px)`;
        });
      }
      groups.forEach((idxs, pos)=>{
        if(pos === "__start") return;
        const center = tileCoords[pos];
        if(!center) return;
        const n = idxs.length;
        const baseR = Math.max(14, TILE_SIZE * 0.28);
        if(n === 1){
          const t = ensureToken(idxs[0]);
          t.style.transform = `translate(${center.x}px, ${center.y}px)`;
        } else {
          const perOuter = 6;
          const outerCount = Math.min(n, perOuter);
          const innerCount = Math.max(0, n - perOuter);
          let used = 0;
          const outerR = baseR;
          for(let k=0;k<outerCount;k++){
            const ang = (k / outerCount) * Math.PI * 2 - Math.PI/2;
            const x = center.x + Math.cos(ang) * outerR;
            const y = center.y + Math.sin(ang) * outerR;
            const t = ensureToken(idxs[used++]);
            t.style.transform = `translate(${x}px, ${y}px)`;
          }
          if(innerCount > 0){
            const innerR = baseR * 0.6;
            for(let k=0;k<innerCount;k++){
              const ang = (k / innerCount) * Math.PI * 2 - Math.PI/2;
              const x = center.x + Math.cos(ang) * innerR;
              const y = center.y + Math.sin(ang) * innerR;
              const t = ensureToken(idxs[used++]);
              t.style.transform = `translate(${x}px, ${y}px)`;
            }
          }
        }
      });
    }

    function pushLog(text, kind){
      const p = document.createElement("div");
      p.textContent = `[${(new Date()).toLocaleTimeString()}] ${text}`;
      if(kind === "ok") p.style.color = "green";
      if(kind === "bad") p.style.color = "#333";
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function moveTokenStep(playerIndex, pos){
      return new Promise(resolve=>{
        const t = ensureToken(playerIndex);
        const c = (typeof pos === "number" && tileCoords[pos]) ? tileCoords[pos] : null;
        const bRect = board.getBoundingClientRect();
        if(!c){
          const sRect = START_MARKER.getBoundingClientRect();
          const x = (sRect.left - bRect.left) + sRect.width/2;
          const y = (sRect.top - bRect.top) + sRect.height/2;
          t.style.transform = `translate(${x}px, ${y}px)`;
          setTimeout(()=> resolve(), TOKEN_MOVE_MS + 20);
          return;
        }
        let finished = false;
        function onEnd(e){
          if(e && e.target !== t) return;
          if(finished) return;
          finished = true;
          t.removeEventListener('transitionend', onEnd);
          setTimeout(()=> resolve(), 20);
        }
        t.addEventListener('transitionend', onEnd);
        setTimeout(()=>{ if(!finished){ finished=true; t.removeEventListener('transitionend', onEnd); resolve(); } }, TOKEN_MOVE_MS + 200);
        t.style.transform = `translate(${c.x}px, ${c.y}px)`;
      });
    }

    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      try{
        let pos = (typeof pl.position === "number") ? pl.position : -1;
        let remaining = steps;
        while(remaining > 0){
          const next = pos + 1;
          if(next >= NUM_TILES){
            pos = NUM_TILES - 1;
            pl.position = pos;
            await moveTokenStep(playerIndex, pos);
            break;
          } else {
            pos = next;
            pl.position = pos;
            await moveTokenStep(playerIndex, pos);
          }
          remaining--;
        }
        placeAllTokens();
        await resolveCell(playerIndex, pl.position);
      }catch(e){ console.error(e); }
      finally{ state.animating = false; updateRollState(); }
    }

    async function resolveCell(playerIndex, pathIndex){
      const pl = state.players[playerIndex];
      if(pl == null) return;
      const tileEl = board.querySelector(`.tile[data-path-index="${pathIndex}"]`);
      if(!tileEl){ renderPlayersPanel(); return; }
      if(tileEl.classList.contains("goal")){
        pl.finished = true;
        pushLog(`${pl.name}: ゴール！`, "ok");
        await showCard("ゴール", `${pl.name} がゴールしました`);
      } else if(tileEl.classList.contains("event")){
        pl.learning = (pl.learning || 0) + 3;
        pushLog(`${pl.name}: イベント（学び+3）`, "ok");
        await showCard("案件イベント", `${pl.name} が案件イベントに遭遇しました`);
      } else if(tileEl.classList.contains("bonus")){
        pl.learning = (pl.learning || 0) + 2;
        pushLog(`${pl.name}: ボーナス（学び+2）`, "ok");
      } else if(tileEl.classList.contains("penalty")){
        pl.learning = Math.max(0,(pl.learning || 0)-2);
        pushLog(`${pl.name}: コスト（学び-2）`, "bad");
      } else if(tileEl.classList.contains("client")){
        const base = 0.55;
        const repBonus = ((pl.rating||50)-50)/200;
        const prob = Math.max(0.05, Math.min(0.95, base + repBonus));
        const success = state.rng() < prob;
        if(success){
          pl.learning = Math.max(0, pl.learning + 4); pl.rating = Math.max(0, pl.rating + 3);
          pushLog(`${pl.name}: クライアント成功`, "ok");
        } else {
          pl.mental = Math.max(0, (pl.mental||50) - 3); pl.rating = Math.max(0, (pl.rating||50) - 1);
          pushLog(`${pl.name}: クライアント不調`, "bad");
        }
        await showCard("クライアント面談", `${pl.name} の面談が終了しました`);
      } else if(tileEl.classList.contains("workshop")){
        const gain = [1,2,3,5][Math.floor(state.rng()*4)];
        pl.learning = Math.max(0,(pl.learning||0) + gain); pl.rating = Math.max(0,(pl.rating||0)+1);
        pushLog(`${pl.name}: ワークショップで学び+${gain}`, "ok");
        await showCard("ワークショップ", `${pl.name} がワークショップに参加しました`);
      }
      renderPlayersPanel();
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    function updateRollState(){
      const rbtn = document.getElementById('btn-roll');
      if(!rbtn) return;
      rbtn.disabled = !(state.started && !state.animating);
    }

    async function rollTurn(){
      if(!state.started || state.animating) return;
      const current = state.currentPlayerIndex;
      const val = Math.floor(Math.random()*6)+1;
      if(diceEl) diceEl.textContent = String(val);
      pushLog(`${state.players[current].name} がサイコロを振りました`);
      await animateMove(current, val);
      nextPlayerTurn();
    }

    function nextPlayerTurn(){
      const total = state.players.length;
      if(total === 0) return;
      let i = state.currentPlayerIndex;
      for(let c=0;c<total;c++){
        i = (i+1) % total;
        const cand = state.players[i];
        if(!cand) continue;
        if(cand.finished) continue;
        state.currentPlayerIndex = i;
        statCurrentEl.textContent = state.players[i].name;
        highlightActive();
        return;
      }
      statCurrentEl.textContent = "-";
    }

    function highlightActive(){
      Array.from(playersPanelEl.children).forEach((row, idx)=>{
        if(idx === state.currentPlayerIndex) row.style.boxShadow = "0 0 0 3px rgba(134,187,39,0.12) inset";
        else row.style.boxShadow = "";
      });
      highlightActiveToken();
    }

    function highlightActiveToken(){
      state.players.forEach((pl,i)=>{
        const t = document.getElementById(`token-${i}`);
        if(!t) return;
        if(i === state.currentPlayerIndex) t.style.outline = "3px solid rgba(0,0,0,0.08)";
        else t.style.outline = "none";
      });
    }

    function renderPlayersPanel(){
      playersPanelEl.innerHTML = "";
      state.players.forEach((pl, i)=>{
        const row = document.createElement("div");
        row.className = "player-row";
        const left = document.createElement("div");
        left.style.display = "flex"; left.style.alignItems = "center"; left.style.gap = "8px";
        const badge = document.createElement("div");
        badge.style.width = "18px"; badge.style.height = "18px"; badge.style.borderRadius = "50%";
        badge.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#000000"][i % 4]) || "#86BB27";
        left.appendChild(badge);
        const name = document.createElement("div"); name.textContent = pl.name;
        left.appendChild(name);
        const right = document.createElement("div"); right.style.textAlign = "right";
        right.innerHTML = `<div>学び: ${pl.learning}</div><div>評価: ${pl.rating}</div>`;
        row.appendChild(left); row.appendChild(right);
        playersPanelEl.appendChild(row);
      });
      highlightActive();
    }

    function startGame(){
      if(state.started) return;
      const names = getPlayerNames();
      // set initial positions to 0 (start tile) so players "start" immediately on the start tile
      state.players = names.map((n,i)=>({
        name: n,
        position: 0, // start at tile 0
        learning: 50,
        rating: 50,
        finished: false
      }));
      state.started = true;
      state.turn = 1;
      state.currentPlayerIndex = 0;
      statTurnEl.textContent = String(state.turn);
      statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
      layoutTiles();
      renderPlayersPanel();
      pushLog("ゲームを開始しました（プレイヤーはスタートマスに配置されます）", "ok");
      updateRollState();
    }

    function resetGame(){
      state.started = false;
      state.turn = 0;
      state.currentPlayerIndex = 0;
      state.players = [];
      statTurnEl.textContent = "0";
      statCurrentEl.textContent = "-";
      board.querySelectorAll(".token").forEach(t=>t.remove());
      playersPanelEl.innerHTML = "";
      pushLog("ゲームをリセットしました", "ok");
      updateRollState();
    }

    function showCard(title, text){
      return new Promise(resolve=>{
        document.querySelectorAll('.modal-fallback').forEach(e=>e.remove());
        const overlay = document.createElement("div"); overlay.className="modal-fallback";
        const card = document.createElement("div"); card.className="card";
        const h = document.createElement("h3"); h.textContent = title;
        const p = document.createElement("div"); p.style.marginTop = "8px"; p.textContent = text;
        const actions = document.createElement("div"); actions.style.marginTop = "12px"; actions.style.textAlign = "right";
        const ok = document.createElement("button"); ok.className = "primary"; ok.textContent = "OK";
        ok.addEventListener("click", ()=>{ overlay.remove(); resolve(); });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(p); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
        ok.focus();
      });
    }

    function attachHandlers(){
      btnStart.addEventListener("click", ()=> startGame());
      btnRoll.addEventListener("click", ()=> rollTurn());
      btnReset.addEventListener("click", ()=> resetGame());
      window.addEventListener("resize", ()=> layoutTiles());
      window.addEventListener("keydown", (e)=>{
        if((e.key === " " || e.key === "Enter") && state.started && !state.animating){
          e.preventDefault();
          rollTurn();
        }
      });
    }

    attachHandlers();
    layoutTiles();
    pushLog("UI ready — スタートマス調整済み。開始でプレイヤーがスタートマスに配置されます。");

  })();
  </script>
</body>
</html>
