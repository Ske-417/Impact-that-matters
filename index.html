<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000; --white:#FFFFFF; --green:#86BB27; --green-light:#DFF3C6; --gray:#C4C4C4;
      --cell-size:68px; /* tile size */
      --tile-size: var(--cell-size);
      --tile-gap: 16px; /* baseline gap */
      --board-padding: 24px;
      --token-size:30px;
      --token-move-ms:140ms; /* per-tile move duration */
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); font-weight:900;
    }

    /* Appbar */
    .appbar{position:sticky; top:0; z-index:1100; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); display:flex; justify-content:center}
    .toolbar{width:100%; max-width:1300px; display:flex; gap:10px; align-items:center; padding:8px}
    .title{font-weight:900; font-size:15px; margin-right:auto; color:var(--black)}
    .group{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--gray); border-radius:10px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:8px; border:1px solid var(--gray)}

    button{padding:8px 12px; border-radius:8px; border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent}
    #btn-roll, #btn-reset{ font-weight:900; }

    .wrap{width:100%; max-width:1300px; margin:18px auto; display:grid; grid-template-columns:3fr 1fr; gap:12px; align-items:start; padding:0 12px}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* Board */
    .board-wrap{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:var(--board-padding); position:relative; overflow:hidden; min-height:520px}
    .board{
      position:relative; width:100%; height:820px; touch-action:none; /* slightly taller */
    }

    /* tiles */
    .tile{
      position:absolute;
      width:var(--tile-size);
      height:var(--tile-size);
      background:var(--white);
      border:1px solid var(--gray);
      border-radius:6px;
      transform: translate(-50%,-50%);
      display:grid; place-items:center;
      font-weight:900; color:var(--black);
      box-shadow: 0 6px 18px rgba(0,0,0,0.03);
      transition: transform 120ms linear;
      z-index:2;
      font-size:12px;
    }
    /* eventish tiles: keep visual green border but no inner label text */
    .tile.event,
    .tile.client,
    .tile.workshop,
    .tile.bonus,
    .tile.penalty {
      border:2px solid var(--green);
      background:#fbfff6;
      /* intentionally no text inside */
    }
    .tile.goal{ background: var(--green); color: #fff; border-color: var(--green) }

    /* START_MARKER aligned to tile0 and placed slightly above */
    .start-marker{
      position:absolute;
      width:calc(var(--tile-size) * 0.9);
      height:calc(var(--tile-size) * 0.28);
      display:grid; place-items:center;
      border-radius:6px; border:1px solid rgba(0,0,0,0.08);
      color:var(--black); font-weight:900; background:rgba(134,187,39,0.08);
      z-index:6;
      transform: translate(-50%,-125%); /* positioned above the tile */
      pointer-events:none;
      font-size:12px;
    }

    .token{
      position:absolute;
      width:var(--token-size); height:var(--token-size); border-radius:50%; display:grid; place-items:center; color:#fff; font-weight:900;
      border:2px solid #000; transform: translate(-50%,-50%);
      box-shadow:0 8px 20px rgba(0,0,0,0.06);
      pointer-events:none;
      transition: transform var(--token-move-ms) linear;
      z-index:20;
    }
    .token.finished{ opacity:0.85; border-color:var(--gray) }

    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px}
    .stat{display:flex; justify-content:space-between; padding:10px; border-radius:10px}
    .players{margin-top:10px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:8px; padding:8px; border-radius:10px; border:1px solid var(--gray); align-items:center}
    .attr-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; font-weight:700}
    .log{margin-top:12px; border:1px solid var(--gray); border-radius:10px; padding:10px; max-height:300px; overflow:auto; font-size:13px}

    /* modal fallback */
    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:9999}
    .modal-fallback .card{background:#fff; padding:16px; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,0.12); max-width:720px}
    .event-title{font-weight:900; margin-bottom:8px}
    .event-body{white-space:pre-wrap; margin-bottom:12px; line-height:1.5}
    .event-changes{font-weight:700; color:var(--green)}
    .choice-btn{margin-right:8px}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title"><span style="color:var(--green)">M</span>ake an impact that matters</div>

      <div class="group">
        <label for="players-count">人数</label>
        <select id="players-count"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>

      <div class="group" id="player-names"></div>

      <div class="group" style="margin-left:auto;">
        <div class="dice" id="dice">-</div>
        <button id="btn-start" class="primary">開始</button>
        <button id="btn-roll" disabled>サイコロ</button>
        <button id="btn-reset">リセット</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <div class="board" id="board" aria-label="ボード">
        <div class="start-marker" id="start-marker">START</div>
      </div>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>

      <div class="players" id="players-panel"></div>

      <div class="log" id="log" aria-live="polite"></div>
    </aside>
  </div>

  <script>
  (function(){
    const $ = s => document.querySelector(s);
    const board = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const playersCountSel = $("#players-count"), playerNamesWrap = $("#player-names");
    const START_MARKER = $("#start-marker");

    const TILE_SIZE = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 68;
    const NUM_TILES = 60; // last is goal
    const BASE_JITTER = 12;
    const GAP = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 16;
    const TOKEN_MOVE_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 140;

    let tileCoords = [];
    let state = {
      started:false,
      turn:0,
      currentPlayerIndex:0,
      players:[],
      animating:false,
      rng: Math.random,
      history: []
    };

    // UI: player name inputs
    function renderPlayerNameInputs(){
      playerNamesWrap.innerHTML = "";
      const count = Math.max(1, Number(playersCountSel.value) || 2);
      for(let i=0;i<count;i++){
        const inp = document.createElement("input");
        inp.type = "text";
        inp.placeholder = `Player ${i+1}`;
        inp.value = `プレイヤー${i+1}`;
        inp.style.width = "120px";
        playerNamesWrap.appendChild(inp);
      }
    }
    playersCountSel.addEventListener("change", renderPlayerNameInputs);
    renderPlayerNameInputs();
    function getPlayerNames(){
      return Array.from(playerNamesWrap.querySelectorAll("input")).map((el,idx)=> el.value.trim() || `プレイヤー${idx+1}`);
    }

    // Event templates (positive-only). We'll select based on player's experience stage.
    // Each template: {title, body, changes:{learning, rating, mental, motivation, responsibility}, choices?}
    const EVENT_TEMPLATES = {
      junior: [
        {
          title: "デロイトに入社、念願のコンサル職！",
          body: "入社し念願のコンサル職に就けた！思ったよりも温かみのあるオフィスで安心して発言できた！",
          changes: { learning:0, motivation:10, rating:3, mental:0, responsibility:0 }
        },
        {
          title: "長期プロジェクト配属",
          body: "初めて長期プロジェクトに配属された！2年かかる予定のなかなかない機会だ。しっかり頑張ろう！",
          changes: { learning:0, motivation:5, rating:0, mental:0, responsibility:5 }
        },
        {
          title: "昇進の知らせ",
          body: "入社から一年が経過して職務にも慣れてきた。自分の前向きな姿勢と実績が評価され、アナリストからコンサルタントに出世した！",
          changes: { learning:0, motivation:0, rating:5, mental:0, responsibility:5 } // '給料' mapped to rating increase here (money positive-only)
        },
        {
          title: "有名企業から直案件の打診",
          body: "あの有名企業の社長から直々に案件が舞い込んだ！1ヶ月で意味あるインパクトを出すかどうか選べる場面だ。",
          choices: [
            { label:"受注する（挑戦）", resultText:"難しいが大きな学びと評価に繋がった！", changes:{ learning:5, rating:3, motivation:3, responsibility:5, mental:0 } },
            { label:"今回は見送る（慎重）", resultText:"チームの安定を優先。短期的には負担はないが信頼は維持された。", changes:{ learning:1, motivation:1, rating:1, responsibility:0, mental:0 } }
          ]
        },
        {
          title: "打ち合わせの失敗を糧に",
          body: "打ち合わせでミスがあったが、先輩の指摘を受けて気合いを入れ直した。次に活かそう。",
          changes: { learning:5, motivation:0, rating:1, mental:3, responsibility:0 }
        },
        {
          title: "先輩と有意義な飲み会",
          body: "シニアマネジャーの先輩と話が弾み貴重なアドバイスをもらえた。学びが深まった。",
          changes: { learning:3, motivation:8, rating:0, mental:0, responsibility:0 }
        },
        {
          title: "友人に羨ましがられる",
          body: "大学時代の友人に高賃金を羨ましがられたが、自分はやりがいを楽しんでいる。嬉しい気持ちになれた。",
          changes: { learning:0, motivation:3, rating:0, mental:0, responsibility:0 }
        },
        {
          title: "休日を楽しむ（セルフケア）",
          body: "ネイルサロンや趣味に時間を使ってリフレッシュ。仕事のパフォーマンスを保つための大事な時間。",
          changes: { learning:0, motivation:3, rating:0, mental:2, responsibility:0 }
        }
      ],
      mid: [
        {
          title: "大規模案件の主要メンバーに",
          body: "中堅として大規模案件の主要メンバーに抜擢。チームを率いる手腕が問われるがやりがいがある。",
          changes: { learning:6, motivation:6, rating:4, mental:0, responsibility:4 }
        },
        {
          title: "社内での評価が安定",
          body: "クライアントでの実績が評価され、安定した信頼を獲得。給与の上昇やポジションも期待される。",
          changes: { learning:2, motivation:4, rating:5, mental:0, responsibility:2 }
        },
        {
          title: "講演や勉強会で登壇",
          body: "社内勉強会で登壇し、知見を共有した。周囲からの評価と学びが増えた。",
          changes: { learning:5, motivation:3, rating:2, mental:0, responsibility:0 }
        },
        {
          title: "大手クライアントの直案件",
          body: "有名企業から短期集中の案件が舞い込む。受注するか判断を求められる。",
          choices: [
            { label:"受注（チャレンジ）", resultText:"結果は大成功。高い評価と責任が得られた。", changes:{ learning:6, rating:5, motivation:4, responsibility:6, mental:0 } },
            { label:"見送り（慎重）", resultText:"リスク回避の判断でチームは安定。次の機会に備える。", changes:{ learning:1, motivation:1, rating:1, responsibility:0, mental:0 } }
          ]
        },
        {
          title: "部下の指導で学びが倍増",
          body: "後輩指導を通じて自分自身も成長。教えることで理解が深まった。",
          changes: { learning:6, motivation:2, rating:1, mental:0, responsibility:2 }
        }
      ],
      senior: [
        {
          title: "チームを率いて大きな成果",
          body: "ベテランとしてチームを牽引し、クライアントに大きなインパクトを提供した。信頼が高まる。",
          changes: { learning:8, motivation:6, rating:6, mental:0, responsibility:8 }
        },
        {
          title: "業界賞や表彰",
          body: "プロジェクトの成功が認められ、社内外で表彰された。キャリアハイの瞬間だ。",
          changes: { learning:4, motivation:8, rating:8, mental:0, responsibility:3 }
        },
        {
          title: "重要クライアントの提案を任される",
          body: "経営層と直接やり取りするポジションで、より大きな責任を担うチャンス。",
          choices: [
            { label:"受注（大勝負）", resultText:"受注成功でチームの評判がさらに向上。責任と評価が大きく伸びた。", changes:{ learning:6, rating:8, motivation:6, responsibility:10, mental:0 } },
            { label:"見送り（戦略）", resultText:"戦略的な判断で次にもっと良い機会を探る。安定した判断は信頼に繋がる。", changes:{ learning:2, motivation:2, rating:2, responsibility:1, mental:0 } }
          ]
        },
        {
          title: "後進育成の時間",
          body: "若手の成長に注力し、自分の経験が組織の強化に繋がる実感を得た。",
          changes: { learning:3, motivation:5, rating:2, mental:0, responsibility:3 }
        }
      ]
    };

    // Helpers to pick event template based on player stage (position):
    function eventStageForPlayer(pl){
      // player 'experience' measured by position; threshold 30 as requested
      const pos = typeof pl.position === "number" ? pl.position : 0;
      if(pos >= 30) return "senior";
      if(pos >= 15) return "mid";
      return "junior";
    }

    function pickEventForPlayer(playerIndex){
      const pl = state.players[playerIndex];
      if(!pl) return null;
      const stage = eventStageForPlayer(pl);
      const pool = EVENT_TEMPLATES[stage] || EVENT_TEMPLATES.junior;
      // Pick candidate influenced by attributes: bias toward learning if low, motivation if low, etc.
      // Simple approach: if learning < 40, prefer learning-heavy events.
      const candidates = pool.slice();
      // small weighting
      let weights = candidates.map(c=>{
        let w = 1;
        if((pl.learning||0) < 40 && (c.changes && c.changes.learning)) w += 1.5;
        if((pl.motivation||0) < 40 && (c.changes && c.changes.motivation)) w += 1.3;
        if(c.choices) w += 0.3; // prefer choices sometimes
        return w;
      });
      const total = weights.reduce((a,b)=>a+b,0);
      let r = state.rng() * total;
      for(let i=0;i<candidates.length;i++){
        r -= weights[i];
        if(r <= 0) return candidates[i];
      }
      return candidates[candidates.length-1];
    }

    // modal helpers: show simple card
    function removeFallbacks(){ document.querySelectorAll('.modal-fallback').forEach(e=>e.remove()); }
    function showCard(title, body, timeout=30000){
      return new Promise(resolve=>{
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = body;
        const chg = document.createElement('div'); chg.className='event-changes';
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
        ok.addEventListener('click', ()=>{ overlay.remove(); resolve(true); });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(b); card.appendChild(chg); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
        ok.focus();
      });
    }

    function showEventModal(playerIndex, tmpl){
      return new Promise(async resolve=>{
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const chg = document.createElement('div'); chg.className='event-changes';
        const changes = tmpl.changes || {};
        const parts = [];
        if(changes.learning) parts.push(`学び ＋${changes.learning}`);
        if(changes.rating) parts.push(`評価 ＋${changes.rating}`);
        if(changes.mental) parts.push(`メンタル ＋${changes.mental}`);
        if(changes.motivation) parts.push(`モチベ ＋${changes.motivation}`);
        if(changes.responsibility) parts.push(`責任 ＋${changes.responsibility}`);
        chg.textContent = parts.join('　');
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
        ok.addEventListener('click', ()=>{
          // apply changes (only positive)
          applyAttributeChanges(playerIndex, changes);
          overlay.remove();
          resolve(true);
        });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(b); card.appendChild(chg); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
        ok.focus();
      });
    }

    function showChoiceModal(playerIndex, tmpl){
      return new Promise(async resolve=>{
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const actions = document.createElement('div'); actions.style.textAlign='right'; actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px';
        tmpl.choices.forEach(choice=>{
          const btn = document.createElement('button'); btn.type='button'; btn.className='choice-btn'; btn.textContent = choice.label;
          btn.addEventListener('click', ()=> {
            // apply choice.changes
            applyAttributeChanges(playerIndex, choice.changes || {});
            // show short result
            const resCard = document.createElement('div'); resCard.className='card'; resCard.style.marginTop='8px';
            // clean up overlay and show result then resolve
            overlay.remove();
            showCard(choice.resultText || "選択結果", "").then(()=> resolve(true));
          });
          actions.appendChild(btn);
        });
        const cancel = document.createElement('button'); cancel.type='button'; cancel.textContent='やめる';
        cancel.addEventListener('click', ()=> { overlay.remove(); resolve(false); });
        actions.appendChild(cancel);
        card.appendChild(h); card.appendChild(b); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
      });
    }

    function applyAttributeChanges(playerIndex, changes){
      const pl = state.players[playerIndex];
      if(!pl) return;
      // ensure attributes exist and only add positive numbers (user requested no negatives)
      const attrs = ['learning','rating','mental','motivation','responsibility'];
      attrs.forEach(a=>{
        if(typeof changes[a] === 'number' && changes[a] > 0){
          pl[a] = Math.max(0, (pl[a]||0) + Math.round(changes[a]));
        }
      });
      pushLog(`${pl.name}: 属性が変化しました → ${Object.entries(changes).filter(([k,v])=>v>0).map(([k,v])=> `${k} +${v}`).join(', ')}`, "ok");
      renderPlayersPanel();
    }

    // pick and show event when landing on eventish tile
    async function handleEventTile(playerIndex){
      const tmpl = pickEventForPlayer(playerIndex);
      if(!tmpl) return;
      if(tmpl.choices && Array.isArray(tmpl.choices)){
        await showChoiceModal(playerIndex, tmpl);
      } else {
        await showEventModal(playerIndex, tmpl);
      }
    }

    // Build connected path (rings+connectors), start near top-left (so tile 0 is upper-left)
    function buildConnectedPath(N, containerW, containerH, tileSize, gap){
      const cx = containerW/2, cy = containerH/2;
      const coords = [];
      const margin = Math.max(tileSize*1.6, 28);
      let left = margin, top = margin, right = containerW - margin, bottom = containerH - margin;
      const ringInset = tileSize + gap + Math.round(tileSize*0.4);

      function perimeterPoints(l,t,r,b, spacing){
        const w = Math.max(1, r - l), h = Math.max(1, b - t);
        const perim = 2*(w + h);
        const count = Math.max(4, Math.floor(perim / spacing));
        let topCount = Math.max(1, Math.round(count * (w / perim)));
        let rightCount = Math.max(1, Math.round(count * (h / perim)));
        let bottomCount = Math.max(1, Math.round(count * (w / perim)));
        let leftCount = Math.max(1, Math.round(count * (h / perim)));
        let sum = topCount + rightCount + bottomCount + leftCount;
        let idxAdjust = 0;
        while(sum < count){ if(idxAdjust%4===0) topCount++; else if(idxAdjust%4===1) rightCount++; else if(idxAdjust%4===2) bottomCount++; else leftCount++; idxAdjust++; sum++; }
        while(sum > count){ if(idxAdjust%4===0 && topCount>1) topCount--; else if(idxAdjust%4===1 && rightCount>1) rightCount--; else if(idxAdjust%4===2 && bottomCount>1) bottomCount--; else if(idxAdjust%4===3 && leftCount>1) leftCount--; idxAdjust++; sum--; }
        const pts = [];
        for(let i=0;i<topCount;i++){ const x = l + (i+0.5) * (w / topCount); const y = t; pts.push({x,y}); }
        for(let i=0;i<rightCount;i++){ const x = r; const y = t + (i+0.5) * (h / rightCount); pts.push({x,y}); }
        for(let i=0;i<bottomCount;i++){ const x = r - (i+0.5) * (w / bottomCount); const y = b; pts.push({x,y}); }
        for(let i=0;i<leftCount;i++){ const x = l; const y = b - (i+0.5) * (h / leftCount); pts.push({x,y}); }
        return pts;
      }

      const rings = [];
      let attempts = 0;
      while(coords.length < N - 1 && right - left > tileSize && bottom - top > tileSize && attempts < 24){
        const pts = perimeterPoints(left, top, right, bottom, tileSize + gap);
        rings.push({pts, l:left, t:top, r:right, b:bottom});
        left += ringInset; top += ringInset; right -= ringInset; bottom -= ringInset;
        attempts++;
      }

      let prevExit = null;
      for(let ri = 0; ri < rings.length && coords.length < N - 1; ri++){
        const ring = rings[ri];
        const pts = ring.pts.slice();
        let startIdx = 0;
        if(prevExit){
          let best = 0, bestD = Infinity;
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - prevExit.x, dy = pts[k].y - prevExit.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        } else {
          // choose a point close to top-left to make tile 0 be near top-left
          let best = 0, bestD = Infinity;
          const topLeft = {x: ring.l + 6, y: ring.t + 6};
          for(let k=0;k<pts.length;k++){
            const dx = pts[k].x - topLeft.x, dy = pts[k].y - topLeft.y;
            const d = Math.hypot(dx,dy);
            if(d < bestD){ best = k; bestD = d; }
          }
          startIdx = best;
        }

        for(let k=0;k<pts.length && coords.length < N - 1;k++){
          const idx = (startIdx + k) % pts.length;
          const jitterX = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          const jitterY = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
          coords.push({x: pts[idx].x + jitterX, y: pts[idx].y + jitterY, ang: (Math.random()*2-1)*6});
        }
        prevExit = coords[coords.length-1];
        if(ri < rings.length - 1 && coords.length < N - 1){
          const inner = rings[ri+1];
          const innerCenter = {x: (inner.l + inner.r)/2, y: (inner.t + inner.b)/2};
          const connX = prevExit.x + (innerCenter.x - prevExit.x) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          const connY = prevExit.y + (innerCenter.y - prevExit.y) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
          coords.push({x: connX, y: connY, ang: (Math.random()*2-1)*6});
          prevExit = coords[coords.length-1];
        }
      }

      if(coords.length < N - 1){
        const remaining = (N - 1) - coords.length;
        for(let i=0;i<remaining;i++){
          const angle = (i/remaining) * Math.PI * 2;
          const radius = Math.min(containerW, containerH) * 0.11 + (i%3) * (tileSize*0.4);
          const x = cx + Math.cos(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          const y = cy + Math.sin(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
          coords.push({x,y,ang:(Math.random()*2-1)*8});
        }
      }

      coords.push({x: cx, y: cy, ang:0});

      const clampMargin = tileSize;
      for(const c of coords){
        c.x = Math.max(clampMargin, Math.min(containerW - clampMargin, c.x));
        c.y = Math.max(clampMargin, Math.min(containerH - clampMargin, c.y));
      }
      if(coords.length > N) coords.length = N;
      return coords;
    }

    function layoutTiles(){
      board.querySelectorAll(".tile").forEach(n=>n.remove());
      const rect = board.getBoundingClientRect();
      const coords = buildConnectedPath(NUM_TILES, rect.width, rect.height, TILE_SIZE, GAP);
      tileCoords = coords;
      coords.forEach((c, idx)=>{
        const div = document.createElement("div");
        div.className = "tile";
        div.dataset.pathIndex = String(idx);
        if(idx === NUM_TILES - 1){
          div.classList.add("goal");
          div.textContent = "GOAL";
        } else if(idx % 11 === 0){
          div.classList.add("client");
          // no inner text for eventish tiles per request
        } else if(idx % 13 === 0){
          div.classList.add("workshop");
        } else if(idx % 6 === 0){
          div.classList.add("event");
        } else if(idx % 5 === 0){
          div.classList.add("bonus");
        } else if(idx % 7 === 0){
          div.classList.add("penalty");
        } else {
          // normal tiles can show nothing (kept blank)
        }
        div.style.left = `${c.x}px`;
        div.style.top = `${c.y}px`;
        const rot = c.ang || ((Math.random()*2-1)*6);
        div.style.transform = `translate(-50%,-50%) rotate(${rot}deg)`;
        board.appendChild(div);
      });

      // align START_MARKER to tile 0 (slight offset above tile)
      if(tileCoords && tileCoords[0]){
        const t0 = tileCoords[0];
        START_MARKER.style.left = `${t0.x}px`;
        START_MARKER.style.top = `${t0.y}px`;
        START_MARKER.style.display = 'grid';
      } else {
        START_MARKER.style.display = 'none';
      }

      placeAllTokens();
    }

    // token helpers
    function ensureToken(i){
      let t = document.getElementById(`token-${i}`);
      if(!t){
        t = document.createElement("div"); t.className = "token"; t.id = `token-${i}`;
        t.textContent = String(i+1);
        t.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#000000"][i % 4]) || "#86BB27";
        board.appendChild(t);
      }
      return t;
    }

    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{
        const pos = (typeof pl.position === "number" && pl.position >= 0) ? pl.position : "__start";
        if(!groups.has(pos)) groups.set(pos, []);
        groups.get(pos).push(i);
      });
      const bRect = board.getBoundingClientRect();
      if(groups.has("__start")){
        const startIdxs = groups.get("__start");
        const sRect = START_MARKER.getBoundingClientRect();
        const sx = (sRect.left - bRect.left) + sRect.width/2;
        const sy = (sRect.top - bRect.top) + sRect.height/2;
        startIdxs.forEach((pi,k)=>{
          const t = ensureToken(pi);
          const offX = ((
