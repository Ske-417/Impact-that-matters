<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000; --white:#FFFFFF; --green:#86BB27; --green-light:#DFF3C6; --gray:#C4C4C4;
      --board-cols:10;
      --board-rows:6;
      --cell-size:68px;
      --board-max-width: calc(var(--cell-size) * var(--board-cols) + 32px);
      --btn-radius:12px; --card-radius:14px; --card-shadow:0 12px 30px rgba(0,0,0,0.08);
      --btn-shadow:0 6px 14px rgba(0,0,0,0.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); font-weight:900;
    }

    /* App bar */
    .appbar{position:sticky; top:0; z-index:1100; width:100%; display:flex; justify-content:center; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); box-shadow:0 4px 18px rgba(0,0,0,0.03)}
    .toolbar{width:100%; padding:6px 10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .title{font-weight:900; font-size:15px; margin-right:auto}
    .group{display:flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--gray); border-radius:14px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white)}
    button{padding:8px 12px; border-radius:var(--btn-radius); border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent; box-shadow:var(--btn-shadow)}
    button:disabled{opacity:.45; cursor:not-allowed}

    .player-names{display:flex; gap:8px; align-items:center}
    .player-names input{width:140px; padding:8px 10px; border-radius:10px; border:1px solid var(--gray); background:var(--white); transition:box-shadow .12s, border-color .12s}
    .player-names input:focus{outline:none; border-color:var(--green); box-shadow:0 0 0 6px rgba(134,187,39,0.08)}

    /* Layout */
    .wrap{width:100%; padding:16px; display:grid; grid-template-columns:3fr 1.1fr; gap:12px; flex:1; align-items:start}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* Board */
    .board-wrap{display:flex; justify-content:center; overflow:auto; padding-bottom:8px}
    .board{
      padding:12px; border-radius:14px; border:2px solid var(--gray); background:var(--white);
      display:grid; gap:8px; position:relative;
      grid-template-columns: repeat(var(--board-cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      min-width: var(--board-max-width);
    }
    .cell{
      border:1px solid var(--gray); border-radius:12px; display:grid; place-items:center; padding:8px; font-size:12px;
      color:var(--black); position:relative; background:var(--white);
    }
    .cell.start{background:var(--green-light); border-color:var(--green)}
    .cell.goal{background:var(--green); border-color:var(--green)}
    .cell.event,.cell.bonus,.cell.workshop,.cell.client{background:var(--green-light); border-color:var(--green)}
    .cell.penalty{background:#FBFBFB; border-color:var(--gray)}
    .cell .idx{position:absolute; top:6px; left:8px; font-size:10px; color:var(--black)}

    /* Tokens */
    .token{width:30px; height:30px; border-radius:50%; display:grid; place-items:center; color:var(--white); font-weight:900; border:2px solid var(--black); box-shadow:0 8px 20px rgba(0,0,0,0.06); position:absolute}
    .token.finished{opacity:.9; border-color:var(--gray)}
    .token.active{outline:3px solid rgba(0,0,0,0.08)}

    /* Sidebar */
    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px; background:var(--white)}
    .stat{display:flex; justify-content:space-between; padding:10px 12px; border-radius:12px}
    .players{display:grid; gap:10px; margin-bottom:6px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:10px; padding:10px 12px; border:1px solid var(--gray); border-radius:12px}
    .player-row.active{box-shadow:0 0 0 2px rgba(134,187,39,0.06) inset}
    .badge{width:20px; height:20px; border-radius:50%; border:2px solid var(--black); display:inline-block}
    .attr-list{display:flex; gap:8px; justify-content:flex-end}
    .attr{padding:6px 10px; border-radius:10px; border:1px solid var(--gray); min-width:86px; text-align:center}

    .log{border:1px solid var(--gray); border-radius:12px; padding:12px; max-height:320px; overflow:auto}
    .log p{margin:0 0 8px}
    .log p.ok{color:var(--green)}
    .log p.bad{color:var(--black)}

    .card{padding:16px; border-radius:var(--card-radius); border:1px solid var(--gray); box-shadow:var(--card-shadow)}
    .card .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:12px}

    /* fallback overlay */
    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:1600}
    .modal-fallback .card{max-width:520px; width:calc(100% - 40px)}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title"><span style="color:var(--green)">M</span>ake an impact that matters</div>

      <div class="group"><label for="players-count">人数</label>
        <select id="players-count"><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option></select>
      </div>

      <div class="group player-names" id="player-names"></div>

      <div class="group" style="gap:8px;">
        <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>
        <button id="btn-start" class="primary" type="button">開始</button>
        <button id="btn-roll" disabled type="button">サイコロ</button>
        <button id="btn-reset" type="button">リセット</button>
      </div>

      <div class="group" style="margin-left:auto;">
        <button id="btn-zoom-in" title="ズームイン" type="button">ズーム＋</button>
        <button id="btn-zoom-out" title="ズームアウト" type="button">ズーム−</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <main class="board" id="board" aria-label="ボード"></main>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>

      <div class="players" id="players-panel"></div>

      <div class="log" id="log" aria-live="polite" aria-atomic="false"></div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>履歴</div>
          <div style="display:flex; gap:8px">
            <button id="btn-history" type="button">履歴を表示</button>
            <button id="history-clear" type="button">履歴クリア</button>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <dialog class="modal" id="modal" aria-labelledby="modal-title">
    <div class="card">
      <h3 id="modal-title">イベント</h3>
      <div id="modal-text" style="white-space:normal"></div>
      <div class="muted" id="modal-sub"></div>
      <div class="actions" id="modal-actions"></div>
    </div>
  </dialog>

  <dialog class="modal" id="result" aria-labelledby="result-title">
    <div class="card"><h3 id="result-title">結果発表</h3><div id="result-body"></div><div class="actions"><button id="result-close" class="primary">閉じる</button></div></div>
  </dialog>

  <script>
  (function(){
    const $ = s => document.querySelector(s);
    const boardEl = $("#board"), logEl = $("#log"), diceEl = $("#dice");
    const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
    const playersPanelEl = $("#players-panel");
    const playersCountSel = $("#players-count");
    let btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
    const btnHistory = $("#btn-history"), historyClear = $("#history-clear");
    const genericModal = $("#modal"), genericTitle = $("#modal-title"), genericText = $("#modal-text"), genericSub = $("#modal-sub"), genericActions = $("#modal-actions");
    const resultDlg = $("#result"), resultBody = $("#result-body");

    const BOARD_COLS = Number(getComputedStyle(document.documentElement).getPropertyValue('--board-cols')) || 10;
    const BOARD_ROWS = Number(getComputedStyle(document.documentElement).getPropertyValue('--board-rows')) || 6;
    const TOTAL_CELLS = BOARD_COLS * BOARD_ROWS;
    const PLAYER_COLORS = ["#86BB27","#DFF3C6","#C4C4C4","#000000"];
    const BRANCH_CHANCE = 0.36;
    const HISTORY_KEY = "itmatters_history_v1";

    let state = {
      started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false,
      rng: Math.random, speed:180, overshoot:"clamp", history: []
    };

    // load history
    try{ const saved = localStorage.getItem(HISTORY_KEY); if(saved) state.history = JSON.parse(saved); }catch(e){ state.history = []; }

    function persistHistory(){ try{ localStorage.setItem(HISTORY_KEY, JSON.stringify(state.history)); }catch(e){} }
    function timeNow(){ return (new Date()).toISOString() }
    function pushLog(text, kind){ const item = { ts: timeNow(), text: String(text), kind: kind || "" }; state.history.push(item); persistHistory(); appendLogToDom(item); }
    function appendLogToDom(item){ if(!logEl) return; const p = document.createElement("p"); p.textContent = `[${item.ts.slice(11,19)}] ${item.text}`; if(item.kind) p.classList.add(item.kind); logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }

    // history UI
    function showHistory(){ const overlay = document.createElement("div"); overlay.className="modal-fallback"; const card=document.createElement("div"); card.className="card"; const h=document.createElement("h3"); h.textContent="イベント履歴"; const body=document.createElement("div"); body.style.maxHeight="60vh"; body.style.overflow="auto"; body.style.marginTop="8px"; if(state.history.length===0){ body.textContent="履歴がありません"; } else { state.history.slice().reverse().forEach(it=>{ const d=document.createElement("div"); d.style.padding="6px 0"; d.textContent=`[${it.ts.slice(0,19)}] ${it.text}`; if(it.kind) d.classList.add(it.kind); body.appendChild(d); }); } const actions=document.createElement("div"); actions.className="actions"; const close=document.createElement("button"); close.className="primary"; close.type="button"; close.textContent="閉じる"; close.addEventListener("click", ()=> overlay.remove()); actions.appendChild(close); card.appendChild(h); card.appendChild(body); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay); close.focus(); }
    if(btnHistory) btnHistory.addEventListener("click", showHistory);
    if(historyClear) historyClear.addEventListener("click", ()=>{ if(!confirm("履歴を完全にクリアしますか？")) return; state.history = []; persistHistory(); if(logEl) logEl.innerHTML = ""; pushLog("履歴をクリアしました","ok"); });

    // player inputs
    function renderPlayerNameInputs(){ const count = Math.max(1, Number(playersCountSel.value) || 2); const parent = document.getElementById("player-names"); parent.innerHTML=""; for(let i=0;i<count;i++){ const input=document.createElement("input"); input.type="text"; input.placeholder=`Player ${i+1} 名前`; input.id=`player-name-${i}`; input.value=`プレイヤー${i+1}`; parent.appendChild(input); } }
    playersCountSel.addEventListener("change", renderPlayerNameInputs);
    renderPlayerNameInputs();
    function getPlayerNames(){ return Array.from(document.querySelectorAll("#player-names input")).map((inp,i)=>inp.value.trim()||`プレイヤー${i+1}`); }

    // board cells
    const cells = Array.from({length:TOTAL_CELLS}, (_,i)=>({ index:i, type:"none", label:"" }));
    cells[0] = { index:0, type:"start", label:"スタート" };
    cells[TOTAL_CELLS-1] = { index:TOTAL_CELLS-1, type:"goal", label:"ゴール" };
    (function markCells(){
      for(let i=1;i<TOTAL_CELLS-1;i++){
        if(i % 11 === 0){ cells[i].type="client"; cells[i].label="クライアント"; }
        else if(i % 13 === 0){ cells[i].type="workshop"; cells[i].label="ワークショップ"; }
        else if(i % 6 === 0){ cells[i].type="event"; cells[i].label="案件/イベント"; }
        else if(i % 5 === 0){ cells[i].type="bonus"; cells[i].label="案件成功"; }
        else if(i % 7 === 0){ cells[i].type="penalty"; cells[i].label="コスト"; }
        else { cells[i].type="none"; cells[i].label=""; }
      }
    })();

    // Map linear index to grid (snake pattern)
    function indexToGrid(index){
      const row = Math.floor(index / BOARD_COLS);
      let col = index % BOARD_COLS;
      // snake pattern: every other row reversed visually
      if(row % 2 === 1) col = BOARD_COLS - 1 - col;
      return { row, col };
    }

    // render board
    function renderBoard(){
      if(!boardEl) return;
      boardEl.innerHTML = "";
      // create cells in DOM
      cells.forEach(cell=>{
        const div = document.createElement("div");
        div.className = "cell " + (cell.type !== "none" ? cell.type : "");
        div.dataset.index = String(cell.index);
        const idx = document.createElement("div"); idx.className = "idx"; idx.textContent = String(cell.index); div.appendChild(idx);
        const label = document.createElement("div");
        label.textContent = (["event","bonus","workshop","client"].includes(cell.type) ? "イベント" : (cell.label || ""));
        div.appendChild(label);
        const g = indexToGrid(cell.index);
        div.style.gridRowStart = (g.row + 1);
        div.style.gridColumnStart = (g.col + 1);
        boardEl.appendChild(div);
      });
      // tokens
      state.players.forEach((pl,i)=>{
        const token = document.createElement("div");
        token.className = "token";
        token.id = `token-${i}`;
        token.textContent = String(i+1);
        token.style.background = PLAYER_COLORS[i % PLAYER_COLORS.length];
        token.style.color = (i === 1 || i === 2) ? 'var(--black)' : 'var(--white)';
        if(pl.finished) token.classList.add("finished");
        // will be positioned by placeAllTokens
        boardEl.appendChild(token);
      });
      placeAllTokens();
      highlightActiveToken();
    }

    function placeAllTokens(){
      const groups = new Map();
      state.players.forEach((pl,i)=>{ if(!groups.has(pl.position)) groups.set(pl.position, []); groups.get(pl.position).push(i); });
      const boardRect = boardEl.getBoundingClientRect();
      groups.forEach((idxs, pos)=>{
        const targetCell = boardEl.querySelector(`.cell[data-index="${pos}"]`);
        if(!targetCell) return;
        const rc = targetCell.getBoundingClientRect();
        const cx = rc.left - boardRect.left + rc.width/2;
        const cy = rc.top - boardRect.top + rc.height/2;
        const r = Math.min(rc.width, rc.height)/3.2;
        const n = idxs.length; const baseAngle = -90;
        idxs.forEach((pi,k)=>{
          const angle = baseAngle + (n===1?0: (k-(n-1)/2)*30);
          const rad = angle * Math.PI / 180;
          const x = cx + r * Math.cos(rad) - 14;
          const y = cy + r * Math.sin(rad) - 14;
          const t = document.getElementById(`token-${pi}`);
          if(t) t.style.transform = `translate(${x}px, ${y}px)`;
        });
      });
      state.players.forEach((pl,i)=>{ const t=document.getElementById(`token-${i}`); if(!t) return; if(typeof pl.position!=="number") t.style.transform="translate(-9999px,-9999px)"; });
    }

    function highlightActiveToken(){ state.players.forEach((_,i)=>{ const t=document.getElementById(`token-${i}`); if(!t) return; if(i===state.currentPlayerIndex) t.classList.add("active"); else t.classList.remove("active"); }); }

    function renderPlayersPanel(){
      if(!playersPanelEl) return;
      playersPanelEl.innerHTML = "";
      if(!state.players || state.players.length===0){
        const ph = document.createElement("div"); ph.className="card"; ph.style.textAlign="center"; ph.textContent="プレイヤーを設定して「開始」を押してください"; playersPanelEl.appendChild(ph); return;
      }
      state.players.forEach((pl,i)=>{
        const row=document.createElement("div"); row.className="player-row"+(i===state.currentPlayerIndex?" active":"");
        const left=document.createElement("div"); left.className="left-col";
        const badge=document.createElement("span"); badge.className="badge"; badge.style.background = pl.color; left.appendChild(badge);
        const wrap=document.createElement("div"); wrap.className="name-wrap";
        const name=document.createElement("div"); name.className="player-name"; name.textContent = pl.name;
        const { rank, estimatedSalary } = getRankAndSalary(pl);
        const rankEl=document.createElement("div"); rankEl.className="rank"; rankEl.textContent = rank;
        const salEl=document.createElement("div"); salEl.className="salary"; salEl.textContent = `${yen(estimatedSalary)}`;
        wrap.appendChild(name); wrap.appendChild(rankEl); wrap.appendChild(salEl); left.appendChild(wrap);
        const right=document.createElement("div"); right.className="attr-list";
        const aL=document.createElement("div"); aL.className="attr"; aL.id=`learning-${i}`; aL.textContent=`学び: ${pl.learning}`;
        const aM=document.createElement("div"); aM.className="attr"; aM.id=`mental-${i}`; aM.textContent=`メンタル: ${pl.mental}`;
        const aR=document.createElement("div"); aR.className="attr"; aR.id=`rating-${i}`; aR.textContent=`評価: ${pl.rating}`;
        const aS=document.createElement("div"); aS.className="attr"; aS.id=`responsibility-${i}`; aS.textContent=`責任: ${pl.responsibility}`;
        right.appendChild(aL); right.appendChild(aM); right.appendChild(aR); right.appendChild(aS);
        row.appendChild(left); row.appendChild(right); playersPanelEl.appendChild(row);
      });
    }

    function flashAttr(playerIndex, attrName){
      try{ const el = document.getElementById(`${attrName}-${playerIndex}`); if(!el) return; el.classList.add('flash-attr'); setTimeout(()=>el.classList.remove('flash-attr'),520); }catch(e){}
    }

    // modals (robust with fallback) - same as earlier implementations
    function showCard(title, text, sub, {timeout=30000} = {}) {
      return new Promise(resolve=>{
        if(!genericModal){ resolve(); return; }
        genericTitle.textContent = title||""; genericText.textContent = text||""; genericSub.textContent = sub||""; genericActions.innerHTML="";
        const ok = document.createElement("button"); ok.className="primary"; ok.type="button"; ok.textContent="OK";
        let finished=false, timer=null;
        function cleanup(){ if(timer){clearTimeout(timer); timer=null;} try{ genericModal.removeEventListener("close", onClose); }catch(e){} document.removeEventListener("keydown", onKey); }
        function finish(v){ if(finished) return; finished=true; cleanup(); try{ if(genericModal.open) genericModal.close(); }catch(e){} const fb=document.querySelector(".modal-fallback"); if(fb) fb.remove(); resolve(v); }
        function onOk(){ finish(); } function onClose(){ finish(); } function onKey(e){ if(e.key==="Escape") finish(); }
        ok.addEventListener("click", onOk); genericActions.appendChild(ok);
        try{ genericModal.addEventListener("close", onClose); document.addEventListener("keydown", onKey); timer=setTimeout(()=>finish(), timeout); genericModal.showModal(); ok.focus(); return; }catch(err){}
        const overlay=document.createElement("div"); overlay.className="modal-fallback"; const card=document.createElement("div"); card.className="card";
        card.innerHTML=`<h3>${escapeHtml(title||"")}</h3><div style="white-space:normal">${escapeHtml(text||"")}</div><div class="muted" style="margin-top:8px">${escapeHtml(sub||"")}</div>`;
        const actions=document.createElement("div"); actions.className="actions"; const ok2=document.createElement("button"); ok2.className="primary"; ok2.type="button"; ok2.textContent="OK"; actions.appendChild(ok2); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
        function fbOk(){ finish(); } function fbKey(e){ if(e.key==="Escape") finish(); } function fbClick(e){ if(e.target===overlay) finish(); }
        ok2.addEventListener("click", fbOk); document.addEventListener("keydown", fbKey); overlay.addEventListener("click", fbClick); timer=setTimeout(()=>finish(), timeout);
      });
    }

    function showBranchModal(branchEv, playerIndex, {timeout=30000} = {}) {
      return new Promise(resolve=>{
        if(!genericModal){ resolve(null); return; }
        genericTitle.textContent="案件分岐 (提案)"; genericText.textContent = branchEv.text||""; genericSub.textContent=`あなた: ${state.players[playerIndex].name}`; genericActions.innerHTML="";
        let resolved=false, timer=null;
        function cleanup(){ if(timer){clearTimeout(timer); timer=null;} try{ genericModal.removeEventListener("close", onClose); }catch(e){} document.removeEventListener("keydown", onKey); }
        function finish(v){ if(resolved) return; resolved=true; cleanup(); try{ if(genericModal.open) genericModal.close(); }catch(e){} const fb=document.querySelector(".modal-fallback"); if(fb) fb.remove(); resolve(v); }
        function onClose(){ finish(null); } function onKey(e){ if(e.key==="Escape") finish(null); }
        const buttons=[];
        branchEv.choices.forEach(choice=>{
          const b=document.createElement("button"); b.type="button"; b.textContent=choice.label;
          b.addEventListener("click", ()=>{
            buttons.forEach(x=>x.disabled=true);
            const baseProb=(typeof choice.probGood==="number")?choice.probGood:1.0;
            const pl=state.players[playerIndex];
            const repBonus=Math.max(-0.3, Math.min(0.3,(pl.rating||0)/200));
            const prob=Math.max(0.05, Math.min(0.95, baseProb+repBonus));
            const success=state.rng()<prob;
            const res = success ? (choice.success||{}) : (choice.failure||{});
            ["learning","mental","rating","responsibility"].forEach(k=>{ if(typeof res[k]==="number"){ pl[k]=Math.max(0, Math.round((pl[k]||0)+res[k])); }});
            ["learning","mental","rating","responsibility"].forEach(k=> flashAttr(playerIndex,k));
            pushLog(`${pl.name}: ${success ? (res.text || choice.label + " → 成功") : (res.text || choice.label + " → 失敗")}`, success ? "ok" : "bad");
            finish({choice, res, success});
          });
          genericActions.appendChild(b); buttons.push(b);
        });
        const cancel=document.createElement("button"); cancel.type="button"; cancel.textContent="やめる"; cancel.addEventListener("click", ()=> finish(null)); genericActions.appendChild(cancel); buttons.push(cancel);
        try{ genericModal.addEventListener("close", onClose); document.addEventListener("keydown", onKey); timer=setTimeout(()=>finish(null), timeout); genericModal.showModal(); return; }catch(e){}
        const overlay=document.createElement("div"); overlay.className="modal-fallback"; const card=document.createElement("div"); card.className="card";
        const h=document.createElement("h3"); h.textContent="案件分岐 (提案)"; const body=document.createElement("div"); body.style.whiteSpace="normal"; body.textContent=branchEv.text||"";
        const muted=document.createElement("div"); muted.className="muted"; muted.style.marginTop="8px"; muted.textContent=`あなた: ${state.players[playerIndex].name}`;
        const actionsWrap=document.createElement("div"); actionsWrap.className="actions";
        branchEv.choices.forEach(choice=>{
          const b=document.createElement("button"); b.type="button"; b.textContent=choice.label;
          b.addEventListener("click", ()=>{
            Array.from(actionsWrap.querySelectorAll("button")).forEach(x=>x.disabled=true);
            const baseProb=(typeof choice.probGood==="number")?choice.probGood:1.0;
            const pl=state.players[playerIndex];
            const repBonus=Math.max(-0.3, Math.min(0.3,(pl.rating||0)/200));
            const prob=Math.max(0.05, Math.min(0.95, baseProb+repBonus));
            const success=state.rng()<prob;
            const res = success ? (choice.success||{}) : (choice.failure||{});
            ["learning","mental","rating","responsibility"].forEach(k=>{ if(typeof res[k]==="number"){ pl[k]=Math.max(0, Math.round((pl[k]||0)+res[k])); }});
            ["learning","mental","rating","responsibility"].forEach(k=> flashAttr(playerIndex,k));
            pushLog(`${pl.name}: ${success ? (res.text || choice.label + " → 成功") : (res.text || choice.label + " → 失敗")}`, success ? "ok" : "bad");
            finish({choice, res, success});
          });
          actionsWrap.appendChild(b);
        });
        const fbCancel=document.createElement("button"); fbCancel.type="button"; fbCancel.textContent="やめる"; fbCancel.addEventListener("click", ()=> finish(null)); actionsWrap.appendChild(fbCancel);
        card.appendChild(h); card.appendChild(body); card.appendChild(muted); card.appendChild(actionsWrap); overlay.appendChild(card); document.body.appendChild(overlay);
        function fbKey(e){ if(e.key==="Escape") finish(null); } function fbClick(e){ if(e.target===overlay) finish(null); }
        document.addEventListener("keydown", fbKey); overlay.addEventListener("click", fbClick); timer=setTimeout(()=>finish(null), timeout);
      });
    }

    // game logic
    async function resolveCell(playerIndex, index){
      const pl = state.players[playerIndex]; const cell = cells[index]; if(!cell||!pl) return;
      switch(cell.type){
        case "start": pushLog(`${pl.name}: スタート`, "ok"); break;
        case "goal":
          if(!pl.finished){
            pl.finished = true; state.finishedCount += 1; document.getElementById(`token-${playerIndex}`)?.classList.add("finished");
            pl.turnsToGoal = state.turn; pushLog(`${pl.name}: ゴール！`);
            const { rank, estimatedSalary } = getRankAndSalary(pl);
            await showCard("ゴール（プロジェクト完了）", `ランク: ${rank} / 推定年収: ${yen(estimatedSalary)}`, `${pl.name}`);
            if(isGameFinished()) showResult();
          }
          break;
        // other cases handled earlier...
        default: break;
      }
      renderPlayersPanel();
    }

    // placeholder showResult
    function showResult(){
      try{
        const rows = state.players.map((p,i)=>({i,name:p.name,score:Math.round(estimateScore(p))})).sort((a,b)=>b.score-a.score);
        resultBody.innerHTML = `<ol>${rows.map(r=>`<li>${r.name}: スコア ${r.score} / ランク ${getRankAndSalary(state.players[r.i]).rank} / ${yen(getRankAndSalary(state.players[r.i]).estimatedSalary)}</li>`).join("")}</ol>`;
        try{ resultDlg.showModal(); }catch(e){ alert("結果:\n"+rows.map(r=>`${r.name}: ${r.score}`).join("\n")); }
      }catch(e){ console.error(e); }
    }

    // utilities and scoring (restated)
    function estimateScore(p){ return ((p.learning||0)*0.35 + (p.rating||0)*0.35 + (p.responsibility||0)*0.2 + (p.mental||0)*0.1); }
    function getRankAndSalary(p){
      const score = estimateScore(p);
      const rank = RANKS.find(r=>score>=r.min && score<=r.max) || RANKS[0];
      const modifier = 1 + Math.min(0.5, (p.responsibility||0)/200) + Math.min(0.3, (p.rating||0)/400);
      const estimated = Math.round(rank.base * modifier / 1000) * 1000;
      return { rank: rank.key, baseSalary: rank.base, estimatedSalary: estimated, score: Math.round(score) };
    }

    // movement and control (animateMove kept earlier implementation)
    async function animateMove(playerIndex, steps){
      const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
      state.animating = true; updateRollState();
      try{
        const delay = Number(state.speed || 180);
        let pos = pl.position || 0, dir = 1, remaining = steps;
        while(remaining > 0){
          let next = pos + dir;
          if(next >= TOTAL_CELLS){
            if(state.overshoot === "clamp"){ pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
            else { pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay); dir = -1; }
          } else if(next < 0){ pos = 0; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
          else { pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); }
          remaining--;
        }
        await resolveCell(playerIndex, pl.position);
      }catch(e){ console.error("animateMove error:", e); }
      finally{ state.animating = false; updateRollState(); }
    }

    function updateRollState(){ try{ btnRoll = document.getElementById('btn-roll'); if(!btnRoll) return; btnRoll.disabled = !(state.started && !state.animating); if(!btnRoll.disabled) btnRoll.removeAttribute('aria-disabled'); else btnRoll.setAttribute('aria-disabled','true'); }catch(e){ console.error(e); if(btnRoll) btnRoll.disabled = true; } }

    // start / roll / reset (exposed and safe)
    function startGame(){
      if(state.started) return;
      try{
        const count = Math.max(1, Number(playersCountSel.value) || 2);
        const names = getPlayerNames();
        state.players = [];
        for(let i=0;i<count;i++){
          state.players.push({ name: names[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length], position:0, learning:50, mental:50, rating:50, responsibility:0, achievements:[], finished:false, skipTurn:false });
        }
        state.started = true; state.turn = 1; state.currentPlayerIndex = 0; state.finishedCount = 0; state.rng = Math.random;
        renderBoard(); renderPlayersPanel(); statTurnEl.textContent = String(state.turn); statCurrentEl.textContent = state.players[state.currentPlayerIndex]?.name || "-";
        pushLog("ゲームを開始しました","ok");
        const sbtn = document.getElementById('btn-start'); if(sbtn) sbtn.disabled = true;
        const rbtn = document.getElementById('btn-roll'); if(rbtn) rbtn.disabled = false;
        updateRollState();
      }catch(e){ console.error("startGame failed:", e); pushLog("ゲーム開始に失敗しました: "+(e && e.message?e.message:String(e)),"bad"); state.started=false; state.animating=false; try{ if(document.getElementById('btn-start')) document.getElementById('btn-start').disabled=false; }catch(ex){} updateRollState(); }
    }
    window.startGame = startGame;

    async function rollTurn(){
      try{
        if(!state.started || state.animating) return;
        if(state.players.length === 0){ pushLog("プレイヤーが設定されていません"); return; }
        const current = state.currentPlayerIndex;
        const val = rollDice(); // only update dice display, do not log value
        await animateMove(current, val);
        const wasLast = (function(){ const active = state.players.map((p,i)=>({i,active:!p.finished})); const indices = active.filter(a=>a.active).map(a=>a.i); if(indices.length===0) return false; return current === indices[indices.length-1]; })();
        nextPlayerTurn();
        if(wasLast){ state.turn = (state.turn || 1) + 1; statTurnEl.textContent = String(state.turn); }
        updateRollState();
      }catch(err){ console.error("rollTurn error:", err); pushLog("サイコロ処理でエラーが発生しました: " + (err && err.message ? err.message : String(err)), "bad"); state.animating=false; updateRollState(); }
    }
    window.rollTurn = rollTurn;

    function resetGame(){ state.started=false; state.turn=0; state.currentPlayerIndex=0; state.players=[]; state.finishedCount=0; state.animating=false; state.rng=Math.random; renderBoard(); renderPlayersPanel(); statTurnEl.textContent="0"; statCurrentEl.textContent="-"; const sbtn=document.getElementById('btn-start'); if(sbtn) sbtn.disabled=false; pushLog("ゲームをリセットしました","ok"); updateRollState(); }

    // next player turn (sequential)
    function nextPlayerTurn(){
      const total = state.players.length; if(total===0) return; if(isGameFinished()){ statCurrentEl.textContent="-"; return; }
      let i = state.currentPlayerIndex;
      for(let c=0;c<total;c++){
        i = (i + 1) % total;
        const candidate = state.players[i];
        if(!candidate) continue;
        if(candidate.finished) continue;
        if(candidate.skipTurn){ candidate.skipTurn=false; pushLog(`${candidate.name} の手番は休みのためスキップされました`,"bad"); continue; }
        state.currentPlayerIndex = i; highlightActiveToken(); renderPlayersPanel(); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name; return;
      }
      statCurrentEl.textContent="-";
    }

    const isGameFinished = ()=> state.finishedCount === state.players.length;

    // attach handlers safely (clone to remove old listeners)
    function attachHandlerSafe(id, handler){
      const el = document.getElementById(id); if(!el) return;
      const clone = el.cloneNode(true); el.parentNode.replaceChild(clone, el); clone.addEventListener("click", handler);
    }
    attachHandlerSafe("btn-start", ()=> window.startGame && window.startGame());
    attachHandlerSafe("btn-roll", ()=> window.rollTurn && window.rollTurn());
    attachHandlerSafe("btn-reset", ()=> resetGame());
    attachHandlerSafe("btn-zoom-in", ()=> { document.documentElement.style.fontSize = 'calc(100% + 8px)'; });
    attachHandlerSafe("btn-zoom-out", ()=> { document.documentElement.style.fontSize = '100%'; });

    // keyboard support
    window.addEventListener('keydown', function(ev){ if((ev.ctrlKey||ev.metaKey) && !ev.shiftKey){ if(ev.key==='+'||ev.key==='='){ ev.preventDefault(); document.getElementById('btn-zoom-in')?.click(); } if(ev.key==='-'){ ev.preventDefault(); document.getElementById('btn-zoom-out')?.click(); } return; } if(!ev.ctrlKey && !ev.metaKey){ if((ev.key===' '||ev.key==='Enter') && state.started && !state.animating){ ev.preventDefault(); rollTurn().catch(e=>console.error(e)); } } });

    // init UI
    try{ state.history.forEach(it=>appendLogToDom(it)); }catch(e){}
    renderBoard(); renderPlayersPanel(); updateRollState(); window.dispatchEvent(new CustomEvent('app-ready'));

    // ensureUIHealthy
    (function ensureUIHealthy(){ try{ document.querySelectorAll('.modal-fallback').forEach(e=>e.remove()); }catch(e){} try{ const s=document.getElementById('btn-start'); if(s) s.disabled = !!state.started; const r=document.getElementById('btn-roll'); if(r) r.disabled = !(state.started && !state.animating); }catch(e){ console.error('ensureUIHealthy', e); } })();

    // expose some helpers for debugging
    window.__renderBoard = renderBoard;
    window.__renderPlayersPanel = renderPlayersPanel;
    window.__ensureUIHealthy = ensureUIHealthy;

  })();
  </script>
</body>
</html>
