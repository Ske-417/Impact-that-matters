<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000; --white:#FFFFFF; --green:#86BB27; --green-light:#DFF3C6; --gray:#C4C4C4;
      --cell-size:68px;
      --tile-size: var(--cell-size);
      --tile-gap: 16px;
      --board-padding: 24px;
      --token-size:30px;
      --token-move-ms:140ms;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); font-weight:900;
    }
    .appbar{position:sticky; top:0; z-index:1100; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); display:flex; justify-content:center}
    .toolbar{width:100%; max-width:1300px; display:flex; gap:10px; align-items:center; padding:8px}
    .title{font-weight:900; font-size:15px; margin-right:auto; color:var(--black)}
    .group{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--gray); border-radius:10px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:8px; border:1px solid var(--gray)}
    button{padding:8px 12px; border-radius:8px; border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent}
    #btn-roll, #btn-reset{ font-weight:900; }
    .wrap{width:100%; max-width:1300px; margin:18px auto; display:grid; grid-template-columns:3fr 1fr; gap:12px; align-items:start; padding:0 12px}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }
    .board-wrap{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:var(--board-padding); position:relative; overflow:auto; min-height:520px}
    .board{position:relative; width:100%; height:860px; touch-action:none; background: linear-gradient(180deg, rgba(0,0,0,0.01), rgba(0,0,0,0.00));}
    .tile{position:absolute; width:var(--tile-size); height:var(--tile-size); background:#f6f8fb; border:2px solid rgba(0,0,0,0.06); border-radius:8px; transform: translate(-50%,-50%); display:grid; place-items:center; font-weight:900; color:var(--black); box-shadow: 0 6px 14px rgba(14,20,25,0.06); transition: transform 120ms linear; z-index:2; font-size:12px;}
    .tile:hover{ box-shadow: 0 10px 26px rgba(14,20,25,0.12); }
    .tile.event, .tile.client, .tile.workshop, .tile.bonus, .tile.penalty { border:3px solid var(--green); background:#f7fff6; }
    .tile.goal{ background: var(--green); color: #fff; border-color: var(--green); font-weight:900; box-shadow: 0 10px 30px rgba(134,187,39,0.18); }
    .start-marker{position:absolute; width:calc(var(--tile-size) * 0.9); height:calc(var(--tile-size) * 0.28); display:grid; place-items:center; border-radius:6px; border:1px solid rgba(0,0,0,0.08); color:var(--black); font-weight:900; background:rgba(134,187,39,0.08); z-index:6; transform: translate(-50%,-125%); pointer-events:none; font-size:12px;}
    .token{position:absolute; width:var(--token-size); height:var(--token-size); border-radius:50%; display:grid; place-items:center; color:#fff; font-weight:900; border:2px solid #000; transform: translate(-50%,-50%); box-shadow:0 8px 20px rgba(0,0,0,0.08); pointer-events:none; transition: transform var(--token-move-ms) linear; z-index:30;}
    .token.finished{ opacity:0.85; border-color:var(--gray) }
    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px}
    .stat{display:flex; justify-content:space-between; padding:10px; border-radius:10px}
    .players{margin-top:10px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:8px; padding:8px; border-radius:10px; border:1px solid var(--gray); align-items:center}
    .attr-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; font-weight:700}
    .log{margin-top:12px; border:1px solid var(--gray); border-radius:10px; padding:10px; max-height:300px; overflow:auto; font-size:13px}
    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:9999}
    .modal-fallback .card{background:#fff; padding:16px; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,0.12); max-width:720px}
    .event-title{font-weight:900; margin-bottom:8px}
    .event-body{white-space:pre-wrap; margin-bottom:12px; line-height:1.5}
    .event-changes{font-weight:700; color:var(--green)}
    .choice-btn{margin-right:8px}
    .results-table{width:100%; border-collapse:collapse}
    .results-table th, .results-table td{border:1px solid #eee; padding:8px; text-align:left}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title"><span style="color:var(--green)">M</span>ake an impact that matters</div>
      <div class="group">
        <label for="players-count">人数</label>
        <select id="players-count"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>
      <div class="group" id="player-names"></div>
      <div class="group" style="margin-left:auto;">
        <div class="dice" id="dice">-</div>
        <button id="btn-start" class="primary">開始</button>
        <button id="btn-roll" disabled>サイコロ</button>
        <button id="btn-reset">リセット</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <div class="board" id="board" aria-label="ボード">
        <div class="start-marker" id="start-marker">START</div>
      </div>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>
      <div class="players" id="players-panel"></div>
      <div class="log" id="log" aria-live="polite"></div>
    </aside>
  </div>

  <script>
  (function(){
    window.addEventListener('load', init);
    function init(){
      const $ = s => document.querySelector(s);
      const board = $("#board"), logEl = $("#log"), diceEl = $("#dice");
      const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
      const playersPanelEl = $("#players-panel");
      const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
      const playersCountSel = $("#players-count"), playerNamesWrap = $("#player-names");
      const START_MARKER = $("#start-marker");

      const TILE_SIZE = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 68;
      const NUM_TILES = 60;
      const GAP = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 16;
      const TOKEN_MOVE_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 140;

      let tileCoords = [];
      let state = { started:false, turn:0, currentPlayerIndex:0, players:[], animating:false, rng: Math.random, history: [] };

      function renderPlayerNameInputs(){
        playerNamesWrap.innerHTML = "";
        const count = Math.max(1, Number(playersCountSel.value) || 2);
        for(let i=0;i<count;i++){
          const inp = document.createElement("input");
          inp.type = "text";
          inp.placeholder = `Player ${i+1}`;
          inp.value = `プレイヤー${i+1}`;
          inp.style.width = "120px";
          playerNamesWrap.appendChild(inp);
        }
      }
      playersCountSel.addEventListener("change", renderPlayerNameInputs);
      renderPlayerNameInputs();
      function getPlayerNames(){ return Array.from(playerNamesWrap.querySelectorAll("input")).map((el,idx)=> el.value.trim() || `プレイヤー${idx+1}`); }

      // events abbreviated (same templates as before)
      const EVENT_TEMPLATES = {/* ...omitted for brevity in this snippet; same event definitions as before... */};

      function eventStageForPlayer(pl){
        const pos = typeof pl.position === "number" ? pl.position : 0;
        if(pos >= 30) return "senior";
        if(pos >= 15) return "mid";
        return "junior";
      }
      function pickEventForPlayer(playerIndex){
        const pl = state.players[playerIndex];
        if(!pl) return null;
        const stage = eventStageForPlayer(pl);
        const pool = (EVENT_TEMPLATES[stage] && EVENT_TEMPLATES[stage].length) ? EVENT_TEMPLATES[stage] : [
          { title:"案件イベント", body:"前向きな出来事がありました。", changes:{ learning:3, motivation:3 } }
        ];
        return pool[Math.floor(state.rng()*pool.length)];
      }

      function removeFallbacks(){ document.querySelectorAll('.modal-fallback').forEach(e=>e.remove()); }
      function showCard(title, body){
        return new Promise(resolve=>{
          removeFallbacks();
          const overlay = document.createElement('div'); overlay.className='modal-fallback';
          const card = document.createElement('div'); card.className='card';
          const h = document.createElement('div'); h.className='event-title'; h.textContent = title;
          const b = document.createElement('div'); b.className='event-body'; b.textContent = body;
          const actions = document.createElement('div'); actions.style.textAlign='right';
          const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
          ok.addEventListener('click', ()=>{ overlay.remove(); resolve(true); });
          actions.appendChild(ok);
          card.appendChild(h); card.appendChild(b); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
          ok.focus();
        });
      }

      function applyAttributeChanges(playerIndex, changes){
        const pl = state.players[playerIndex];
        if(!pl) return;
        const attrs = ['learning','rating','mental','motivation','responsibility'];
        attrs.forEach(a=>{
          if(typeof changes[a] === 'number'){
            pl[a] = Math.round((pl[a]||0) + changes[a]);
            if(pl[a] < 0) pl[a] = 0;
          }
        });
        pushLog(`${pl.name}: 属性が変化しました → ${Object.entries(changes).filter(([k,v])=>v!==0).map(([k,v])=> `${k} ${v>0?'+':''}${v}`).join(', ')}`, "ok");
        renderPlayersPanel();
      }

      async function showEventModal(playerIndex, tmpl){
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const chg = document.createElement('div'); chg.className='event-changes';
        const changes = tmpl.changes || {};
        const parts = [];
        if(changes.learning) parts.push(`学び ＋${changes.learning}`);
        if(changes.rating) parts.push(`評価 ＋${changes.rating}`);
        if(changes.mental) parts.push(`メンタル ＋${changes.mental}`);
        if(changes.motivation) parts.push(`モチベ ＋${changes.motivation}`);
        if(changes.responsibility) parts.push(`責任 ＋${changes.responsibility}`);
        chg.textContent = parts.join('　');
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
        ok.addEventListener('click', ()=>{ applyAttributeChanges(playerIndex, changes); overlay.remove(); });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(b); card.appendChild(chg); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay); ok.focus();
      }

      // Choice modal with probabilistic success/failure kept as before
      async function showChoiceModal(playerIndex, tmpl){
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px';
        tmpl.choices.forEach(choice=>{
          const btn = document.createElement('button'); btn.type='button'; btn.className='choice-btn'; btn.textContent = choice.label;
          btn.addEventListener('click', async ()=> {
            const baseProb = (typeof choice.probGood === 'number') ? choice.probGood : 1.0;
            const pl = state.players[playerIndex];
            const repBonus = Math.max(-0.2, Math.min(0.2, ((pl.rating||50)-50)/250));
            const prob = Math.max(0.02, Math.min(0.98, baseProb + repBonus));
            const success = state.rng() < prob;
            if(success){
              const succ = choice.success || choice.changes || {};
              applyAttributeChanges(playerIndex, succ);
              overlay.remove();
              await showCard("成功！", choice.resultTextSuccess || choice.resultText || "良い結果が得られました。");
            } else {
              const fail = choice.failure || { learning:4, rating:-2, motivation:1 };
              applyAttributeChanges(playerIndex, fail);
              overlay.remove();
              await showCard("失敗（学びあり）", choice.resultTextFailure || "挑戦は失敗したが、多くを学んだ。学びが増え、評価は少し下がった。");
            }
          });
          actions.appendChild(btn);
        });
        const cancel = document.createElement('button'); cancel.type='button'; cancel.textContent='やめる';
        cancel.addEventListener('click', ()=> overlay.remove());
        actions.appendChild(cancel);
        card.appendChild(h); card.appendChild(b); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
      }

      async function handleEventTile(playerIndex){
        const tmpl = pickEventForPlayer(playerIndex);
        if(!tmpl) return;
        if(tmpl.choices && Array.isArray(tmpl.choices)) await showChoiceModal(playerIndex, tmpl); else await showEventModal(playerIndex, tmpl);
      }

      /* Controlled-variance spiral on grid: guarantees no overlaps while keeping organic feel
         - We place tiles on a regular grid (cell = tile + gap) to guarantee center distances.
         - Then we apply a bounded jitter (<= jitterMax) that is small enough to never cause overlap.
         - JitterMax = min(gap*0.45, tileSize*0.18, 12) so it's visible but safe.
         - This keeps a spiral traversal order while adding organic randomness.
      */
      function buildSpiralGridWithJitter(N, containerW, containerH, tileSize, gap){
        const cell = tileSize + gap;
        let margin = Math.max(tileSize/2 + 12, 12);
        const maxAttempts = 8;
        let cols, rows;
        for(let attempt=0; attempt<maxAttempts; attempt++){
          const usableW = Math.max(0, containerW - margin*2);
          const usableH = Math.max(0, containerH - margin*2);
          cols = Math.max(1, Math.floor((usableW + gap) / cell));
          rows = Math.max(1, Math.floor((usableH + gap) / cell));
          if(cols * rows >= N) break;
          margin = Math.max(8, margin - 6);
        }
        if(cols * rows < N){
          const usableW = Math.max(0, containerW - (tileSize/2) * 2);
          const usableH = Math.max(0, containerH - (tileSize/2) * 2);
          cols = Math.max(1, Math.floor(usableW / tileSize));
          rows = Math.max(1, Math.floor(usableH / tileSize));
        }
        cols = Math.max(cols, 3);
        rows = Math.max(rows, 3);

        // spiral traversal generation (same as before)
        const coordsGrid = [];
        const totalCells = cols * rows;
        const needed = Math.min(N, totalCells);
        let layer = 0;
        while(coordsGrid.length < needed){
          const left = layer, top = layer, right = cols - 1 - layer, bottom = rows - 1 - layer;
          if(left > right || top > bottom) break;
          for(let c = left; c <= right && coordsGrid.length < needed; c++) coordsGrid.push({col:c, row:top});
          for(let r = top+1; r <= bottom-1 && coordsGrid.length < needed; r++) coordsGrid.push({col:right, row:r});
          if(bottom > top) for(let c = right; c >= left && coordsGrid.length < needed; c--) coordsGrid.push({col:c, row:bottom});
          if(left < right) for(let r = bottom-1; r > top && coordsGrid.length < needed; r--) coordsGrid.push({col:left, row:r});
          layer++;
        }
        if(coordsGrid.length < N){
          for(let r=0;r<rows && coordsGrid.length < N;r++){
            for(let c=0;c<cols && coordsGrid.length < N;c++){
              if(!coordsGrid.find(p => p.col===c && p.row===r)) coordsGrid.push({col:c,row:r});
            }
          }
        }

        // compute jitter max so we never reduce center-to-center below tileSize + safeMargin
        const safeMargin = 4; // keep extra safety pixels
        const minCenter = tileSize + safeMargin;
        // cell >= tileSize + gap ensures base distance; jitter must be < (cell - minCenter)/2
        const jitterLimit = Math.max(0, (cell - minCenter) / 2);
        const jitterMax = Math.min(jitterLimit, Math.min(gap*0.45, tileSize*0.18, 12));

        // map to pixel centers and apply bounded jitter (preserve guarantee)
        const startX = margin;
        const startY = margin;
        const pixelCoords = coordsGrid.slice(0, N).map((p, idx) => {
          const baseX = startX + p.col * cell;
          const baseY = startY + p.row * cell;
          // apply small jitter biased by ring index to make inner rings slightly tighter visually
          // bias factor: earlier coords (outer) get slightly less jitter, inner coords more (but still bounded)
          const ringBias = Math.min(1, Math.max(0, (idx / N)));
          const jitterX = (Math.random()*2 -1) * jitterMax * (0.5 + 0.8 * (1 - ringBias)); // outer slightly more, inner slightly less
          const jitterY = (Math.random()*2 -1) * jitterMax * (0.5 + 0.8 * (1 - ringBias));
          // small rotation angle for organic feel
          const ang = (Math.random()*2 -1) * 6;
          return { x: Math.round(baseX + jitterX), y: Math.round(baseY + jitterY), ang, col: p.col, row: p.row };
        });

        // Final safety pass: ensure pairwise center distances >= minCenter.
        // Because jitterMax was chosen conservatively, conflicts should be rare; but check and nudge if needed.
        for(let i=0;i<pixelCoords.length;i++){
          for(let j=i+1;j<pixelCoords.length;j++){
            const a = pixelCoords[i], b = pixelCoords[j];
            const dx = b.x - a.x, dy = b.y - a.y;
            const d = Math.hypot(dx,dy);
            if(d < minCenter){
              // push them apart along vector connecting them, splitting adjustment
              const need = (minCenter - d) / 2 + 0.5;
              const ux = dx === 0 && dy === 0 ? (Math.random()>.5?1:0) : dx / (d || 1);
              const uy = dx === 0 && dy === 0 ? (Math.random()>.5?0:1) : dy / (d || 1);
              // nudge both points (clamp nudges so we don't create new collisions), smaller nudge for stable layout
              a.x = Math.round(a.x - ux * need);
              a.y = Math.round(a.y - uy * need);
              b.x = Math.round(b.x + ux * need);
              b.y = Math.round(b.y + uy * need);
            }
          }
        }

        // clamp to board bounds with margins
        for(const c of pixelCoords){
          c.x = Math.max(tileSize/2 + 6, Math.min(containerW - (tileSize/2 + 6), c.x));
          c.y = Math.max(tileSize/2 + 6, Math.min(containerH - (tileSize/2 + 6), c.y));
        }

        return pixelCoords;
      }

      // layout using controlled-variance spiral
      function layoutTiles(){
        board.querySelectorAll(".tile").forEach(n=>n.remove());
        const rect = board.getBoundingClientRect();
        const coords = buildSpiralGridWithJitterSafeFallback(NUM_TILES, rect.width, rect.height, TILE_SIZE, GAP);
        tileCoords = coords;
        coords.forEach((c, idx)=>{
          const div = document.createElement("div");
          div.className = "tile";
          div.dataset.pathIndex = String(idx);
          if(idx === NUM_TILES - 1){ div.classList.add("goal"); div.textContent = "GOAL"; }
          else if(idx % 11 === 0){ div.classList.add("client"); }
          else if(idx % 13 === 0){ div.classList.add("workshop"); }
          else if(idx % 6 === 0){ div.classList.add("event"); }
          else if(idx % 5 === 0){ div.classList.add("bonus"); }
          else if(idx % 7 === 0){ div.classList.add("penalty"); }
          div.style.left = `${c.x}px`; div.style.top = `${c.y}px`;
          // apply small rotation stored in ang (keeps organic look but no collision change)
          div.style.transform = `translate(-50%,-50%) rotate(${c.ang || 0}deg)`;
          board.appendChild(div);
        });

        // align START_MARKER to tile 0
        if(tileCoords && tileCoords[0]){
          const t0 = tileCoords[0];
          START_MARKER.style.left = `${t0.x}px`;
          START_MARKER.style.top = `${t0.y}px`;
          START_MARKER.style.display = 'grid';
        } else {
          START_MARKER.style.display = 'none';
        }

        placeAllTokens();
      }

      // safe wrapper: try spiral+jit, fallback to strict grid if something unexpected occurs
      function buildSpiralGridWithJitterSafeFallback(N, w, h, tileSize, gap){
        try{
          return buildSpiralGridWithJitter(N, w, h, tileSize, gap);
        }catch(e){
          console.warn("spiralWithJitter failed, falling back to deterministic grid:", e);
          // fallback deterministic grid (no jitter)
          const cell = tileSize + gap;
          const margin = Math.max(tileSize/2 + 12, 12);
          const cols = Math.max(3, Math.floor((w - margin*2) / cell));
          const rows = Math.max(3, Math.floor((h - margin*2) / cell));
          const coords = [];
          let idx = 0;
          for(let r=0;r<rows && idx<N;r++){
            for(let c=0;c<cols && idx<N;c++){
              coords.push({ x: margin + c*cell, y: margin + r*cell, ang:0});
              idx++;
            }
          }
          // pad if needed with center
          while(coords.length < N) coords.push({ x: w/2, y: h/2, ang:0});
          return coords;
        }
      }

      // token helpers: set background and readable text color
      function ensureToken(i){
        let t = document.getElementById(`token-${i}`);
        if(!t){ t = document.createElement("div"); t.className = "token"; t.id = `token-${i}`; t.textContent = String(i+1); board.appendChild(t); }
        const palette = ["#86BB27","#DFF3C6","#C4C4C4","#2B2B2B"];
        const bg = palette[i % palette.length];
        t.style.background = bg;
        const rgb = hexToRgb(bg);
        const lum = (0.2126 * linearize(rgb.r/255) + 0.7152 * linearize(rgb.g/255) + 0.0722 * linearize(rgb.b/255));
        t.style.color = (lum > 0.6) ? "#000" : "#fff";
        return t;
      }
      function hexToRgb(hex){ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); const num = parseInt(hex,16); return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 }; }
      function linearize(c){ return (c <= 0.03928) ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4); }

      function placeAllTokens(){
        const groups = new Map();
        state.players.forEach((pl,i)=>{
          const pos = (typeof pl.position === "number" && pl.position >= 0) ? pl.position : "__start";
          if(!groups.has(pos)) groups.set(pos, []);
          groups.get(pos).push(i);
        });
        const bRect = board.getBoundingClientRect();
        if(groups.has("__start")){
          const startIdxs = groups.get("__start");
          const sRect = START_MARKER.getBoundingClientRect();
          const sx = (sRect.left - bRect.left) + sRect.width/2;
          const sy = (sRect.top - bRect.top) + sRect.height/2;
          startIdxs.forEach((pi,k)=>{ const t = ensureToken(pi); const offX = ((k % 2) - 0.5) * 18; const offY = (Math.floor(k/2) - 0.5) * 18; t.style.transform = `translate(${sx + offX}px, ${sy + offY}px)`; });
        }
        groups.forEach((idxs, pos)=>{
          if(pos === "__start") return;
          const center = tileCoords[pos];
          if(!center) return;
          const n = idxs.length;
          const baseR = Math.max(14, TILE_SIZE * 0.28);
          if(n === 1){ const t = ensureToken(idxs[0]); t.style.transform = `translate(${center.x}px, ${center.y}px)`; }
          else {
            const perOuter = 6; const outerCount = Math.min(n, perOuter); const innerCount = Math.max(0, n - perOuter); let used = 0;
            const outerR = baseR;
            for(let k=0;k<outerCount;k++){ const ang = (k / outerCount) * Math.PI * 2 - Math.PI/2; const x = center.x + Math.cos(ang) * outerR; const y = center.y + Math.sin(ang) * outerR; const t = ensureToken(idxs[used++]); t.style.transform = `translate(${x}px, ${y}px)`; }
            if(innerCount > 0){ const innerR = baseR * 0.6; for(let k=0;k<innerCount;k++){ const ang = (k / innerCount) * Math.PI * 2 - Math.PI/2; const x = center.x + Math.cos(ang) * innerR; const y = center.y + Math.sin(ang) * innerR; const t = ensureToken(idxs[used++]); t.style.transform = `translate(${x}px, ${y}px)`; } }
          }
        });
      }

      function pushLog(text, kind){ const p = document.createElement("div"); p.textContent = `[${(new Date()).toLocaleTimeString()}] ${text}`; if(kind === "ok") p.style.color = "green"; if(kind === "bad") p.style.color = "#333"; logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }

      function moveTokenStep(playerIndex, pos){
        return new Promise(resolve=>{
          const t = ensureToken(playerIndex);
          const c = (typeof pos === "number" && tileCoords[pos]) ? tileCoords[pos] : null;
          const bRect = board.getBoundingClientRect();
          if(!c){ const sRect = START_MARKER.getBoundingClientRect(); const x = (sRect.left - bRect.left) + sRect.width/2; const y = (sRect.top - bRect.top) + sRect.height/2; t.style.transform = `translate(${x}px, ${y}px)`; setTimeout(()=> resolve(), TOKEN_MOVE_MS + 20); return; }
          let finished = false;
          function onEnd(e){ if(e && e.target !== t) return; if(finished) return; finished = true; t.removeEventListener('transitionend', onEnd); setTimeout(()=> resolve(), 20); }
          t.addEventListener('transitionend', onEnd);
          setTimeout(()=>{ if(!finished){ finished=true; t.removeEventListener('transitionend', onEnd); resolve(); } }, TOKEN_MOVE_MS + 220);
          t.style.transform = `translate(${c.x}px, ${c.y}px)`;
        });
      }

      async function animateMove(playerIndex, steps){
        const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
        state.animating = true; updateRollState();
        try{
          let pos = (typeof pl.position === "number") ? pl.position : -1;
          let remaining = steps;
          while(remaining > 0){
            const next = pos + 1;
            if(next >= NUM_TILES){ pos = NUM_TILES - 1; pl.position = pos; await moveTokenStep(playerIndex, pos); break; } else { pos = next; pl.position = pos; await moveTokenStep(playerIndex, pos); }
            remaining--;
          }
          placeAllTokens();
          const tileEl = board.querySelector(`.tile[data-path-index="${pl.position}"]`);
          if(tileEl && (tileEl.classList.contains('event') || tileEl.classList.contains('client') || tileEl.classList.contains('workshop') || tileEl.classList.contains('bonus') || tileEl.classList.contains('penalty')) ){
            await handleEventTile(playerIndex);
          } else {
            await resolveCell(playerIndex, pl.position);
          }
        }catch(e){ console.error(e); }
        finally{ state.animating = false; updateRollState(); }
      }

      async function resolveCell(playerIndex, pathIndex){
        const pl = state.players[playerIndex];
        if(pl == null) return;
        const tileEl = board.querySelector(`.tile[data-path-index="${pathIndex}"]`);
        if(!tileEl){ renderPlayersPanel(); return; }
        if(tileEl.classList.contains("goal")){
          if(!pl.finished){
            pl.finished = true;
            pl.turnsToGoal = state.turn;
            pushLog(`${pl.name}: ゴール！`, "ok");
            await showCard("ゴール（完了）", `${pl.name} がゴールしました！`);
            checkAllFinishedAndShowResults();
          }
        } else { renderPlayersPanel(); }
      }

      function updateRollState(){ const rbtn = document.getElementById('btn-roll'); if(!rbtn) return; rbtn.disabled = !(state.started && !state.animating); }
      function isGameFinished(){ return state.players.length>0 && state.players.every(p=>p.finished); }

      function showFinalResults(){
        const results = state.players.map(p=>{
          const score = ((p.learning||0)*0.30 + (p.rating||0)*0.30 + (p.motivation||0)*0.20 + (p.responsibility||0)*0.15 + (p.mental||0)*0.05);
          return {...p, score: Math.round(score*100)/100};
        }).sort((a,b)=> b.score - a.score);
        let body = "最終結果\n\n";
        body += "順位\t名前\t学び\t評価\tメンタル\tモチベ\t責任\tスコア\n";
        results.forEach((r, idx)=>{ body += `${idx+1}\t${r.name}\t${r.learning}\t${r.rating}\t${r.mental}\t${r.motivation}\t${r.responsibility}\t${r.score}\n`; });
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = "ゲーム結果";
        const pre = document.createElement('pre'); pre.style.whiteSpace='pre-wrap'; pre.textContent = body;
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='閉じる';
        ok.addEventListener('click', ()=>{ overlay.remove(); });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(pre); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
      }

      function checkAllFinishedAndShowResults(){ if(isGameFinished()){ setTimeout(()=> showFinalResults(), 200); } }

      async function rollTurn(){ if(!state.started || state.animating) return; const current = state.currentPlayerIndex; const val = Math.floor(Math.random()*6)+1; if(diceEl) diceEl.textContent = String(val); pushLog(`${state.players[current].name} がサイコロを振りました`); await animateMove(current, val); nextPlayerTurn(); }

      function nextPlayerTurn(){ const total = state.players.length; if(total === 0) return; let i = state.currentPlayerIndex; for(let c=0;c<total;c++){ i = (i+1) % total; const cand = state.players[i]; if(!cand) continue; if(cand.finished) continue; state.currentPlayerIndex = i; statCurrentEl.textContent = state.players[state.currentPlayerIndex].name; highlightActive(); return; } statCurrentEl.textContent = "-"; }

      function highlightActive(){ Array.from(playersPanelEl.children).forEach((row, idx)=>{ if(idx === state.currentPlayerIndex) row.style.boxShadow = "0 0 0 3px rgba(134,187,39,0.12) inset"; else row.style.boxShadow = ""; }); highlightActiveToken(); }
      function highlightActiveToken(){ state.players.forEach((pl,i)=>{ const t = document.getElementById(`token-${i}`); if(!t) return; if(i === state.currentPlayerIndex) t.style.outline = "3px solid rgba(0,0,0,0.08)"; else t.style.outline = "none"; }); }

      function renderPlayersPanel(){
        playersPanelEl.innerHTML = "";
        state.players.forEach((pl, i)=>{
          const row = document.createElement("div"); row.className = "player-row";
          const left = document.createElement("div"); left.style.display = "flex"; left.style.alignItems = "center"; left.style.gap = "8px";
          const badge = document.createElement("div"); badge.style.width = "18px"; badge.style.height = "18px"; badge.style.borderRadius = "50%";
          badge.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#2B2B2B"][i % 4]) || "#86BB27";
          left.appendChild(badge);
          const name = document.createElement("div"); name.textContent = pl.name;
          left.appendChild(name);
          const right = document.createElement("div"); right.className = "attr-list";
          right.innerHTML = `<div>学び:${pl.learning}</div><div>評価:${pl.rating}</div><div>メンタル:${pl.mental}</div><div>モチベ:${pl.motivation}</div><div>責任:${pl.responsibility}</div>`;
          row.appendChild(left); row.appendChild(right); playersPanelEl.appendChild(row);
        });
        highlightActive();
      }

      function startGame(){
        if(state.started) return;
        const names = getPlayerNames();
        state.players = names.map((n,i)=>({ name: n, position: 0, learning: 50, rating: 50, mental: 50, motivation: 50, responsibility: 0, finished: false }));
        state.started = true; state.turn = 1; state.currentPlayerIndex = 0; statTurnEl.textContent = String(state.turn); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
        layoutTiles(); renderPlayersPanel(); pushLog("ゲームを開始しました（プレイヤーはスタートマスに配置されます）", "ok"); updateRollState();
      }

      function resetGame(){ state.started = false; state.turn = 0; state.currentPlayerIndex = 0; state.players = []; statTurnEl.textContent = "0"; statCurrentEl.textContent = "-"; board.querySelectorAll(".token").forEach(t=>t.remove()); playersPanelEl.innerHTML = ""; pushLog("ゲームをリセットしました", "ok"); updateRollState(); }

      function attachHandlers(){ btnStart.addEventListener("click", ()=> startGame()); btnRoll.addEventListener("click", ()=> rollTurn()); btnReset.addEventListener("click", ()=> resetGame()); window.addEventListener("resize", ()=> layoutTiles()); window.addEventListener("keydown", (e)=>{ if((e.key === " " || e.key === "Enter") && state.started && !state.animating){ e.preventDefault(); rollTurn(); }}); }

      attachHandlers(); layoutTiles(); pushLog("UI ready — 螺旋を意識したグリッド＋制御ジッターで「被らない」かつほどよく崩したレイアウトにしました。");
    }
  })();
  </script>
</body>
</html>
