<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>人生ゲーム ver-4</title>
  <style>
    :root{
      --board-cols:8; --board-rows:5; --cell-size:68px;
      --accent:#ff6b6b; --bg:#fffaf0; --text:#222; --active:#4c9aff;
      --ok:#00c853; --warn:#ff8f00; --bad:#e53935; --muted:#94a3b8;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--text); background:var(--bg);
      display:flex; flex-direction:column; align-items:center
    }

    /* ===== App Bar / Toolbar ===== */
    .appbar{position:sticky; top:0; z-index:10; width:100%; display:flex; justify-content:center; background:linear-gradient(180deg, rgba(255,250,240,.95), rgba(255,250,240,.85)); backdrop-filter:saturate(1.05)}
    .toolbar{width:min(1100px,100%); padding:12px 16px; display:flex; flex-wrap:wrap; align-items:center; gap:10px}
    .title{font-weight:800; font-size:16px; color:#111; letter-spacing:.02em; white-space:nowrap; margin-right:auto}

    .group{display:flex; align-items:center; gap:6px; padding:6px 8px; background:#fff; border:1px solid #e6e8eb; border-radius:10px}
    label{font-size:12px; color:#555}
    select,input[type="number"],input[type="text"],input[type="range"],textarea,select{padding:6px 8px; border-radius:8px; border:1px solid #ddd}
    input[type="range"]{width:140px}
    button{padding:10px 14px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer; font-weight:600}
    button.primary{background:var(--accent); color:#fff; border-color:transparent}
    button:disabled{opacity:.5; cursor:not-allowed}
    .dice{width:42px; height:42px; display:grid; place-items:center; border-radius:8px; border:1px solid #e2e8f0; background:#fff; font-weight:800}
    .dice.spin{animation:spin .6s ease}
    @keyframes spin{0%{transform:rotate(0)}50%{transform:rotate(180deg) scale(1.15)}100%{transform:rotate(360deg)}}

    /* ===== Layout ===== */
    .wrap{width:min(1100px,100%); padding:16px; display:grid; grid-template-columns:3fr 1.2fr; gap:16px}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* ===== Board ===== */
    .board{background:#fff; border:2px solid #eee; border-radius:12px; padding:12px; position:relative; display:grid; gap:8px; grid-template-columns:repeat(var(--board-cols), minmax(52px, var(--cell-size))); grid-template-rows:repeat(var(--board-rows), minmax(52px, var(--cell-size))); min-height: calc(var(--board-rows) * var(--cell-size));}
    .cell{background:#f9fafb; border:1px solid #e6e8eb; border-radius:10px; padding:6px; display:grid; place-items:center; font-size:12px; position:relative}
    .cell.start{background:#d1f7c4}
    .cell.goal{background:#cde7ff}
    .cell.event{background:#fff4cc}
    .cell.penalty{background:#ffe0e0}
    .cell.bonus{background:#e8ffea}
    .cell .idx{position:absolute; top:4px; left:6px; font-size:10px; color:#999}

    /* ===== Tokens ===== */
    .token{width:28px; height:28px; border-radius:50%; border:2px solid #333; display:grid; place-items:center; color:#fff; font-size:12px; font-weight:700; box-shadow:0 4px 10px rgba(0,0,0,.15); transition:transform .18s ease}
    .token.finished{opacity:.6; border-color:#777}
    .token.active{outline:3px solid rgba(76,154,255,.5)}

    /* ===== Sidebar ===== */
    .sidebar{background:#fff; border:2px solid #eee; border-radius:12px; padding:12px; display:grid; gap:12px; height:fit-content}
    .stat{display:flex; justify-content:space-between; gap:8px; padding:8px 10px; background:#f5f7fa; border-radius:10px}
    .players{display:grid; gap:8px}
    .player-row{display:grid; grid-template-columns:1.6fr .8fr 1fr .8fr; gap:8px; align-items:center; padding:8px 10px; background:#fafcff; border:1px solid #eee; border-radius:10px}
    .player-row.active{border-color:var(--active); box-shadow:0 0 0 2px rgba(76,154,255,.2) inset}
    .badge{width:18px; height:18px; border-radius:50%; border:2px solid #333; display:inline-block; margin-right:6px}
    .money{justify-self:end; font-weight:700; transition:color 240ms ease, transform 240ms ease}
    .money.flash-plus{color:#0a7a2d; transform:scale(1.06)}
    .money.flash-minus{color:#b00020; transform:scale(.96)}

    .log{border:1px solid #eee; border-radius:10px; background:#fafcff; padding:10px; max-height:260px; overflow:auto; font-size:13px; line-height:1.4}
    .log p{margin:0 0 6px}
    .log p.ok{color:var(--ok)}
    .log p.bad{color:var(--bad)}
    .footer{font-size:12px; color:#777}

    /* ===== Modal ===== */
    dialog.modal{border:none; border-radius:12px; padding:0; width:min(92vw,760px)}
    .card{padding:16px; border-radius:12px; background:#fff}
    .card h3{margin:0 0 6px}
    .card p{margin:0 0 8px}
    .card .muted{color:#64748b; font-size:12px}
    .card .actions{display:flex; justify-content:flex-end; gap:8px; margin-top:12px}
    .card .actions button{min-width:84px}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e5e7eb; padding:8px; text-align:left}
    th{background:#f8fafc}

    /* ===== Settings / Persona Manager ===== */
    .settings-list{display:grid; gap:8px; margin-top:8px}
    .settings-row{display:flex; gap:8px; align-items:center}
    .settings-row select[type="text"]{flex:1}
    .settings-row input[type="color"]{width:44px; height:34px; padding:4px}
    .persona-table{width:100%; border-collapse:collapse; margin-top:8px}
    .persona-table th, .persona-table td{border:1px solid #e5e7eb; padding:6px}
    .small{font-size:13px; color:#666}
    .muted-row{color:#666; font-size:13px}
    .choice-row{display:flex; gap:6px; align-items:center; margin-bottom:6px}
    .choice-row input[type="number"]{width:84px}
    .choice-row input[type="text"]{flex:1}
    .branch-editor { display:grid; gap:8px; }
    .choices-list{border:1px dashed #ddd; padding:8px; border-radius:8px; max-height:260px; overflow:auto}
  </style>
</head>
<body>
  <!-- App Bar -->
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title">人生ゲーム ver-4</div>
      <div class="group"><label for="players-count">人数</label><select id="players-count"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option></select></div>
      <div class="group"><label for="initial-money">初期資金</label><input id="initial-money" type="number" value="20000" min="0" step="1000" /></div>
      <div class="group"><label for="rng-seed">シード</label><input id="rng-seed" type="text" placeholder="任意(空=ランダム)" /></div>
      <div class="group"><label for="speed">速度</label><input id="speed" type="range" min="80" max="400" value="180" /></div>
      <div class="group"><label for="overshoot">ゴール超過</label><select id="overshoot"><option value="clamp" selected>止まる</option><option value="bounce">反射</option></select></div>
      <div class="dice" id="dice" aria-live="polite" aria-atomic="true">-</div>
      <button id="btn-start" class="primary">開始</button>
      <button id="btn-roll" disabled>サイコロ</button>
      <button id="btn-reset">リセット</button>
      <button id="btn-save" title="ローカルに保存">保存</button>
      <button id="btn-load" title="保存から読込">読込</button>
      <button id="btn-export" title="JSONエクスポート">Export</button>
      <input id="file-import" type="file" accept="application/json" hidden />
      <button id="btn-import" title="JSONインポート">Import</button>
      <button id="btn-settings" title="プレイヤー設定">設定</button>
      <button id="btn-import-personas" title="ペルソナJSONを読み込む">ペルソナ読み込み</button>
      <button id="btn-manage-personas" title="ペルソナ管理">ペルソナ管理</button>
      <input id="file-personas" type="file" accept="application/json" hidden />
    </div>
  </div>

  <div class="wrap">
    <main class="board" id="board" aria-label="ボード"></main>
    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>
      <div class="players" id="players-panel"></div>
      <div class="log" id="log" aria-live="polite" aria-atomic="false"></div>
      <div class="footer">Space/Enterでサイコロ。全員がゴールすると結果発表。</div>
    </aside>
  </div>

  <dialog class="modal" id="modal">
    <div class="card">
      <h3 id="modal-title">イベント</h3>
      <p id="modal-text"></p>
      <p class="muted" id="modal-sub"></p>
      <div class="actions" id="modal-actions"><button id="modal-close" class="primary">OK</button></div>
    </div>
  </dialog>

  <dialog class="modal" id="result">
    <div class="card">
      <h3>結果発表</h3>
      <div id="result-body"></div>
      <div class="actions"><button id="result-close" class="primary">閉じる</button></div>
    </div>
  </dialog>

  <!-- 設定モーダル（プレイヤー名・色 / ペルソナ選択） -->
  <dialog class="modal" id="settings-modal" aria-labelledby="settings-title">
    <div class="card">
      <h3 id="settings-title">プレイヤー設定</h3>
      <p class="small">人数は上部の「人数」で切り替え。あらかじめ用意したペルソナから選べます。</p>
      <div id="settings-list" class="settings-list"></div>
      <div class="actions">
        <button id="settings-cancel">キャンセル</button>
        <button id="settings-save" class="primary">保存</button>
      </div>
    </div>
  </dialog>

  <!-- ペルソナ管理モーダル -->
  <dialog class="modal" id="persona-modal" aria-labelledby="persona-title">
    <div class="card">
      <h3 id="persona-title">ペルソナ管理</h3>
      <p class="small">ペルソナを追加・編集・削除できます。イベントはGUIで詳しく編集できます。</p>
      <table class="persona-table" id="persona-table">
        <thead><tr><th>#</th><th>表示名</th><th>色</th><th>イベント（GUI）</th><th>分岐イベント</th><th>アクション</th></tr></thead>
        <tbody id="persona-tbody"></tbody>
      </table>
      <div style="display:flex; gap:8px; margin-top:8px">
        <button id="persona-add">ペルソナ追加</button>
        <button id="persona-save" class="primary">保存</button>
        <button id="persona-export">エクスポート</button>
        <button id="persona-close">閉じる</button>
      </div>
    </div>
  </dialog>

  <!-- 分岐エディタモーダル（リッチ） -->
  <dialog class="modal" id="branch-editor-modal" aria-labelledby="branch-editor-title">
    <div class="card">
      <h3 id="branch-editor-title">分岐イベントエディタ</h3>
      <div id="branch-editor" class="branch-editor">
        <label>イベント本文 (プレイヤーに表示される説明)</label>
        <input id="branch-text" type="text" placeholder="イベントの説明を入力" />
        <div>
          <strong>選択肢</strong>
          <div class="choices-list" id="choices-list"></div>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="branch-add-choice">選択肢を追加</button>
            <button id="branch-preview" class="primary">プレビュー（乱数で判定）</button>
            <div style="flex:1"></div>
            <button id="branch-save" class="primary">保存</button>
            <button id="branch-cancel">キャンセル</button>
          </div>
        </div>
      </div>
    </div>
  </dialog>

  <script>
  // ====== ユーティリティ & DOM refs ======
  const $ = s => document.querySelector(s);
  const boardEl = $("#board"), logEl = $("#log"), diceEl = $("#dice");
  const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
  const playersPanelEl = $("#players-panel");
  const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset");
  const btnSave = $("#btn-save"), btnLoad = $("#btn-load"), btnExport = $("#btn-export"), btnImport = $("#btn-import"), fileImport = $("#file-import");
  const playersCountSel = $("#players-count"), initialMoneyInput = $("#initial-money");
  const rngSeedInput = $("#rng-seed"), speedInput = $("#speed"), overshootSel = $("#overshoot");
  const modal = $("#modal"), modalTitle = $("#modal-title"), modalText = $("#modal-text"), modalSub = $("#modal-sub"), modalActions = $("#modal-actions"), modalClose = $("#modal-close");
  const resultDlg = $("#result"), resultBody = $("#result-body"), resultClose = $("#result-close");
  const settingsBtn = $("#btn-settings"), settingsModal = $("#settings-modal"), settingsListEl = $("#settings-list");
  const settingsSaveBtn = $("#settings-save"), settingsCancelBtn = $("#settings-cancel");
  const btnImportPersonas = $("#btn-import-personas"), filePersonas = $("#file-personas");
  const btnManagePersonas = $("#btn-manage-personas"), personaModal = $("#persona-modal");
  const personaTbody = $("#persona-tbody"), personaAddBtn = $("#persona-add"), personaSaveBtn = $("#persona-save"), personaExportBtn = $("#persona-export"), personaCloseBtn = $("#persona-close");
  const branchEditorModal = $("#branch-editor-modal"), branchTextInput = $("#branch-text"), choicesListEl = $("#choices-list");
  const branchAddChoiceBtn = $("#branch-add-choice"), branchSaveBtn = $("#branch-save"), branchCancelBtn = $("#branch-cancel"), branchPreviewBtn = $("#branch-preview");

  const BOARD_COLS = 8, BOARD_ROWS = 5, TOTAL_CELLS = BOARD_COLS * BOARD_ROWS;
  const PLAYER_COLORS = ["#ff6b6b", "#4c9aff", "#00c853", "#ff8f00", "#9c27b0", "#00acc1"];

  // ==== persona default store ====
  const DEFAULT_PERSONAS = [
    { id:"shinsotsu", displayName:"新卒さん", color:"#ff6b6b", events: [
      { text:"研修で評価されて昇給チャンス+¥15,000", money:15000 },
      { text:"飲み会で交際費-¥5,000", money:-5000 },
    ], branchEvents: [] },
    { id:"chuto", displayName:"中途さん", color:"#4c9aff", events: [
      { text:"即戦力でプロジェクト入り+¥25,000", money:25000 },
      { text:"引越し費用-¥30,000", money:-30000 }
    ], branchEvents: [] },
    { id:"shigodeki", displayName:"しごできさん", color:"#00c853", events: [
      { text:"成果報酬で+¥40,000", money:40000 },
      { text:"過労で病院-¥8,000", money:-8000 }
    ], branchEvents: [] },
    { id:"shacho", displayName:"社長さん", color:"#ff8f00", events: [
      { text:"事業が当たって大儲け+¥100,000", money:100000 },
      { text:"投資の失敗-¥60,000", money:-60000 }
    ], branchEvents: [] },
  ];

  // personasStore holds full persona objects
  let personasStore = [];
  let PERSONAS = []; // displayName list
  let personaEventMap = {}; // displayName -> events[]
  let personaBranchMap = {}; // displayName -> branchEvents[]

  // RNG support
  function createRNG(seed){
    if(!seed) return Math.random;
    let h = 2166136261 >>> 0;
    for (let i=0;i<seed.length;i++){ h ^= seed.charCodeAt(i); h = Math.imul(h, 16777619); }
    return () => { h += 0x6D2B79F5; let t = Math.imul(h ^ h>>>15, 1 | h); t ^= t + Math.imul(t ^ t>>>7, 61 | t); return ((t ^ t>>>14) >>> 0) / 4294967296; };
  }
  const randPick = (rng, arr)=> arr[Math.floor(rng()*arr.length)];
  const yen = n => "¥" + n.toLocaleString("ja-JP");
  const sleep = ms => new Promise(res=>setTimeout(res, ms));

  // board cells
  const cells = Array.from({length:TOTAL_CELLS},(_,i)=>({index:i,type:"none",label:""}));
  cells[0] = {index:0,type:"start",label:"スタート"};
  cells[TOTAL_CELLS-1] = {index:TOTAL_CELLS-1,type:"goal",label:"ゴール"};
  const mark = (idxs, type, label)=> idxs.forEach(i=>{cells[i].type=type; cells[i].label=label});
  mark([3,6,9,12,15,18,23,27,31,33], "event", "イベント");
  mark([4,10,16,22,30], "bonus", "ボーナス");
  mark([8,14,20,26,34], "penalty", "ペナルティ");

  const eventTable = [
    { text:"就職おめでとう！初任給で+¥30,000", money:+30000 },
    { text:"家賃の更新で-¥20,000", money:-20000 },
    { text:"副業がバズって+¥50,000", money:+50000 },
    { text:"スマホが壊れて-¥15,000", money:-15000 },
    { text:"推し活で-¥10,000", money:-10000 },
    { text:"奨学金が振り込まれた+¥40,000", money:+40000 },
    { text:"バイト昇給で+¥8,000", money:+8000 },
    { text:"体調不良で病院代-¥5,000", money:-5000 },
    { text:"フリマで売れて+¥6,000", money:+6000 },
    { text:"交通違反で-¥12,000", money:-12000 },
  ];

  const branchEvents = [
    {
      text: "運命の分かれ道を見つけた。直感で選択しよう。",
      choices: [
        { label: "奇跡を信じる（高リスク高リターン）", probGood:0.55,
          success:{ money:80000, move:2, text:"奇跡が起きた！" },
          failure:{ money:-30000, move:0, text:"失敗して損失…" }
        },
        { label: "堅実に進む（小リターン）", probGood:1.0,
          success:{ money:10000, move:1, text:"堅実な前進" }, failure:{ money:0, move:0, text:"" }
        }
      ]
    }
  ];

  const BRANCH_CHANCE = 0.30;

  // state
  const state = {
    started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false,
    rng: Math.random, seed:"", speed:180, overshoot:"clamp",
    playerSettings: []
  };

  // sync helper: populate PERSONAS, personaEventMap, personaBranchMap
  function syncStoresFromPersonasList(list){
    personasStore = list.map(p => ({
      id: p.id || (p.displayName || "p").toLowerCase().replace(/\s+/g,"_")+Math.floor(Math.random()*1000),
      displayName: p.displayName || "未設定",
      color: p.color || PLAYER_COLORS[0],
      events: Array.isArray(p.events) ? p.events.map(ev => ({ text: ev.text||"", money: Number(ev.money)||0 })) : [],
      branchEvents: Array.isArray(p.branchEvents) ? p.branchEvents.map(be => deepClone(be)) : []
    }));
    PERSONAS = personasStore.map(p => p.displayName);
    personaEventMap = {};
    personaBranchMap = {};
    personasStore.forEach(p => {
      personaEventMap[p.displayName] = p.events.slice();
      if(p.branchEvents && p.branchEvents.length) personaBranchMap[p.displayName] = p.branchEvents.slice();
    });
  }

  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // load saved personas or defaults
  (function initPersonas(){
    try{
      const s = localStorage.getItem("imported-personas");
      if(s){
        const data = JSON.parse(s);
        if(data && Array.isArray(data.personas)) { syncStoresFromPersonasList(data.personas); return; }
      }
    }catch(e){}
    syncStoresFromPersonasList(DEFAULT_PERSONAS);
  })();

  // player settings ensure
  function ensurePlayerSettings(count = 4){
    if(!state.playerSettings || !Array.isArray(state.playerSettings)) state.playerSettings = [];
    for(let i=0;i<count;i++){
      if(!state.playerSettings[i]) {
        state.playerSettings[i] = { persona: PERSONAS[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length] };
      }
    }
    state.playerSettings.length = count;
  }

  // board helpers
  function indexToGrid(index){
    const row = Math.floor(index/BOARD_COLS);
    let col = index % BOARD_COLS;
    if(row % 2 === 1) col = BOARD_COLS-1-col;
    return {row, col};
  }

  function renderBoard(){
    boardEl.style.setProperty("--board-cols", BOARD_COLS);
    boardEl.style.setProperty("--board-rows", BOARD_ROWS);
    boardEl.innerHTML = "";
    cells.forEach(cell=>{
      const div = document.createElement("div");
      div.className = "cell "+(cell.type!="none"?cell.type:"");
      div.dataset.index = String(cell.index);
      const idx = document.createElement("div"); idx.className = "idx"; idx.textContent = String(cell.index); div.appendChild(idx);
      const label = document.createElement("div"); label.textContent = cell.label||""; div.appendChild(label);
      const {row,col} = indexToGrid(cell.index); div.style.gridRowStart = row+1; div.style.gridColumnStart = col+1;
      boardEl.appendChild(div);
    });
    state.players.forEach((pl,i)=>{
      const token=document.createElement("div"); token.className="token"; token.id=tokenId(i); token.textContent=String(i+1); token.style.background=pl.color; if(pl.finished) token.classList.add("finished");
      token.style.position = "absolute"; token.style.left = "0px"; token.style.top = "0px";
      boardEl.appendChild(token);
    });
    placeAllTokens(); highlightActiveToken();
  }

  function tokenId(i){ return `token-${i}` }

  function placeAllTokens(){
    const groups = new Map();
    state.players.forEach((pl,i)=>{
      if(!groups.has(pl.position)) groups.set(pl.position, []);
      groups.get(pl.position).push(i);
    });
    groups.forEach((idxs, pos)=>{
      const targetCell = boardEl.querySelector(`.cell[data-index="${pos}"]`);
      if(!targetCell) return;
      const rectBoard = boardEl.getBoundingClientRect();
      const rc = targetCell.getBoundingClientRect();
      const cx = rc.left - rectBoard.left + rc.width/2; const cy = rc.top - rectBoard.top + rc.height/2;
      const r = Math.min(rc.width, rc.height) / 3.2;
      const n = idxs.length; const baseAngle = -90;
      idxs.forEach((pi, k)=>{
        const angle = baseAngle + (n===1?0: (k-(n-1)/2) * 30);
        const rad = angle * Math.PI / 180;
        const x = cx + r * Math.cos(rad) - 14; const y = cy + r * Math.sin(rad) - 14;
        const t = $("#"+tokenId(pi)); if(t) t.style.transform = `translate(${x}px, ${y}px)`;
      });
    });
  }

  function highlightActiveToken(){
    state.players.forEach((_,i)=>{
      const t=$("#"+tokenId(i)); if(!t) return; if(i===state.currentPlayerIndex) t.classList.add("active"); else t.classList.remove("active");
    });
  }

  // sidebar
  function moneyId(i){return `money-${i}`}
  function renderPlayersPanel(){
    playersPanelEl.innerHTML="";
    state.players.forEach((pl,i)=>{
      const row=document.createElement("div"); row.className="player-row"+(i===state.currentPlayerIndex?" active":"");
      const name=document.createElement("div");
      const badge=document.createElement("span"); badge.className="badge"; badge.style.background=pl.color; name.appendChild(badge);
      const nameText=document.createElement("span"); nameText.textContent = pl.name + (pl.finished?"（ゴール）":""); name.appendChild(nameText);
      const pos=document.createElement("div"); pos.textContent = "位置: "+pl.position;
      const money=document.createElement("div"); money.className="money"; money.id=moneyId(i); money.textContent=yen(pl.money);
      const status=document.createElement("div"); status.textContent = pl.skipTurn?"次ターン休み":"";
      row.appendChild(name); row.appendChild(pos); row.appendChild(money); row.appendChild(status);
      playersPanelEl.appendChild(row);
    });
  }
  function flashMoney(i,delta){ const el=$("#"+moneyId(i)); if(!el) return; const cls=delta>=0?"flash-plus":"flash-minus"; el.classList.add(cls); setTimeout(()=>el.classList.remove(cls), 400) }

  // log
  function pushLog(text, kind){ const p=document.createElement("p"); p.textContent=text; if(kind) p.classList.add(kind); logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight; }

  // modal simple
  function showCard(title, text, sub){
    modalTitle.textContent = title;
    modalText.textContent = text;
    modalSub.textContent = sub || "";
    modalActions.innerHTML = "";
    const ok = document.createElement("button"); ok.id = "modal-close"; ok.className = "primary"; ok.textContent = "OK";
    ok.addEventListener("click", ()=> modal.close());
    modalActions.appendChild(ok);
    modal.showModal();
  }
  modalClose.addEventListener("click", ()=> modal.close());

  // Branch modal renderer for gameplay: uses new choice structure
  function showBranchModal(branchEv, playerIndex){
    modalTitle.textContent = "分岐イベント";
    modalText.textContent = branchEv.text;
    modalSub.textContent = `あなた: ${state.players[playerIndex].name}`;
    modalActions.innerHTML = "";

    branchEv.choices.forEach((choice, idx)=>{
      const btn = document.createElement("button");
      btn.textContent = choice.label;
      btn.addEventListener("click", async ()=>{
        const prob = (typeof choice.probGood === "number") ? choice.probGood : 1.0;
        const success = state.rng() < prob;
        const pl = state.players[playerIndex];
        const res = success ? (choice.success || {}) : (choice.failure || {});
        // money
        if(typeof res.money === "number" && res.money !== 0){ pl.money += res.money; flashMoney(playerIndex, res.money); }
        // log with custom text if provided else default
        const text = success ? (res.text || `${choice.label} → 成功`) : (res.text || `${choice.label} → 失敗`);
        pushLog(`${pl.name}: ${text} ${res.money ? `(${res.money>0?'+':''}${yen(res.money)})` : ""}`, success ? "ok" : "bad");
        // move
        if(typeof res.move === "number" && res.move !== 0){
          if(res.move > 0){
            await animateMove(playerIndex, res.move);
          } else {
            pl.position = Math.max(0, pl.position + res.move);
            placeAllTokens();
            resolveCell(playerIndex, pl.position);
          }
        } else {
          renderPlayersPanel();
        }
        modal.close();
      });
      modalActions.appendChild(btn);
    });
    const cancel = document.createElement("button");
    cancel.textContent = "やめる";
    cancel.addEventListener("click", ()=> modal.close());
    modalActions.appendChild(cancel);
    modal.showModal();
  }

  // resolveCell uses personaBranchMap with new branch structure
  function resolveCell(playerIndex, index){
    const pl = state.players[playerIndex]; const cell = cells[index]; if(!cell||!pl) return;
    switch(cell.type){
      case "start": pushLog(`${pl.name}: スタート！`, "ok"); break;
      case "goal":
        if(!pl.finished){
          pl.finished = true; state.finishedCount += 1; $("#"+tokenId(playerIndex))?.classList.add("finished");
          pushLog(`${pl.name}: ゴール！お疲れ！`);
          showCard("ゴール", `${pl.name} がゴール！`, `現在残高: ${yen(pl.money)}`);
        }
        break;
      case "bonus":{
        const amount = randPick(state.rng, [5000,8000,10000,15000,20000]); pl.money += amount; flashMoney(playerIndex, amount);
        pushLog(`${pl.name}: ボーナス！${yen(amount)}獲得（残高: ${yen(pl.money)}）`, "ok"); break;
      }
      case "penalty":{
        const amount = randPick(state.rng, [5000,8000,10000,15000,20000]); pl.money -= amount; flashMoney(playerIndex, -amount);
        pushLog(`${pl.name}: ペナルティ…${yen(amount)}失う（残高: ${yen(pl.money)}）`, "bad"); break;
      }
      case "event":{
        // branch chance
        if(state.rng() < BRANCH_CHANCE){
          const pb = personaBranchMap[pl.name];
          if(pb && pb.length > 0){
            const be = randPick(state.rng, pb);
            showBranchModal(be, playerIndex);
            return;
          } else {
            const be = randPick(state.rng, branchEvents);
            showBranchModal(be, playerIndex);
            return;
          }
        }
        // persona events
        const personaEvents = personaEventMap[pl.name];
        if(personaEvents && personaEvents.length>0 && state.rng() < 0.7){
          const ev = randPick(state.rng, personaEvents);
          pl.money += ev.money; flashMoney(playerIndex, ev.money);
          pushLog(`${pl.name}: ${ev.text}（残高: ${yen(pl.money)}）`, ev.money>=0?"ok":"bad");
          renderPlayersPanel();
          if(state.rng() < 0.10){ pl.skipTurn = true; pushLog(`${pl.name}: 次のターンはお休み（スキップ）`); }
          showCard("イベント", ev.text, `${pl.name} / 残高: ${yen(pl.money)}`);
          return;
        }
        // fallback
        const ev = randPick(state.rng, eventTable);
        pl.money += ev.money; flashMoney(playerIndex, ev.money);
        pushLog(`${pl.name}: ${ev.text}（残高: ${yen(pl.money)}）`, ev.money>=0?"ok":"bad");
        if(state.rng() < 0.10){ pl.skipTurn = true; pushLog(`${pl.name}: 次のターンはお休み（スキップ）`); }
        showCard("イベント", ev.text, `${pl.name} / 残高: ${yen(pl.money)}`);
        break;
      }
    }
    renderPlayersPanel();
  }

  // dice + move
  function rollDice(){ const n = Math.floor(state.rng()*6)+1; diceEl.textContent = n; diceEl.classList.add("spin"); setTimeout(()=>diceEl.classList.remove("spin"), 620); return n; }

  async function animateMove(playerIndex, steps){
    const pl = state.players[playerIndex]; if(!pl || pl.finished) return;
    state.animating = true; btnRoll.disabled = true; const delay = Number(speedInput.value || state.speed);
    let pos = pl.position; let remain = steps;
    while(remain>0){
      let next = pos + 1;
      if(next >= TOTAL_CELLS-1){
        if(state.overshoot === "clamp"){ next = TOTAL_CELLS-1; pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); break; }
        else {
          const extra = remain - 1 - ((TOTAL_CELLS-1) - pos - 1);
          pos = TOTAL_CELLS-1; pl.position = pos; placeAllTokens(); await sleep(delay);
          for(let b=0; b<extra; b++){ pos -= 1; pl.position = pos; placeAllTokens(); await sleep(delay); }
          remain = 0; break;
        }
      }
      pos = next; pl.position = pos; placeAllTokens(); await sleep(delay); remain--;
    }
    resolveCell(playerIndex, pl.position);
    state.animating = false;
  }

  function nextPlayerTurn(){
    const total = state.players.length; let i = state.currentPlayerIndex;
    for(let c=0;c<total;c++){ i=(i+1)%total; const p=state.players[i]; if(!p.finished){ state.currentPlayerIndex=i; break; } }
    highlightActiveToken(); renderPlayersPanel(); statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
  }
  const isGameFinished = ()=> state.finishedCount === state.players.length;

  // result
  function openResult(){
    const rows = state.players.map((p,i)=>({i, name:p.name, money:p.money})).sort((a,b)=> b.money-a.money);
    let html = `<table><thead><tr><th>順位</th><th>プレイヤー</th><th>所持金</th><th>差額</th></tr></thead><tbody>`;
    const top = rows[0]?.money ?? 0;
    rows.forEach((r,idx)=>{ const diff = r.money - top; html += `<tr><td>${idx+1}</td><td>${r.name}</td><td>${yen(r.money)}</td><td>${diff===0?"-":yen(diff)}</td></tr>`; });
    html += `</tbody></table>`;
    resultBody.innerHTML = html; resultDlg.showModal();
  }
  resultClose.addEventListener("click", ()=> resultDlg.close());

  // save/load
  const SAVE_KEY = "life-game-save-v4-persona";
  function snapshot(){ return JSON.stringify({
    started:state.started, turn:state.turn, currentPlayerIndex:state.currentPlayerIndex, finishedCount:state.finishedCount,
    players:state.players, seed:state.seed, overshoot:state.overshoot, speed:Number(speedInput.value||state.speed),
    playerSettings: state.playerSettings, personas: personasStore
  }); }
  function restore(json){ try{
    const d = JSON.parse(json);
    state.started = d.started; state.turn = d.turn; state.currentPlayerIndex = d.currentPlayerIndex; state.finishedCount = d.finishedCount;
    state.players = d.players; state.seed = d.seed||""; state.overshoot = d.overshoot||"clamp"; state.rng = createRNG(state.seed||"");
    speedInput.value = String(d.speed||180); overshootSel.value = state.overshoot; rngSeedInput.value = state.seed;
    state.playerSettings = d.playerSettings || [];
    if(Array.isArray(d.personas)) { syncStoresFromPersonasList(d.personas); }
    renderBoard(); renderPlayersPanel(); statTurnEl.textContent = String(state.turn); statCurrentEl.textContent = state.players[state.currentPlayerIndex]?.name || "-";
    pushLog("保存データを読み込みました。", "ok");
  }catch(e){ alert("読み込みに失敗しました"); }}

  btnSave.addEventListener("click", ()=>{ localStorage.setItem(SAVE_KEY, snapshot()); pushLog("保存しました", "ok"); });
  btnLoad.addEventListener("click", ()=>{ const s=localStorage.getItem(SAVE_KEY); if(!s) return alert("保存がありません"); restore(s); });
  btnExport.addEventListener("click", ()=>{
    const blob = new Blob([snapshot()], {type:"application/json"});
    const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href=url; a.download="life-game-save.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });
  btnImport.addEventListener("click", ()=> fileImport.click());
  fileImport.addEventListener("change", async e=>{ const f=e.target.files?.[0]; if(!f) return; const txt = await f.text(); restore(txt); fileImport.value=""; });

  // persona JSON import
  function validatePersonaJSON(data){
    if(!data || typeof data !== "object") return "JSONがオブジェクトではありません";
    if(!Array.isArray(data.personas)) return "personas 配列がありません";
    for(const p of data.personas){
      if(typeof p.displayName !== "string") return "personas[].displayName が文字列ではありません";
    }
    return null;
  }
  btnImportPersonas.addEventListener("click", ()=> filePersonas.click());
  filePersonas.addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      const json = JSON.parse(txt);
      const err = validatePersonaJSON(json);
      if(err) return alert("読み込みエラー: " + err);
      const merged = personasStore.concat(json.personas);
      syncStoresFromPersonasList(merged);
      try { localStorage.setItem("imported-personas", JSON.stringify({ personas: personasStore })); } catch(e){}
      buildSettingsForm();
      pushLog("ペルソナを読み込みました: " + json.personas.map(x=>x.displayName).join(", "), "ok");
    }catch(err){
      console.error(err);
      alert("読み込みに失敗しました（JSONの形式を確認してください）");
    } finally {
      filePersonas.value = "";
    }
  });

  // Persona manager UI
  function openPersonaManager(){ renderPersonaTable(); personaModal.showModal(); }
  function renderPersonaTable(){
    personaTbody.innerHTML = "";
    personasStore.forEach((p, idx) => {
      const tr = document.createElement("tr");
      const tdIdx = document.createElement("td"); tdIdx.textContent = String(idx+1);
      const tdName = document.createElement("td"); const nameInput = document.createElement("input"); nameInput.type="text"; nameInput.value=p.displayName; nameInput.dataset.idx=idx; tdName.appendChild(nameInput);
      const tdColor = document.createElement("td"); const colorInput = document.createElement("input"); colorInput.type="color"; colorInput.value=p.color; colorInput.dataset.idx=idx; tdColor.appendChild(colorInput);
      const tdEvents = document.createElement("td");
      const evEditorBtn = document.createElement("button"); evEditorBtn.textContent = "イベント編集"; evEditorBtn.dataset.idx=idx;
      evEditorBtn.addEventListener("click", ()=> openPersonaEventEditor(idx));
      tdEvents.appendChild(evEditorBtn);
      const tdBranches = document.createElement("td");
      const brEditorBtn = document.createElement("button"); brEditorBtn.textContent = "分岐編集"; brEditorBtn.dataset.idx=idx;
      brEditorBtn.addEventListener("click", ()=> openBranchEditorForPersona(idx));
      tdBranches.appendChild(brEditorBtn);
      const tdAction = document.createElement("td");
      const delBtn = document.createElement("button"); delBtn.textContent = "削除"; delBtn.dataset.idx=idx;
      delBtn.addEventListener("click", ()=> {
        if(!confirm(`"${p.displayName}" を削除してよいですか？`)) return;
        personasStore.splice(idx,1);
        syncStoresFromPersonasList(personasStore);
        renderPersonaTable();
      });
      tdAction.appendChild(delBtn);

      tr.appendChild(tdIdx); tr.appendChild(tdName); tr.appendChild(tdColor); tr.appendChild(tdEvents); tr.appendChild(tdBranches); tr.appendChild(tdAction);
      personaTbody.appendChild(tr);
    });
  }

  // Simple persona event editor: opens a prompt-like editor for events list (kept small)
  function openPersonaEventEditor(idx){
    const persona = personasStore[idx];
    const current = persona.events.map(ev => `${ev.text}|${ev.money}`).join("\n");
    const res = prompt("イベントを1行ごとに入力: テキスト|金額", current);
    if(res===null) return;
    const events = res.split("\n").map(l=>l.trim()).filter(l=>l).map(l=>{
      const parts = l.split("|");
      return { text: (parts[0]||"").trim(), money: Number((parts[1]||"0").replace(/[^\d\-]/g,'')) || 0 };
    });
    persona.events = events;
    syncStoresFromPersonasList(personasStore);
    pushLog(`${persona.displayName} のイベントを更新しました`, "ok");
  }

  // Branch editor for persona: open editor modal and edit persona.branchEvents
  let currentEditingPersonaIndex = null;
  let editingBranchIndex = null; // which branch in persona we edit; null => new
  function openBranchEditorForPersona(personaIdx, branchIdx = null){
    currentEditingPersonaIndex = personaIdx;
    editingBranchIndex = branchIdx;
    const persona = personasStore[personaIdx];
    const branch = (branchIdx!==null && persona.branchEvents[branchIdx]) ? deepClone(persona.branchEvents[branchIdx]) : { text: "", choices: [] };
    openBranchEditor(branch, (updatedBranch) => {
      if(branchIdx === null){
        persona.branchEvents.push(updatedBranch);
      } else {
        persona.branchEvents[branchIdx] = updatedBranch;
      }
      syncStoresFromPersonasList(personasStore);
      renderPersonaTable();
      pushLog(`${persona.displayName} の分岐イベントを保存しました`, "ok");
    });
  }

  // Branch Editor Modal: builds UI inside branch-editor modal and calls onSave(updatedBranch)
  let branchEditorSaveCallback = null;
  function openBranchEditor(branch, onSave){
    branchEditorSaveCallback = onSave;
    branchTextInput.value = branch.text || "";
    renderChoicesList(branch.choices || []);
    branchEditorModal.showModal();

    // wire save/cancel
    branchSaveBtn.onclick = () => {
      const updated = {
        text: branchTextInput.value.trim(),
        choices: readChoicesFromUI()
      };
      branchEditorModal.close();
      if(branchEditorSaveCallback) branchEditorSaveCallback(updated);
    };
    branchCancelBtn.onclick = () => { branchEditorModal.close(); };
    branchAddChoiceBtn.onclick = ()=> {
      addChoiceUI({ label:"新しい選択肢", probGood:0.5, success:{money:0,move:0,text:"成功"}, failure:{money:0,move:0,text:"失敗"} });
    };
    branchPreviewBtn.onclick = ()=> {
      // simulate random choice selection and result
      const choices = readChoicesFromUI();
      if(!choices.length) return alert("選択肢がありません");
      const idx = Math.floor(Math.random()*choices.length);
      const c = choices[idx];
      const success = Math.random() < (typeof c.probGood==="number"?c.probGood:1.0);
      const res = success ? c.success : c.failure;
      alert(`選択: ${c.label}\n判定: ${success? "成功":"失敗"}\n結果: ${res.text || "(説明なし)"}\n所持金変化: ${res.money ? res.money : 0}\n移動: ${res.move ? res.move : 0}`);
    };
  }

  function renderChoicesList(choices){
    choicesListEl.innerHTML = "";
    choices.forEach((c, i) => addChoiceUI(c));
  }

  function addChoiceUI(choice){
    const idx = choicesListEl.children.length;
    const row = document.createElement("div"); row.className = "choice-row"; row.dataset.idx = idx;
    const labelInput = document.createElement("input"); labelInput.type = "text"; labelInput.value = choice.label||""; labelInput.placeholder="選択肢ラベル";
    const probInput = document.createElement("input"); probInput.type = "number"; probInput.step = "0.05"; probInput.min="0"; probInput.max="1"; probInput.value = typeof choice.probGood==="number"?String(choice.probGood):"1";
    const successMoney = document.createElement("input"); successMoney.type="number"; successMoney.value = (choice.success && typeof choice.success.money==="number")?choice.success.money:0;
    const successMove = document.createElement("input"); successMove.type="number"; successMove.value = (choice.success && typeof choice.success.move==="number")?choice.success.move:0;
    const successText = document.createElement("input"); successText.type="text"; successText.value = (choice.success && choice.success.text) ? choice.success.text : "";
    successText.placeholder = "成功時テキスト";
    const failMoney = document.createElement("input"); failMoney.type="number"; failMoney.value = (choice.failure && typeof choice.failure.money==="number")?choice.failure.money:0;
    const failMove = document.createElement("input"); failMove.type="number"; failMove.value = (choice.failure && typeof choice.failure.move==="number")?choice.failure.move:0;
    const failText = document.createElement("input"); failText.type="text"; failText.value = (choice.failure && choice.failure.text) ? choice.failure.text : "";
    failText.placeholder = "失敗時テキスト";
    const delBtn = document.createElement("button"); delBtn.textContent = "削除";
    delBtn.addEventListener("click", ()=> { row.remove(); reindexChoicesUI(); });
    const previewBtn = document.createElement("button"); previewBtn.textContent = "プレビュー";
    previewBtn.addEventListener("click", ()=>{
      const prob = Number(probInput.value) || 0;
      const success = Math.random() < prob;
      const res = success ? { money: Number(successMoney.value)||0, move: Number(successMove.value)||0, text: successText.value } : { money: Number(failMoney.value)||0, move: Number(failMove.value)||0, text: failText.value };
      alert(`選択: ${labelInput.value}\n判定: ${success? "成功":"失敗"}\n${res.text || ""}\n所持金変化: ${res.money}\n移動: ${res.move}`);
    });

    // layout: [label][prob][sMoney][sMove][sText][fMoney][fMove][fText][preview][del]
    row.appendChild(labelInput);
    row.appendChild(probInput);
    row.appendChild(successMoney);
    row.appendChild(successMove);
    row.appendChild(successText);
    row.appendChild(failMoney);
    row.appendChild(failMove);
    row.appendChild(failText);
    row.appendChild(previewBtn);
    row.appendChild(delBtn);
    choicesListEl.appendChild(row);
  }

  function reindexChoicesUI(){ /* no-op for now; used if needed */ }

  function readChoicesFromUI(){
    const rows = choicesListEl.querySelectorAll(".choice-row");
    const out = [];
    rows.forEach(r=>{
      const inputs = r.querySelectorAll("input");
      // inputs order: label, prob, sMoney, sMove, sText, fMoney, fMove, fText
      const label = inputs[0]?.value || "選択肢";
      const prob = Number(inputs[1]?.value) || 0;
      const sMoney = Number(inputs[2]?.value) || 0;
      const sMove = Number(inputs[3]?.value) || 0;
      const sText = inputs[4]?.value || "";
      const fMoney = Number(inputs[5]?.value) || 0;
      const fMove = Number(inputs[6]?.value) || 0;
      const fText = inputs[7]?.value || "";
      out.push({
        label,
        probGood: prob,
        success: { money: sMoney, move: sMove, text: sText },
        failure: { money: fMoney, move: fMove, text: fText }
      });
    });
    return out;
  }

  // persona manager buttons
  personaAddBtn.addEventListener("click", ()=>{
    const newPersona = { id:`p${Date.now()}`, displayName:`ペルソナ${personasStore.length+1}`, color: PLAYER_COLORS[personasStore.length % PLAYER_COLORS.length], events: [], branchEvents: [] };
    personasStore.push(newPersona);
    syncStoresFromPersonasList(personasStore);
    renderPersonaTable();
  });

  personaCloseBtn.addEventListener("click", ()=> personaModal.close());

  personaSaveBtn.addEventListener("click", ()=>{
    // read table inputs and update personasStore
    const rows = personaTbody.querySelectorAll("tr");
    rows.forEach((tr, idx) => {
      const nameInput = tr.querySelector('input[type="text"]');
      const colorInput = tr.querySelector('input[type="color"]');
      const name = nameInput?.value?.trim() || `ペルソナ${idx+1}`;
      const color = colorInput?.value || PLAYER_COLORS[idx % PLAYER_COLORS.length];
      if(!personasStore[idx]) personasStore[idx] = { id:`p${Date.now()}${idx}`, displayName:name, color, events: [], branchEvents: [] };
      else {
        personasStore[idx].displayName = name;
        personasStore[idx].color = color;
      }
    });
    syncStoresFromPersonasList(personasStore);
    try { localStorage.setItem("imported-personas", JSON.stringify({ personas: personasStore })); } catch(e){}
    buildSettingsForm();
    pushLog("ペルソナを保存しました", "ok");
    personaModal.close();
  });

  personaExportBtn.addEventListener("click", ()=>{
    const data = { personas: personasStore };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = "personas-export.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // open manager
  $("#btn-manage-personas").addEventListener("click", ()=> openPersonaManager());

  // settings modal
  function buildSettingsForm(){
    const count = parseInt(playersCountSel.value,10) || 4;
    ensurePlayerSettings(count);
    settingsListEl.innerHTML = "";
    for(let i=0;i<count;i++){
      const s = state.playerSettings[i] || { persona: PERSONAS[i] || `プレイヤー${i+1}`, color:PLAYER_COLORS[i % PLAYER_COLORS.length] };
      const row = document.createElement("div"); row.className = "settings-row";
      const idx = document.createElement("div"); idx.textContent = `${i+1}`; idx.style.width = "24px"; idx.style.textAlign = "center"; idx.style.fontWeight = "700";
      const personaSelect = document.createElement("select");
      PERSONAS.forEach(p => {
        const opt = document.createElement("option"); opt.value = p; opt.textContent = p; personaSelect.appendChild(opt);
      });
      personaSelect.value = s.persona || PERSONAS[i] || `プレイヤー${i+1}`;
      const colorInput = document.createElement("input"); colorInput.type = "color"; colorInput.value = s.color || PLAYER_COLORS[i % PLAYER_COLORS.length];
      row.appendChild(idx); row.appendChild(personaSelect); row.appendChild(colorInput);
      settingsListEl.appendChild(row);
    }
  }

  function openSettings(){ buildSettingsForm(); settingsModal.showModal(); }
  settingsBtn.addEventListener("click", ()=> openSettings());
  settingsCancelBtn.addEventListener("click", ()=> settingsModal.close());
  settingsSaveBtn.addEventListener("click", ()=>{
    const rows = settingsListEl.querySelectorAll(".settings-row");
    rows.forEach((row, idx)=>{
      const personaSelect = row.querySelector('select');
      const colorInput = row.querySelector('input[type="color"]');
      const persona = personaSelect?.value || PERSONAS[idx] || `プレイヤー${idx+1}`;
      const color = colorInput?.value || PLAYER_COLORS[idx % PLAYER_COLORS.length];
      state.playerSettings[idx] = { persona, color };
    });
    if(state.started && state.players && state.players.length > 0){
      for(let i=0;i<state.players.length;i++){
        const s = state.playerSettings[i];
        if(!s) continue;
        state.players[i].name = s.persona;
        state.players[i].color = s.color;
      }
      renderBoard();
      renderPlayersPanel();
      pushLog("プレイヤー設定を更新しました。", "ok");
    } else {
      pushLog("プレイヤー設定を保存しました。", "ok");
    }
    settingsModal.close();
  });

  // start/reset/roll
  btnStart.addEventListener("click", ()=>{
    if(state.started) return;
    const count = parseInt(playersCountSel.value,10); const initial = parseInt(initialMoneyInput.value,10)||0;
    const seed = (rngSeedInput.value||"").trim(); state.seed = seed; state.rng = createRNG(seed);
    ensurePlayerSettings(count);
    state.players = Array.from({length:count},(_,i)=>{
      const s = state.playerSettings[i] || { persona: PERSONAS[i] || `プレイヤー${i+1}`, color: PLAYER_COLORS[i % PLAYER_COLORS.length] };
      return { name: s.persona, color: s.color, position:0, money:initial, finished:false, skipTurn:false };
    });
    state.started=true; state.turn=1; state.currentPlayerIndex=0; state.finishedCount=0; state.overshoot = overshootSel.value; state.speed = Number(speedInput.value||180);
    pushLog(`ゲーム開始！初期資金: ${yen(initial)} | プレイヤー数: ${count} ${seed?`| シード:${seed}`:""}`, "ok");
    renderBoard(); renderPlayersPanel(); statTurnEl.textContent=String(state.turn); statCurrentEl.textContent=state.players[state.currentPlayerIndex].name; btnRoll.disabled=false; diceEl.textContent='-';
  });

  btnReset.addEventListener("click", ()=>{
    Object.assign(state, {started:false, turn:0, currentPlayerIndex:0, players:[], finishedCount:0, animating:false});
    btnRoll.disabled=true; logEl.innerHTML=""; statTurnEl.textContent="0"; statCurrentEl.textContent="-"; diceEl.textContent='-';
    renderBoard(); playersPanelEl.innerHTML=""; pushLog("リセットしました");
  });

  btnRoll.addEventListener("click", async ()=>{
    if(!state.started || state.animating) return;
    const pl = state.players[state.currentPlayerIndex]; if(!pl || pl.finished){ nextPlayerTurn(); return; }
    if(pl.skipTurn){ pushLog(`${pl.name}: ターンをスキップします`); pl.skipTurn=false; state.turn+=1; statTurnEl.textContent=String(state.turn); nextPlayerTurn(); return; }
    const dice = rollDice(); pushLog(`${pl.name}: サイコロ → ${dice}`);
    const remaining = (TOTAL_CELLS-1) - pl.position; const steps = state.overshoot==="clamp"? Math.min(dice, remaining): dice;
    await animateMove(state.currentPlayerIndex, steps);
    state.turn += 1; statTurnEl.textContent = String(state.turn);
    if(isGameFinished()){ pushLog("全員ゴール！ゲーム終了！"); btnRoll.disabled=true; openResult(); return; }
    nextPlayerTurn(); btnRoll.disabled=false;
  });

  window.addEventListener("keydown", e=>{
    if(e.code==="Space" || e.key==="Enter"){ e.preventDefault(); btnRoll.click(); }
    if(e.key.toLowerCase()==='r' && !state.animating){ btnReset.click(); }
  });

  // initial render
  ensurePlayerSettings(parseInt(playersCountSel.value,10) || 4);
  renderBoard();
  window.addEventListener("resize", ()=> placeAllTokens());
  </script>
</body>
</html>
