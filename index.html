<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Make an impact that matters</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <style>
    :root{
      --black:#000000; --white:#FFFFFF; --green:#86BB27; --green-light:#DFF3C6; --gray:#C4C4C4;
      --cell-size:68px; /* tile size */
      --tile-size: var(--cell-size);
      --tile-gap: 16px; /* baseline gap */
      --board-padding: 24px;
      --token-size:30px;
      --token-move-ms:140ms; /* per-tile move duration */
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      display:flex; flex-direction:column; min-height:100vh; margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      color:var(--black); background:var(--white); font-weight:900;
    }

    /* Appbar */
    .appbar{position:sticky; top:0; z-index:1100; background:var(--white); border-bottom:1px solid rgba(0,0,0,0.06); display:flex; justify-content:center}
    .toolbar{width:100%; max-width:1300px; display:flex; gap:10px; align-items:center; padding:8px}
    .title{font-weight:900; font-size:15px; margin-right:auto; color:var(--black)}
    .group{display:flex; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--gray); border-radius:10px; background:var(--white)}
    select,input[type="text"]{padding:8px 10px; border-radius:8px; border:1px solid var(--gray)}

    button{padding:8px 12px; border-radius:8px; border:1px solid var(--gray); background:var(--white); cursor:pointer}
    button.primary{background:var(--green); color:var(--white); border-color:transparent}
    #btn-roll, #btn-reset{ font-weight:900; }

    .wrap{width:100%; max-width:1300px; margin:18px auto; display:grid; grid-template-columns:3fr 1fr; gap:12px; align-items:start; padding:0 12px}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }

    /* Board */
    .board-wrap{background:var(--white); border:2px solid var(--gray); border-radius:14px; padding:var(--board-padding); position:relative; overflow:auto; min-height:520px}
    .board{
      position:relative; width:100%; height:820px; touch-action:none; /* slightly taller */
      background: linear-gradient(180deg, rgba(0,0,0,0.01), rgba(0,0,0,0.00));
    }

    /* tiles - visible */
    .tile{
      position:absolute;
      width:var(--tile-size);
      height:var(--tile-size);
      background:#f6f8fb; /* light background so tiles are visible on white board */
      border:2px solid rgba(0,0,0,0.06);
      border-radius:8px;
      transform: translate(-50%,-50%);
      display:grid; place-items:center;
      font-weight:900; color:var(--black);
      box-shadow: 0 6px 14px rgba(14,20,25,0.06);
      transition: transform 120ms linear;
      z-index:2;
      font-size:12px;
    }
    .tile:hover{ box-shadow: 0 10px 26px rgba(14,20,25,0.12); }

    /* eventish tiles: green border, no inside text per request */
    .tile.event,
    .tile.client,
    .tile.workshop,
    .tile.bonus,
    .tile.penalty {
      border:3px solid var(--green);
      background:#f7fff6; /* subtle green tint */
    }
    .tile.goal{
      background: var(--green);
      color: #fff;
      border-color: var(--green);
      font-weight:900;
      box-shadow: 0 10px 30px rgba(134,187,39,0.18);
    }

    /* START_MARKER aligned to tile0 and placed slightly above */
    .start-marker{
      position:absolute;
      width:calc(var(--tile-size) * 0.9);
      height:calc(var(--tile-size) * 0.28);
      display:grid; place-items:center;
      border-radius:6px; border:1px solid rgba(0,0,0,0.08);
      color:var(--black); font-weight:900; background:rgba(134,187,39,0.08);
      z-index:6;
      transform: translate(-50%,-125%); /* positioned above the tile */
      pointer-events:none;
      font-size:12px;
    }

    .token{
      position:absolute;
      width:var(--token-size); height:var(--token-size); border-radius:50%; display:grid; place-items:center; color:#fff; font-weight:900;
      border:2px solid #000; transform: translate(-50%,-50%);
      box-shadow:0 8px 20px rgba(0,0,0,0.08);
      pointer-events:none;
      transition: transform var(--token-move-ms) linear;
      z-index:30;
    }
    .token.finished{ opacity:0.85; border-color:var(--gray) }

    .sidebar{border:2px solid var(--gray); border-radius:14px; padding:14px}
    .stat{display:flex; justify-content:space-between; padding:10px; border-radius:10px}
    .players{margin-top:10px}
    .player-row{display:grid; grid-template-columns:1fr 1fr; gap:8px; padding:8px; border-radius:10px; border:1px solid var(--gray); align-items:center}
    .attr-list{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; font-weight:700}
    .log{margin-top:12px; border:1px solid var(--gray); border-radius:10px; padding:10px; max-height:300px; overflow:auto; font-size:13px}

    /* events panel */
    .events-panel{margin-top:12px}
    .events-tabs{display:flex; gap:6px; margin-bottom:8px}
    .events-list{max-height:260px; overflow:auto; border:1px solid #eee; border-radius:8px; padding:6px}
    .event-item{padding:8px; border-bottom:1px dashed #eee; cursor:pointer}
    .event-item:hover{background:#fbfffb}

    /* modal fallback */
    .modal-fallback{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.42); z-index:9999}
    .modal-fallback .card{background:#fff; padding:16px; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,0.12); max-width:720px}
    .event-title{font-weight:900; margin-bottom:8px}
    .event-body{white-space:pre-wrap; margin-bottom:12px; line-height:1.5}
    .event-changes{font-weight:700; color:var(--green)}
    .choice-btn{margin-right:8px}

    /* final results table */
    .results-table{width:100%; border-collapse:collapse; margin-top:8px}
    .results-table th, .results-table td{padding:8px; border-bottom:1px solid #eee; text-align:left; font-weight:700}
    .results-winner{background:linear-gradient(90deg, rgba(134,187,39,0.06), rgba(134,187,39,0.02));}
    .small-muted{font-weight:400; color:#666; font-size:13px}
  </style>
</head>
<body>
  <div class="appbar">
    <div class="toolbar" role="group" aria-label="ゲーム設定">
      <div class="title"><span style="color:var(--green)">M</span>ake an impact that matters</div>

      <div class="group">
        <label for="players-count">人数</label>
        <select id="players-count"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
      </div>

      <div class="group" id="player-names"></div>

      <div class="group" style="margin-left:auto;">
        <div class="dice" id="dice">-</div>
        <button id="btn-start" class="primary">開始</button>
        <button id="btn-roll" disabled>サイコロ</button>
        <button id="btn-results">結果</button>
        <button id="btn-reset">リセット</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="board-wrap">
      <div class="board" id="board" aria-label="ボード">
        <div class="start-marker" id="start-marker">START</div>
      </div>
    </div>

    <aside class="sidebar">
      <div class="stat"><span>ターン</span><strong id="stat-turn">0</strong></div>
      <div class="stat"><span>手番</span><strong id="stat-current">-</strong></div>

      <div class="events-panel" id="events-panel">
        <div class="events-tabs" id="events-tabs"></div>
        <div class="events-list" id="events-list"></div>
      </div>

      <div class="players" id="players-panel"></div>

      <div class="log" id="log" aria-live="polite"></div>
    </aside>
  </div>

  <script>
  (function(){
    // Initialize only after load so board dimensions are correct
    window.addEventListener('load', init);

    // Fully externalized templates: index.html does not embed full templates in A-mode;
    // this repo may have event-templates.json in the root. Fetch is required.
    let EVENT_TEMPLATES = null;

    async function loadEventTemplatesExternal(){
      const res = await fetch('./event-templates.json', { cache: 'no-cache' });
      if(!res.ok) throw new Error('HTTP ' + res.status);
      const json = await res.json();
      if(!json || (!json.junior && !json.mid && !json.senior)) throw new Error('Invalid JSON shape');
      return json;
    }

    function showFatalError(title, body){
      document.body.innerHTML = '';
      const overlay = document.createElement('div');
      overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.display='flex';
      overlay.style.alignItems='center'; overlay.style.justifyContent='center'; overlay.style.background='white';
      const card = document.createElement('div'); card.style.padding='24px'; card.style.maxWidth='720px';
      card.style.borderRadius='12px'; card.style.boxShadow='0 12px 30px rgba(0,0,0,0.12)';
      const h = document.createElement('h2'); h.textContent = title;
      const p = document.createElement('pre'); p.textContent = body; p.style.whiteSpace='pre-wrap'; p.style.marginTop='12px';
      card.appendChild(h); card.appendChild(p); overlay.appendChild(card); document.body.appendChild(overlay);
    }

    // Main init is async to await templates; fatal if not present (A)
    async function init(){
      try{
        EVENT_TEMPLATES = await loadEventTemplatesExternal();
        console.info('Loaded EVENT_TEMPLATES from event-templates.json');
      }catch(e){
        console.error('Failed to load external event-templates.json', e);
        showFatalError('イベントテンプレート読み込みエラー', 'event-templates.json の読み込みに失敗しました。HTTP サーバで配信されているか、ファイルが存在するか確認してください。');
        return; // stop initialization
      }

      const $ = s => document.querySelector(s);
      const board = $("#board"), logEl = $("#log"), diceEl = $("#dice");
      const statTurnEl = $("#stat-turn"), statCurrentEl = $("#stat-current");
      const playersPanelEl = $("#players-panel");
      const btnStart = $("#btn-start"), btnRoll = $("#btn-roll"), btnReset = $("#btn-reset"), btnResults = $("#btn-results");
      const playersCountSel = $("#players-count"), playerNamesWrap = $("#player-names");
      const START_MARKER = $("#start-marker");
      const eventsListEl = $("#events-list"), eventsTabsEl = $("#events-tabs");

      const TILE_SIZE = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-size')) || 68;
      const NUM_TILES = 60;
      const BASE_JITTER = 12;
      const GAP = Number(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 16;
      const TOKEN_MOVE_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--token-move-ms')) || 140;

      let tileCoords = [];
      let state = { started:false, turn:0, currentPlayerIndex:0, players:[], animating:false, rng: Math.random, history: [] };

      function renderPlayerNameInputs(){
        playerNamesWrap.innerHTML = "";
        const count = Math.max(1, Number(playersCountSel.value) || 2);
        for(let i=0;i<count;i++){
          const inp = document.createElement("input");
          inp.type = "text";
          inp.placeholder = `Player ${i+1}`;
          inp.value = `プレイヤー${i+1}`;
          inp.style.width = "120px";
          playerNamesWrap.appendChild(inp);
        }
      }
      playersCountSel.addEventListener("change", renderPlayerNameInputs);
      renderPlayerNameInputs();
      function getPlayerNames(){ return Array.from(playerNamesWrap.querySelectorAll("input")).map((el,idx)=> el.value.trim() || `プレイヤー${idx+1}`); }

      function removeFallbacks(){ document.querySelectorAll('.modal-fallback').forEach(e=>e.remove()); }
      function showCard(title, body){
        return new Promise(resolve=>{
          removeFallbacks();
          const overlay = document.createElement('div'); overlay.className='modal-fallback';
          const card = document.createElement('div'); card.className='card';
          const h = document.createElement('div'); h.className='event-title'; h.textContent = title;
          const b = document.createElement('div'); b.className='event-body'; b.textContent = body;
          const actions = document.createElement('div'); actions.style.textAlign='right';
          const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
          ok.addEventListener('click', ()=>{ overlay.remove(); resolve(true); });
          actions.appendChild(ok);
          card.appendChild(h); card.appendChild(b); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
          ok.focus();
        });
      }

      function pushLog(text, kind){
        const p = document.createElement("div");
        p.textContent = `[${(new Date()).toLocaleTimeString()}] ${text}`;
        if(kind === "ok") p.style.color = "green";
        if(kind === "bad") p.style.color = "#333";
        logEl.appendChild(p);
        logEl.scrollTop = logEl.scrollHeight;
      }

      // helpers to pick event template based on player stage (position):
      function eventStageForPlayer(pl){
        const pos = typeof pl.position === "number" ? pl.position : 0;
        if(pos >= 30) return "senior";
        if(pos >= 15) return "mid";
        return "junior";
      }

      function pickEventForPlayer(playerIndex){
        const pl = state.players[playerIndex];
        if(!pl) return null;
        const stage = eventStageForPlayer(pl);
        const pool = (EVENT_TEMPLATES && EVENT_TEMPLATES[stage]) ? EVENT_TEMPLATES[stage] : [];
        if(!pool || !pool.length) return null;
        // weighting: prefer events that address low attributes
        const weights = pool.map(c => {
          let w = 1;
          const ch = c.changes || {};
          if((pl.learning||0) < 40 && (ch.learning || 0) > 0) w += 1.6;
          if((pl.motivation||0) < 40 && (ch.motivation || 0) > 0) w += 1.4;
          if((pl.rating||0) < 40 && (ch.rating || 0) > 0) w += 1.2;
          if(c.choices) w += 0.3;
          return w;
        });
        const total = weights.reduce((a,b)=>a+b,0);
        let r = state.rng() * total;
        for(let i=0;i<pool.length;i++){
          r -= weights[i];
          if(r <= 0) return pool[i];
        }
        return pool[pool.length-1];
      }

      // event modal & application
      function applyAttributeChanges(playerIndex, changes){
        const pl = state.players[playerIndex];
        if(!pl) return;
        const attrs = ['learning','rating','mental','motivation','responsibility'];
        attrs.forEach(a=>{
          if(typeof changes[a] === 'number' && changes[a] > 0){
            pl[a] = Math.max(0, (pl[a]||0) + Math.round(changes[a]));
          }
        });
        pushLog(`${pl.name}: 属性が変化しました → ${Object.entries(changes).filter(([k,v])=>v>0).map(([k,v])=> `${k} +${v}`).join(', ')}`, "ok");
        renderPlayersPanel();
      }

      async function showEventModal(playerIndex, tmpl){
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const chg = document.createElement('div'); chg.className='event-changes';
        const changes = tmpl.changes || {};
        const parts = [];
        if(changes.learning) parts.push(`学び ＋${changes.learning}`);
        if(changes.rating) parts.push(`評価 ＋${changes.rating}`);
        if(changes.mental) parts.push(`メンタル ＋${changes.mental}`);
        if(changes.motivation) parts.push(`モチベ ＋${changes.motivation}`);
        if(changes.responsibility) parts.push(`責任 ＋${changes.responsibility}`);
        chg.textContent = parts.join('　');
        const actions = document.createElement('div'); actions.style.textAlign='right';
        const ok = document.createElement('button'); ok.className='primary'; ok.textContent='OK';
        ok.addEventListener('click', ()=>{
          applyAttributeChanges(playerIndex, changes);
          overlay.remove();
        });
        actions.appendChild(ok);
        card.appendChild(h); card.appendChild(b); card.appendChild(chg); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
        ok.focus();
      }

      async function showChoiceModal(playerIndex, tmpl){
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        const h = document.createElement('div'); h.className='event-title'; h.textContent = tmpl.title;
        const b = document.createElement('div'); b.className='event-body'; b.textContent = tmpl.body;
        const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px';
        (tmpl.choices||[]).forEach(choice=>{
          const btn = document.createElement('button'); btn.type='button'; btn.className='choice-btn'; btn.textContent = choice.label;
          btn.addEventListener('click', ()=> {
            applyAttributeChanges(playerIndex, choice.changes || {});
            overlay.remove();
            showCard(choice.resultText || "選択結果", "").then(()=>{});
          });
          actions.appendChild(btn);
        });
        const cancel = document.createElement('button'); cancel.type='button'; cancel.textContent='やめる';
        cancel.addEventListener('click', ()=> overlay.remove());
        actions.appendChild(cancel);
        card.appendChild(h); card.appendChild(b); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
      }

      async function handleEventTile(playerIndex){
        const tmpl = pickEventForPlayer(playerIndex);
        if(!tmpl) return;
        if(tmpl.choices && Array.isArray(tmpl.choices)){
          await showChoiceModal(playerIndex, tmpl);
        } else {
          await showEventModal(playerIndex, tmpl);
        }
      }

      /* ----- Path generation & layout (start tile near top-left) ----- */
      function buildConnectedPath(N, containerW, containerH, tileSize, gap){
        const cx = containerW/2, cy = containerH/2;
        const coords = [];
        const margin = Math.max(tileSize*1.6, 28);
        let left = margin, top = margin, right = containerW - margin, bottom = containerH - margin;
        const ringInset = tileSize + gap + Math.round(tileSize*0.4);

        function perimeterPoints(l,t,r,b, spacing){
          const w = Math.max(1, r - l), h = Math.max(1, b - t);
          const perim = 2*(w + h);
          const count = Math.max(4, Math.floor(perim / spacing));
          let topCount = Math.max(1, Math.round(count * (w / perim)));
          let rightCount = Math.max(1, Math.round(count * (h / perim)));
          let bottomCount = Math.max(1, Math.round(count * (w / perim)));
          let leftCount = Math.max(1, Math.round(count * (h / perim)));
          let sum = topCount + rightCount + bottomCount + leftCount;
          let idxAdjust = 0;
          while(sum < count){ if(idxAdjust%4===0) topCount++; else if(idxAdjust%4===1) rightCount++; else if(idxAdjust%4===2) bottomCount++; else leftCount++; idxAdjust++; sum++; }
          while(sum > count){ if(idxAdjust%4===0 && topCount>1) topCount--; else if(idxAdjust%4===1 && rightCount>1) rightCount--; else if(idxAdjust%4===2 && bottomCount>1) bottomCount--; else if(idxAdjust%4===3 && leftCount>1) leftCount--; idxAdjust++; sum--; }
          const pts = [];
          for(let i=0;i<topCount;i++){ const x = l + (i+0.5) * (w / topCount); const y = t; pts.push({x,y}); }
          for(let i=0;i<rightCount;i++){ const x = r; const y = t + (i+0.5) * (h / rightCount); pts.push({x,y}); }
          for(let i=0;i<bottomCount;i++){ const x = r - (i+0.5) * (w / bottomCount); const y = b; pts.push({x,y}); }
          for(let i=0;i<leftCount;i++){ const x = l; const y = b - (i+0.5) * (h / leftCount); pts.push({x,y}); }
          return pts;
        }

        const rings = [];
        let attempts = 0;
        while(coords.length < N - 1 && right - left > tileSize && bottom - top > tileSize && attempts < 24){
          const pts = perimeterPoints(left, top, right, bottom, tileSize + gap);
          rings.push({pts, l:left, t:top, r:right, b:bottom});
          left += ringInset; top += ringInset; right -= ringInset; bottom -= ringInset;
          attempts++;
        }

        let prevExit = null;
        for(let ri = 0; ri < rings.length && coords.length < N - 1; ri++){
          const ring = rings[ri];
          const pts = ring.pts.slice();
          let startIdx = 0;
          if(prevExit){
            let best = 0, bestD = Infinity;
            for(let k=0;k<pts.length;k++){
              const dx = pts[k].x - prevExit.x, dy = pts[k].y - prevExit.y;
              const d = Math.hypot(dx,dy);
              if(d < bestD){ best = k; bestD = d; }
            }
            startIdx = best;
          } else {
            // prefer point close to top-left to make tile 0 be left-top-ish
            let best = 0, bestD = Infinity;
            const topLeft = {x: ring.l + 6, y: ring.t + 6};
            for(let k=0;k<pts.length;k++){
              const dx = pts[k].x - topLeft.x, dy = pts[k].y - topLeft.y;
              const d = Math.hypot(dx,dy);
              if(d < bestD){ best = k; bestD = d; }
            }
            startIdx = best;
          }

          for(let k=0;k<pts.length && coords.length < N - 1;k++){
            const idx = (startIdx + k) % pts.length;
            const jitterX = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
            const jitterY = (Math.random()*2 -1) * (BASE_JITTER * 0.4);
            coords.push({x: pts[idx].x + jitterX, y: pts[idx].y + jitterY, ang: (Math.random()*2-1)*6});
          }
          prevExit = coords[coords.length-1];
          if(ri < rings.length - 1 && coords.length < N - 1){
            const inner = rings[ri+1];
            const innerCenter = {x: (inner.l + inner.r)/2, y: (inner.t + inner.b)/2};
            const connX = prevExit.x + (innerCenter.x - prevExit.x) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
            const connY = prevExit.y + (innerCenter.y - prevExit.y) * 0.25 + (Math.random()*2-1)*(BASE_JITTER*0.6);
            coords.push({x: connX, y: connY, ang: (Math.random()*2-1)*6});
            prevExit = coords[coords.length-1];
          }
        }

        if(coords.length < N - 1){
          const remaining = (N - 1) - coords.length;
          for(let i=0;i<remaining;i++){
            const angle = (i/remaining) * Math.PI * 2;
            const radius = Math.min(containerW, containerH) * 0.11 + (i%3) * (tileSize*0.4);
            const x = cx + Math.cos(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
            const y = cy + Math.sin(angle) * radius + (Math.random()*2-1)*BASE_JITTER;
            coords.push({x,y,ang:(Math.random()*2-1)*8});
          }
        }

        coords.push({x: cx, y: cy, ang:0});
        const clampMargin = tileSize;
        for(const c of coords){
          c.x = Math.max(clampMargin, Math.min(containerW - clampMargin, c.x));
          c.y = Math.max(clampMargin, Math.min(containerH - clampMargin, c.y));
        }
        if(coords.length > N) coords.length = N;
        return coords;
      }

      function layoutTiles(){
        board.querySelectorAll(".tile").forEach(n=>n.remove());
        const rect = board.getBoundingClientRect();
        const coords = buildConnectedPath(NUM_TILES, rect.width, rect.height, TILE_SIZE, GAP);
        tileCoords = coords;
        coords.forEach((c, idx)=>{
          const div = document.createElement("div");
          div.className = "tile";
          div.dataset.pathIndex = String(idx);
          if(idx === NUM_TILES - 1){
            div.classList.add("goal");
            div.textContent = "GOAL";
          } else if(idx % 11 === 0){
            div.classList.add("client");
          } else if(idx % 13 === 0){
            div.classList.add("workshop");
          } else if(idx % 6 === 0){
            div.classList.add("event");
          } else if(idx % 5 === 0){
            div.classList.add("bonus");
          } else if(idx % 7 === 0){
            div.classList.add("penalty");
          }
          div.style.left = `${c.x}px`;
          div.style.top = `${c.y}px`;
          const rot = c.ang || ((Math.random()*2-1)*6);
          div.style.transform = `translate(-50%,-50%) rotate(${rot}deg)`;
          board.appendChild(div);
        });

        // align START_MARKER to tile 0 (slight offset above tile)
        if(tileCoords && tileCoords[0]){
          const t0 = tileCoords[0];
          START_MARKER.style.left = `${t0.x}px`;
          START_MARKER.style.top = `${t0.y}px`;
          START_MARKER.style.display = 'grid';
        } else {
          START_MARKER.style.display = 'none';
        }

        placeAllTokens();
      }

      /* Token & movement (kept stable) */
      function ensureToken(i){
        let t = document.getElementById(`token-${i}`);
        if(!t){
          t = document.createElement("div"); t.className = "token"; t.id = `token-${i}`;
          t.textContent = String(i+1);
          t.style.background = (["#86BB27","#DFF3C6","#C4C4C4","#000000"][i % 4]) || "#86BB27";
          board.appendChild(t);
        }
        return t;
      }

      function placeAllTokens(){
        const groups = new Map();
        state.players.forEach((pl,i)=>{
          const pos = (typeof pl.position === "number" && pl.position >= 0) ? pl.position : "__start";
          if(!groups.has(pos)) groups.set(pos, []);
          groups.get(pos).push(i);
        });
        const bRect = board.getBoundingClientRect();
        if(groups.has("__start")){
          const startIdxs = groups.get("__start");
          const sRect = START_MARKER.getBoundingClientRect();
          const sx = (sRect.left - bRect.left) + sRect.width/2;
          const sy = (sRect.top - bRect.top) + sRect.height/2;
          startIdxs.forEach((pi,k)=>{
            const t = ensureToken(pi);
            const offX = ((k % 2) - 0.5) * 18;
            const offY = (Math.floor(k/2) - 0.5) * 18;
            t.style.transform = `translate(${sx + offX}px, ${sy + offY}px)`;
          });
        }
        groups.forEach((idxs, pos)=>{
          if(pos === "__start") return;
          const center = tileCoords[pos];
          if(!center) return;
          const n = idxs.length;
          const baseR = Math.max(14, TILE_SIZE * 0.28);
          if(n === 1){
            const t = ensureToken(idxs[0]);
            t.style.transform = `translate(${center.x}px, ${center.y}px)`;
          } else {
            const perOuter = 6;
            const outerCount = Math.min(n, perOuter);
            const innerCount = Math.max(0, n - perOuter);
            let used = 0;
            const outerR = baseR;
            for(let k=0;k<outerCount;k++){
              const ang = (k / outerCount) * Math.PI * 2 - Math.PI/2;
              const x = center.x + Math.cos(ang) * outerR;
              const y = center.y + Math.sin(ang) * outerR;
              const t = ensureToken(idxs[used++]);
              t.style.transform = `translate(${x}px, ${y}px)`;
            }
            if(innerCount > 0){
              const innerR = baseR * 0.6;
              for(let k=0;k<innerCount;k++){
                const ang = (k / innerCount) * Math.PI * 2 - Math.PI/2;
                const x = center.x + Math.cos(ang) * innerR;
                const y = center.y + Math.sin(ang) * innerR;
                const t = ensureToken(idxs[used++]);
                t.style.transform = `translate(${x}px, ${y}px)`;
              }
            }
          }
        });
      }

      // Final results calculation & modal
      // Score formula: weighted sum (adjust weights as desired)
      const SCORE_WEIGHTS = { rating: 3.0, learning: 1.5, motivation: 1.2, mental: 1.0, responsibility: 2.0 };

      function computeFinalResults(){
        // returns array of { index, name, score, attrs, finishedAt }
        const rows = state.players.map((p, i) => {
          const attrs = {
            learning: Number(p.learning || 0),
            rating: Number(p.rating || 0),
            mental: Number(p.mental || 0),
            motivation: Number(p.motivation || 0),
            responsibility: Number(p.responsibility || 0)
          };
          const score = Math.round(
            attrs.rating * SCORE_WEIGHTS.rating +
            attrs.learning * SCORE_WEIGHTS.learning +
            attrs.motivation * SCORE_WEIGHTS.motivation +
            attrs.mental * SCORE_WEIGHTS.mental +
            attrs.responsibility * SCORE_WEIGHTS.responsibility
          );
          return {
            index: i,
            name: p.name,
            score,
            attrs,
            finishedAt: p.finishedAt || null,
            finished: !!p.finished
          };
        });

        // sort by score desc, tie-breaker: finishedAt (earlier finish = better), then name
        rows.sort((a,b)=>{
          if(b.score !== a.score) return b.score - a.score;
          if(a.finished && b.finished){
            if(a.finishedAt && b.finishedAt) return a.finishedAt - b.finishedAt;
            if(a.finishedAt) return -1;
            if(b.finishedAt) return 1;
          }
          return a.name.localeCompare(b.name, 'ja');
        });

        // add rank (1..n), handle ties (same score -> same rank)
        let lastScore = null, lastRank = 0, count = 0;
        rows.forEach(r=>{
          count++;
          if(r.score !== lastScore){
            lastRank = count;
            lastScore = r.score;
          }
          r.rank = lastRank;
        });

        return rows;
      }

      function showFinalResultsModal(){
        const results = computeFinalResults();
        removeFallbacks();
        const overlay = document.createElement('div'); overlay.className='modal-fallback';
        const card = document.createElement('div'); card.className='card';
        card.style.maxWidth = '920px';
        const title = document.createElement('div'); title.className = 'event-title'; title.textContent = '最終結果';
        const subtitle = document.createElement('div'); subtitle.className='small-muted'; subtitle.textContent = `集計: ${new Date().toLocaleString()}`;
        card.appendChild(title); card.appendChild(subtitle);

        const table = document.createElement('table'); table.className = 'results-table';
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr><th>順位</th><th>名前</th><th>スコア</th><th>学び</th><th>評価</th><th>メンタル</th><th>モチベ</th><th>責任</th><th>備考</th></tr>`;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');

        results.forEach((r, i) => {
          const tr = document.createElement('tr');
          if(i === 0) tr.classList.add('results-winner');
          const note = r.finished ? (r.finishedAt ? `ゴール済 (${new Date(r.finishedAt).toLocaleTimeString()})` : 'ゴール済') : '';
          tr.innerHTML = `<td>${r.rank}</td><td>${r.name}</td><td>${r.score}</td>
            <td>${r.attrs.learning}</td><td>${r.attrs.rating}</td><td>${r.attrs.mental}</td><td>${r.attrs.motivation}</td><td>${r.attrs.responsibility}</td>
            <td class="small-muted">${note}</td>`;
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        card.appendChild(table);

        // actions: close / download CSV / copy JSON
        const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px'; actions.style.marginTop='12px';

        const btnDownload = document.createElement('button'); btnDownload.textContent = 'CSVダウンロード';
        btnDownload.addEventListener('click', () => {
          const csv = csvFromResults(results);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url;
          a.download = `results_${(new Date()).toISOString().replace(/[:.]/g,'-')}.csv`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        });

        const btnCopyJSON = document.createElement('button'); btnCopyJSON.textContent = 'JSONコピー';
        btnCopyJSON.addEventListener('click', async () => {
          try{
            await navigator.clipboard.writeText(JSON.stringify(results, null, 2));
            pushLog('結果をクリップボードにコピーしました', 'ok');
          }catch(e){
            pushLog('クリップボードへのコピーに失敗しました', 'bad');
          }
        });

        const btnClose = document.createElement('button'); btnClose.className='primary'; btnClose.textContent='閉じる';
        btnClose.addEventListener('click', ()=> { overlay.remove(); });

        actions.appendChild(btnDownload); actions.appendChild(btnCopyJSON); actions.appendChild(btnClose);
        card.appendChild(actions);
        overlay.appendChild(card);
        document.body.appendChild(overlay);
      }

      function csvFromResults(results){
        const header = ['順位','名前','スコア','学び','評価','メンタル','モチベ','責任','ゴール'];
        const rows = results.map(r => [
          r.rank, r.name, r.score, r.attrs.learning, r.attrs.rating, r.attrs.mental, r.attrs.motivation, r.attrs.responsibility, r.finished ? (r.finishedAt? new Date(r.finishedAt).toISOString() : 'yes') : ''
        ]);
        const lines = [header.join(',')].concat(rows.map(cols => cols.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')));
        return lines.join('\n');
      }

      // When a player reaches goal, mark finishedAt timestamp and check all-finished
      async function resolveCell(playerIndex, pathIndex){
        const pl = state.players[playerIndex];
        if(pl == null) return;
        const tileEl = board.querySelector(`.tile[data-path-index="${pathIndex}"]`);
        if(!tileEl){ renderPlayersPanel(); return; }
        if(tileEl.classList.contains("goal")){
          if(!pl.finished){
            pl.finished = true;
            pl.finishedAt = Date.now();
          }
          pushLog(`${pl.name}: ゴール！`, "ok");
          await showCard("ゴール", `${pl.name} がゴールしました`);
          renderPlayersPanel();
          // if all finished -> show final results automatically after short delay
          const allFinished = state.players.length > 0 && state.players.every(p => !!p.finished);
          if(allFinished){
            setTimeout(()=> showFinalResultsModal(), 400);
          }
        } else {
          renderPlayersPanel();
        }
      }

      // rest of movement functions (moveTokenStep / animateMove) remain unchanged - they call handleEventTile or resolveCell

      // per-tile movement function already defined earlier; re-use existing ones (they call resolveCell)

      async function rollTurn(){
        if(!state.started || state.animating) return;
        const current = state.currentPlayerIndex;
        const val = Math.floor(Math.random()*6)+1;
        if(diceEl) diceEl.textContent = String(val);
        pushLog(`${state.players[current].name} がサイコロを振りました`);
        await animateMove(current, val);
        nextPlayerTurn();
      }

      // Attach result button handler and other handlers
      function attachHandlers(){
        btnStart.addEventListener("click", ()=> startGame());
        btnRoll.addEventListener("click", ()=> rollTurn());
        btnReset.addEventListener("click", ()=> resetGame());
        btnResults.addEventListener("click", ()=> showFinalResultsModal());
        window.addEventListener("resize", ()=> layoutTiles());
        window.addEventListener("keydown", (e)=>{
          if((e.key === " " || e.key === "Enter") && state.started && !state.animating){
            e.preventDefault();
            rollTurn();
          }
        });
      }

      // Ensure functions referenced above exist in current scope. Some functions (moveTokenStep, animateMove, etc.)
      // were defined earlier in the file; if not, the earlier defined versions will be used since this file includes them.
      // Start game / UI wiring:
      function startGame(){
        if(state.started) return;
        const names = getPlayerNames();
        state.players = names.map((n,i)=>({
          name: n,
          position: 0, // start at tile0
          learning: 50,
          rating: 50,
          mental: 50,
          motivation: 50,
          responsibility: 0,
          finished: false,
          finishedAt: null
        }));
        state.started = true;
        state.turn = 1;
        state.currentPlayerIndex = 0;
        statTurnEl.textContent = String(state.turn);
        statCurrentEl.textContent = state.players[state.currentPlayerIndex].name;
        layoutTiles();
        renderPlayersPanel();
        pushLog("ゲームを開始しました（プレイヤーはスタートマスに配置されます）", "ok");
        updateRollState();
      }

      function resetGame(){
        state.started = false;
        state.turn = 0;
        state.currentPlayerIndex = 0;
        state.players = [];
        statTurnEl.textContent = "0";
        statCurrentEl.textContent = "-";
        board.querySelectorAll(".token").forEach(t=>t.remove());
        playersPanelEl.innerHTML = "";
        pushLog("ゲームをリセットしました", "ok");
        updateRollState();
      }

      // Some functions used above (moveTokenStep, animateMove, etc.) were defined earlier in the file.
      // If they were defined below in the original file, they remain available (function hoisting). For clarity ensure attachHandlers/layout call below.

      attachHandlers();
      layoutTiles();
      renderEventsPanel();
      pushLog("UI ready — EVENT_TEMPLATES loaded and results feature enabled");
    }

    // init attached above via load listener
  })();
  </script>
</body>
</html>
